<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>前端面试题十万字资料 | Work for money</title>
<link rel="shortcut icon" href="https://coderdml.github.io/favicon.ico?v=1680666558496">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://coderdml.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="前端面试题十万字资料 | Work for money - Atom Feed" href="https://coderdml.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="JS 章节
内置类型
JS 中分为七种内置类型，七种内置类型⼜分为两⼤类型：基本类型和对象（Object）。
基本类型有六种： null ， undefined ， boolean ， number ， string ， symbol 。
..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://coderdml.github.io">
  <img class="avatar" src="https://coderdml.github.io/images/avatar.png?v=1680666558496" alt="">
  </a>
  <h1 class="site-title">
    Work for money
  </h1>
  <p class="site-description">
    study for more money
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              前端面试题十万字资料
            </h2>
            <div class="post-info">
              <span>
                2023-03-17
              </span>
              <span>
                47 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>JS 章节<br>
内置类型<br>
JS 中分为七种内置类型，七种内置类型⼜分为两⼤类型：基本类型和对象（Object）。<br>
基本类型有六种： null ， undefined ， boolean ， number ， string ， symbol 。<br>
其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使<br>
⽤中会遇到某些 Bug。 NaN 也属于 number 类型，并且 NaN 不等于⾃身。<br>
对于基本类型来说，如果使⽤字⾯量的⽅式，那么这个变量只是个字⾯量，只有在必要的时<br>
候才会转换为对应的类型<br>
对象（Object）是引⽤类型，在使⽤过程中会遇到浅拷⻉和深拷⻉的问题。<br>
Typeof<br>
typeof 对于基本类型，除了 null 都可以显示正确的类型<br>
let a = 111 // 这只是字⾯量，不是 number 类型<br>
a.toString() // 使⽤时候才会转换为对象类型<br>
let a = { name: 'FE' }<br>
let b = a<br>
b.name = 'EF'<br>
console.log(a.name) // EF<br>
typeof 对于对象，除了函数都会显示 object<br>
对于 null 来说，虽然它是基本类型，但是会显示 object ，这是⼀个存在很久了的 Bug<br>
PS：为什么会出现这种情况呢？因为在 JS 的最初版本中，使⽤的是 32 位系统，为了性能考<br>
虑使⽤低位存储了变量的类型信息， 000 开头代表是对象，然⽽ null 表示为全零，所以将<br>
它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却<br>
是⼀直流传下来。<br>
如果我们想获得⼀个变量的正确类型，可以通过 Object.prototype.toString.call(xx) 。<br>
这样我们就可以获得类似 [object Type] 的字符串。<br>
typeof 1 // 'number'<br>
typeof '1' // 'string'<br>
typeof undefined // 'undefined'<br>
typeof true // 'boolean'<br>
typeof Symbol() // 'symbol'<br>
typeof b // b 没有声明，但是还会显示 undefined<br>
typeof [] // 'object'<br>
typeof {} // 'object'<br>
typeof console.log // 'function'<br>
typeof null // 'object'<br>
类型转换<br>
转Boolean<br>
在条件判断时，除了 undefined ， null ， false ， NaN ， '' ， 0 ， -0 ，其他所有<br>
值都转为 true ，包括所有对象。<br>
对象转基本类型<br>
对象在转换基本类型时，⾸先会调⽤ valueOf 然后调⽤ toString 。并且这两个⽅法你是<br>
可以重写的。<br>
当然你也可以重写 Symbol.toPrimitive ，该⽅法在转基本类型时调⽤优先级最⾼。<br>
let a<br>
// 我们也可以这样判断 undefined<br>
a === undefined<br>
// 但是 undefined 不是保留字，能够在低版本浏览器被赋值<br>
let undefined = 1<br>
// 这样判断就会出错<br>
// 所以可以⽤下⾯的⽅式来判断，并且代码量更少<br>
// 因为 void 后⾯随便跟上⼀个组成表达式<br>
// 返回就是 undefined<br>
a === void 0<br>
let a = {<br>
valueOf() {<br>
return 0<br>
}<br>
}<br>
四则运算符<br>
只有当加法运算时，其中⼀⽅是字符串类型，就会把另⼀个也转为字符串类型。其他运算只<br>
要其中⼀⽅是数字，那么另⼀⽅就转为数字。并且加法运算会触发三种类型转换：将值转换<br>
为原始值，转换为数字，转换为字符串。<br>
对于加号需要注意这个表达式 'a' + + 'b'<br>
let a = {<br>
valueOf() {<br>
return 0;<br>
},<br>
toString() {<br>
return '1';<br>
},<br>
<a href="">Symbol.toPrimitive</a> {<br>
return 2;<br>
}<br>
}<br>
1 + a // =&gt; 3<br>
'1' + a // =&gt; '12'<br>
1 + '1' // '11'<br>
2 * '2' // 4<br>
[1, 2] + [2, 1] // '1,22,1'<br>
// [1, 2].toString() -&gt; '1,2'<br>
// [2, 1].toString() -&gt; '2,1'<br>
// '1,2' + '2,1' = '1,22,1'<br>
'a' + + 'b' // -&gt; &quot;aNaN&quot;<br>
// 因为 + 'b' -&gt; NaN<br>
// 你也许在⼀些代码中看到过 + '1' -&gt; 1<br>
==== 操作符<br>
上图中的 toPrimitive 就是对象转基本类型。<br>
这⾥来解析⼀道题⽬ [] == ![] // -&gt; true ，下⾯是这个表达式为何为 true 的步骤<br>
⽐较运算符</p>
<ol>
<li>如果是对象，就通过 toPrimitive 转换对象</li>
<li>如果是字符串，就通过 unicode 字符索引来⽐较<br>
原型<br>
// [] 转成 true，然后取反变成 false<br>
[] == false<br>
// 根据第 8 条得出<br>
[] == ToNumber(false)<br>
[] == 0<br>
// 根据第 10 条得出<br>
ToPrimitive([]) == 0<br>
// [].toString() -&gt; ''<br>
'' == 0<br>
// 根据第 6 条得出<br>
0 == 0 // -&gt; true<br>
每个函数都有 prototype 属性，除了 Function.prototype.bind() ，该属性指向原型。<br>
每个对象都有 <strong>proto</strong> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向<br>
了 [[prototype]] ，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使⽤<br>
<em>proto</em> 来访问。<br>
对象可以通过 <strong>proto</strong> 来寻找不属于该对象的属性， <strong>proto</strong> 将对象连接起来组成了<br>
原型链。<br>
如果你想更进⼀步的了解原型，可以仔细阅读 深度解析原型中的各个难点。<br>
new</li>
<li>新⽣成了⼀个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象<br>
在调⽤ new 的过程中会发⽣以上四件事情，我们也可以试着来⾃⼰实现⼀个 new<br>
对于实例对象来说，都是通过 new 产⽣的，⽆论是 function Foo() 还是 let a = { b :<br>
1 } 。<br>
对于创建⼀个对象来说，更推荐使⽤字⾯量的⽅式创建对象（⽆论性能上还是可读性）。因<br>
为你使⽤ new Object() 的⽅式创建对象需要通过作⽤域链⼀层层找到 Object ，但是你使<br>
⽤字⾯量的⽅式就没这个问题。<br>
function create() {<br>
// 创建⼀个空的对象<br>
let obj = new Object()<br>
// 获得构造函数<br>
let Con = [].shift.call(arguments)<br>
// 链接到原型<br>
obj.<strong>proto</strong> = Con.prototype<br>
// 绑定 this，执⾏构造函数<br>
let result = Con.apply(obj, arguments)<br>
// 确保 new 出来的是个对象<br>
return typeof result === 'object' ? result : obj<br>
}<br>
function Foo() {}<br>
// function 就是个语法糖<br>
// 内部等同于 new Function()<br>
let a = { b: 1 }<br>
// 这个字⾯量内部也是使⽤了 new Object()<br>
对于 new 来说，还需要注意下运算符优先级。<br>
从上图可以看出， new Foo() 的优先级⼤于 new Foo ，所以对于上述代码来说可以这样划<br>
分执⾏顺序<br>
对于第⼀个函数来说，先执⾏了 Foo.getName() ，所以结果为 1；对于后者来说，先执⾏<br>
new Foo() 产⽣了⼀个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果<br>
为 2。<br>
function Foo() {<br>
return this;<br>
}<br>
Foo.getName = function () {<br>
console.log('1');<br>
};<br>
Foo.prototype.getName = function () {<br>
console.log('2');<br>
};<br>
new Foo.getName(); // -&gt; 1<br>
new Foo().getName(); // -&gt; 2<br>
new (Foo.getName());<br>
(new Foo()).getName();<br>
instanceof<br>
instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是<br>
能找到类型的 prototype 。<br>
我们也可以试着实现⼀下 instanceof<br>
this<br>
this 是很多⼈会混淆的概念，但是其实他⼀点都不难，你只需要记住⼏个规则就可以了。<br>
function instanceof(left, right) {<br>
// 获得类型的原型<br>
let prototype = right.prototype<br>
// 获得对象的原型<br>
left = left.<strong>proto</strong><br>
// 判断对象的类型是否等于类型的原型<br>
while (true) {<br>
if (left === null)<br>
return false<br>
if (prototype === left)<br>
return true<br>
left = left.<strong>proto</strong><br>
}<br>
}<br>
function foo() {<br>
console.log(this.a)<br>
}<br>
var a = 1<br>
foo()<br>
var obj = {<br>
a: 2,<br>
foo: foo<br>
以上⼏种情况明⽩了，很多代码中的 this 应该就没什么问题了，下⾯让我们看看箭头函数<br>
中的 this<br>
箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外⾯的第⼀个不是箭头函数<br>
的函数的 this 。在这个例⼦中，因为调⽤ a 符合前⾯代码中的第⼀个情况，所以 this<br>
是 window 。并且 this ⼀旦绑定了上下⽂，就不会被任何代码改变。<br>
执⾏上下⽂<br>
当执⾏ JS 代码时，会产⽣三种执⾏上下⽂<br>
全局执⾏上下⽂<br>
函数执⾏上下⽂<br>
}<br>
obj.foo()<br>
// 以上两者情况 <code>this</code> 只依赖于调⽤函数前的对象，优先级是第⼆个情况⼤于第⼀个情况<br>
// 以下情况是优先级最⾼的，<code>this</code> 只会绑定在 <code>c</code> 上，不会被任何⽅式修改 <code>this</code> 指<br>
向<br>
var c = new foo()<br>
c.a = 3<br>
console.log(c.a)<br>
// 还有种就是利⽤ call，apply，bind 改变 this，这个优先级仅次于 new<br>
function a() {<br>
return () =&gt; {<br>
return () =&gt; {<br>
console.log(this)<br>
}<br>
}<br>
}<br>
console.log(a()()())<br>
eval 执⾏上下⽂<br>
每个执⾏上下⽂中都有三个重要的属性<br>
变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下⽂中访问<br>
作⽤域链（JS 采⽤词法作⽤域，也就是说变量的作⽤域是在定义时就决定了）<br>
this<br>
对于上述代码，执⾏栈中有两个上下⽂：全局上下⽂和函数 foo 上下⽂。<br>
对于全局上下⽂来说，VO ⼤概是这样的<br>
对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO）<br>
var a = 10<br>
function foo(i) {<br>
var b = 20<br>
}<br>
foo()<br>
stack = [<br>
globalContext,<br>
fooContext<br>
]<br>
globalContext.VO === globe<br>
globalContext.VO = {<br>
a: undefined,<br>
foo: <Function>,<br>
}<br>
对于作⽤域链，可以把它理解成包含⾃身变量对象和上级变量对象的列表，通过 [[Scope]]<br>
属性查找上级变量<br>
接下来让我们看⼀个⽼⽣常谈的例⼦， var<br>
fooContext.VO === foo.AO<br>
fooContext.AO {<br>
i: undefined,<br>
b: undefined,<br>
arguments: &lt;&gt;<br>
}<br>
// arguments 是函数独有的对象(箭头函数没有)<br>
// 该对象是⼀个伪数组，有 <code>length</code> 属性且可以通过下标访问元素<br>
// 该对象中的 <code>callee</code> 属性代表函数本身<br>
// <code>caller</code> 属性代表函数的调⽤者<br>
fooContext.[[Scope]] = [<br>
globalContext.VO<br>
]<br>
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO<br>
fooContext.Scope = [<br>
fooContext.VO,<br>
globalContext.VO<br>
]<br>
b() // call b<br>
console.log(a) // undefined<br>
var a = 'Hello world'<br>
function b() {<br>
console.log('call b')<br>
}<br>
想必以上的输出⼤家肯定都已经明⽩了，这是因为函数和变量提升的原因。通常提升的解释<br>
是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤家理解。但是更准确的解释<br>
应该是：在⽣成执⾏上下⽂时，会有两个阶段。第⼀个阶段是创建的阶段（具体步骤是创建<br>
VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数<br>
的话会将整个函数存⼊内存中，变量只声明并且赋值为 undefined，所以在第⼆个阶段，也就<br>
是代码执⾏阶段，我们可以直接提前使⽤。<br>
在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升<br>
var 会产⽣很多错误，所以在 ES6中引⼊了 let 。 let 不能在声明前使⽤，但是这并不是<br>
常说的 let 不会提升， let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前<br>
使⽤。<br>
对于⾮匿名的⽴即执⾏函数需要注意以下⼀点<br>
因为当 JS 解释器在遇到⾮匿名的⽴即执⾏函数时，会创建⼀个辅助的特定对象，然后将函数<br>
名称作为这个对象的属性，因此函数内部才可以访问到 foo ，但是这个值⼜是只读的，所以<br>
对它的赋值并不⽣效，所以打印的结果还是这个函数，并且外部的值也没有发⽣更改。<br>
b() // call b second<br>
function b() {<br>
console.log('call b fist')<br>
}<br>
function b() {<br>
console.log('call b second')<br>
}<br>
var b = 'Hello world'<br>
var foo = 1<br>
(function foo() {<br>
foo = 10<br>
console.log(foo)<br>
}()) // -&gt; ƒ foo() { foo = 10 ; console.log(foo) }<br>
闭包<br>
闭包的定义很简单：函数 A 返回了⼀个函数 B，并且函数 B 中使⽤了函数 A 的变量，函数 B<br>
就被称为闭包。<br>
你是否会疑惑，为什么函数 A 已经弹出调⽤栈了，为什么函数 B 还能引⽤到函数 A 中的变<br>
量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出<br>
哪些变量需要存储在堆上，哪些需要存储在栈上。<br>
经典⾯试题，循环中使⽤闭包解决 var 定义函数的问题<br>
specialObject = {};</li>
</ol>
<p>Scope = specialObject + Scope;</p>
<p>foo = new FunctionExpression;<br>
foo.[[Scope]] = Scope;<br>
specialObject.foo = foo; // {DontDelete}, {ReadOnly}</p>
<p>delete Scope[0]; // remove specialObject from the front of scope chain<br>
function A() {<br>
let a = 1<br>
function B() {<br>
console.log(a)<br>
}<br>
return B<br>
}<br>
for ( var i=1; i&lt;=5; i++) {<br>
setTimeout( function timer() {<br>
console.log( i );<br>
}, i<em>1000 );<br>
}<br>
⾸先因为 setTimeout 是个异步函数，所有会先把循环全部执⾏完毕，这时候 i 就是 6<br>
了，所以会输出⼀堆 6。<br>
解决办法两种，第⼀种使⽤闭包<br>
第⼆种就是使⽤ setTimeout 的第三个参数<br>
第三种就是使⽤ let 定义 i 了<br>
因为对于 let 来说，他会创建⼀个块级作⽤域，相当于<br>
for (var i = 1; i &lt;= 5; i++) {<br>
(function(j) {<br>
setTimeout(function timer() {<br>
console.log(j);<br>
}, j * 1000);<br>
})(i);<br>
}<br>
for ( var i=1; i&lt;=5; i++) {<br>
setTimeout( function timer(j) {<br>
console.log( j );<br>
}, i</em>1000, i);<br>
}<br>
for ( let i=1; i&lt;=5; i++) {<br>
setTimeout( function timer() {<br>
console.log( i );<br>
}, i<em>1000 );<br>
}<br>
{ // 形成块级作⽤域<br>
let i = 0<br>
{<br>
深浅拷⻉<br>
从上述例⼦中我们可以发现，如果给⼀个变量赋值⼀个对象，那么两者的值会是同⼀个引<br>
⽤，其中⼀⽅改变，另⼀⽅也会相应改变。<br>
通常在开发中我们不希望出现这样的问题，我们可以使⽤浅拷⻉来解决这个问题。<br>
浅拷⻉<br>
⾸先可以通过 Object.assign 来解决这个问题。<br>
let ii = i<br>
setTimeout( function timer() {<br>
console.log( ii );<br>
}, i</em>1000 );<br>
}<br>
i++<br>
{<br>
let ii = i<br>
}<br>
i++<br>
{<br>
let ii = i<br>
}<br>
...<br>
}<br>
let a = {<br>
age: 1<br>
}<br>
let b = a<br>
a.age = 2<br>
console.log(b.age) // 2<br>
当然我们也可以通过展开运算符（…）来解决<br>
通常浅拷⻉就能解决⼤部分问题了，但是当我们遇到如下情况就需要使⽤到深拷⻉了<br>
浅拷⻉只解决了第⼀层的问题，如果接下去的值中还有对象的话，那么就⼜回到刚开始的话<br>
题了，两者享有相同的引⽤。要解决这个问题，我们需要引⼊深拷⻉。<br>
let a = {<br>
age: 1<br>
}<br>
let b = Object.assign({}, a)<br>
a.age = 2<br>
console.log(b.age) // 1<br>
let a = {<br>
age: 1<br>
}<br>
let b = {...a}<br>
a.age = 2<br>
console.log(b.age) // 1<br>
let a = {<br>
age: 1,<br>
jobs: {<br>
first: 'FE'<br>
}<br>
}<br>
let b = {...a}<br>
a.jobs.first = 'native'<br>
console.log(b.jobs.first) // native<br>
深拷⻉<br>
这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。<br>
但是该⽅法也是有局限性的：<br>
会忽略 undefined<br>
会忽略 symbol<br>
不能序列化函数<br>
不能解决循环引⽤的对象<br>
let a = {<br>
age: 1,<br>
jobs: {<br>
first: 'FE'<br>
}<br>
}<br>
let b = JSON.parse(JSON.stringify(a))<br>
a.jobs.first = 'native'<br>
console.log(b.jobs.first) // FE<br>
let obj = {<br>
a: 1,<br>
b: {<br>
c: 2,<br>
d: 3,<br>
},<br>
}<br>
obj.c = obj.b<br>
obj.e = obj.a<br>
obj.b.c = obj.c<br>
obj.b.d = obj.b<br>
obj.b.e = obj.b.c<br>
let newObj = JSON.parse(JSON.stringify(obj))<br>
console.log(newObj)<br>
如果你有这么⼀个循环引⽤对象，你会发现你不能通过该⽅法深拷⻉<br>
在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化<br>
你会发现在上述情况中，该⽅法会忽略掉函数和 undefined 。<br>
但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决⼤部分问题，并且<br>
该函数是内置函数中处理深拷⻉性能最快的。当然如果你的数据中含有以上三种情况下，可<br>
以使⽤ lodash 的深拷⻉函数。<br>
如果你所需拷⻉的对象含有内置类型并且不包含函数，可以使⽤ MessageChannel<br>
let a = {<br>
age: undefined,<br>
sex: Symbol('male'),<br>
jobs: function() {},<br>
name: 'yck'<br>
}<br>
let b = JSON.parse(JSON.stringify(a))<br>
console.log(b) // {name: &quot;yck&quot;}<br>
function structuralClone(obj) {<br>
return new Promise(resolve =&gt; {<br>
const {port1, port2} = new MessageChannel();<br>
port2.onmessage = ev =&gt; resolve(ev.data);<br>
port1.postMessage(obj);<br>
});<br>
}<br>
var obj = {a: 1, b: {<br>
c: b<br>
模块化<br>
在有 Babel 的情况下，我们可以直接使⽤ ES6 的模块化<br>
CommonJS<br>
CommonJs 是 Node 独有的规范，浏览器中使⽤就需要⽤到 Browserify 解析了。<br>
}}<br>
// 注意该⽅法是异步的<br>
// 可以处理 undefined 和循环引⽤对象<br>
(async () =&gt; {<br>
const clone = await structuralClone(obj)<br>
})()<br>
// file a.js<br>
export function a() {}<br>
export function b() {}<br>
// file b.js<br>
export default function() {}<br>
import {a, b} from './a.js'<br>
import XXX from './b.js'<br>
// a.js<br>
module.exports = {<br>
a: 1<br>
}<br>
// or<br>
exports.a = 1<br>
// b.js<br>
var module = require('./a.js')<br>
module.a // -&gt; log 1<br>
在上述代码中， module.exports 和 exports 很容易混淆，让我们来看看⼤致内部实现<br>
再来说说 module.exports 和 exports ，⽤法其实是相似的，但是不能对 exports 直接<br>
赋值，不会有任何效果。<br>
对于 CommonJS 和 ES6 中的模块化的两者区别是：<br>
前者⽀持动态导⼊，也就是 require(${path}/xx.js) ，后者⽬前不⽀持，但是已有提<br>
案<br>
前者是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不<br>
⼤。⽽后者是异步导⼊，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染<br>
有很⼤影响<br>
前者在导出时都是值拷⻉，就算导出的值变了，导⼊的值也不会改变，所以如果想更新<br>
值，必须重新导⼊⼀次。但是后者采⽤实时绑定的⽅式，导⼊导出的值都指向同⼀个内存<br>
地址，所以导⼊值会跟随导出值变化<br>
var module = require('./a.js')<br>
module.a<br>
// 这⾥其实就是包装了⼀层⽴即执⾏函数，这样就不会污染全局变量了，<br>
// 重要的是 module 这⾥，module 是 Node 独有的⼀个变量<br>
module.exports = {<br>
a: 1<br>
}<br>
// 基本实现<br>
var module = {<br>
exports: {} // exports 就是个空对象<br>
}<br>
// 这个是为什么 exports 和 module.exports ⽤法相似的原因<br>
var exports = module.exports<br>
var load = function (module) {<br>
// 导出的东⻄<br>
var a = 1<br>
module.exports = a<br>
return module.exports<br>
};<br>
后者会编译成 require/exports 来执⾏的<br>
AMD<br>
AMD 是由 RequireJS 提出的<br>
防抖<br>
你是否在⽇常开发中遇到⼀个问题，在滚动事件中需要做个复杂计算或者实现⼀个按钮的防<br>
⼆次点击操作。<br>
这些需求都可以通过函数防抖动来实现。尤其是第⼀个需求，如果在频繁的事件回调中做复<br>
杂计算，很有可能导致⻚⾯卡顿，不如将多次计算合并为⼀次计算，只在⼀个精确点做操<br>
作。<br>
PS：防抖和节流的作⽤都是防⽌函数多次调⽤。区别在于，假设⼀个⽤户⼀直触发这个函<br>
数，且每次触发函数的间隔⼩于wait，防抖的情况下只会调⽤⼀次，⽽节流的 情况会每隔⼀<br>
定时间（参数wait）调⽤函数。<br>
我们先来看⼀个袖珍版的防抖理解⼀下防抖的实现：<br>
// AMD<br>
define(['./a', './b'], function(a, b) {<br>
a.do()<br>
b.do()<br>
})<br>
define(function(require, exports, module) {<br>
var a = require('./a')<br>
a.doSomething()<br>
var b = require('./b')<br>
b.doSomething()<br>
})<br>
// func是⽤户传⼊需要防抖的函数<br>
这是⼀个简单版的防抖，但是有缺陷，这个防抖只能在最后调⽤。⼀般的防抖会有immediate<br>
选项，表示是否⽴即调⽤。这两者的区别，举个栗⼦来说：<br>
例如在搜索引擎搜索问题的时候，我们当然是希望⽤户输⼊完最后⼀个字才调⽤查询接<br>
⼝，这个时候适⽤ 延迟执⾏ 的防抖函数，它总是在⼀连串（间隔⼩于wait的）函数触发之<br>
后调⽤。<br>
例如⽤户给interviewMap点star的时候，我们希望⽤户点第⼀下的时候就去调⽤接⼝，并<br>
且成功之后改变star按钮的样⼦，⽤户就可以⽴⻢得到反馈是否star成功了，这个情况适<br>
⽤ ⽴即执⾏ 的防抖函数，它总是在第⼀次调⽤，并且下⼀次调⽤必须与前⼀次调⽤的时<br>
间间隔⼤于wait才会触发。<br>
下⾯我们来实现⼀个带有⽴即执⾏选项的防抖函数<br>
// wait是等待时间<br>
const debounce = (func, wait = 50) =&gt; {<br>
// 缓存⼀个定时器id<br>
let timer = 0<br>
// 这⾥返回的函数是每次⽤户实际调⽤的防抖函数<br>
// 如果已经设定过定时器了就清空上⼀次的定时器<br>
// 开始⼀个新的定时器，延迟执⾏⽤户传⼊的⽅法<br>
return function(...args) {<br>
if (timer) clearTimeout(timer)<br>
timer = setTimeout(() =&gt; {<br>
func.apply(this, args)<br>
}, wait)<br>
}<br>
}<br>
// 不难看出如果⽤户调⽤该函数的间隔⼩于wait的情况下，上⼀次的时间还未到就被清除了，并<br>
不会执⾏函数<br>
// 这个是⽤来获取当前时间戳的<br>
function now() {<br>
return +new Date()<br>
}<br>
/**</p>
<ul>
<li>防抖函数，返回函数连续调⽤时，空闲时间必须⼤于或等于 wait，func 才会执⾏</li>
<li></li>
<li>@param {function} func 回调函数</li>
<li>@param {number} wait 表示时间窗⼝的间隔</li>
<li>@param {boolean} immediate 设置为ture时，是否⽴即调⽤函数</li>
<li>@return {function} 返回客户调⽤函数<br>
*/<br>
function debounce (func, wait = 50, immediate = true) {<br>
let timer, context, args</li>
</ul>
<p>// 延迟执⾏函数<br>
const later = () =&gt; setTimeout(() =&gt; {<br>
// 延迟函数执⾏完毕，清空缓存的定时器序号<br>
timer = null<br>
// 延迟执⾏的情况下，函数会在延迟函数中执⾏<br>
// 使⽤到之前缓存的参数和上下⽂<br>
if (!immediate) {<br>
func.apply(context, args)<br>
context = args = null<br>
}<br>
}, wait)<br>
// 这⾥返回的函数是每次实际调⽤的函数<br>
return function(...params) {<br>
// 如果没有创建延迟执⾏函数（later），就创建⼀个<br>
if (!timer) {<br>
timer = later()<br>
// 如果是⽴即执⾏，调⽤函数<br>
// 否则缓存参数和调⽤上下⽂<br>
if (immediate) {<br>
func.apply(this, params)<br>
} else {<br>
context = this<br>
args = params<br>
}<br>
// 如果已有延迟执⾏函数（later），调⽤的时候清除原来的并重新设定⼀个<br>
整体函数实现的不难，总结⼀下。<br>
对于按钮防点击来说的实现：如果函数是⽴即执⾏的，就⽴即调⽤，如果函数是延迟执⾏<br>
的，就缓存上下⽂和参数，放到延迟函数中去执⾏。⼀旦我开始⼀个定时器，只要我定时<br>
器还在，你每次点击我都重新计时。⼀旦你点累了，定时器时间到，定时器重置为<br>
null ，就可以再次点击了。<br>
对于延时执⾏函数来说的实现：清除定时器ID，如果是延迟调⽤就调⽤函数<br>
节流<br>
防抖动和节流本质是不⼀样的。防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏<br>
变成每隔⼀段时间执⾏。<br>
// 这样做延迟函数会重新计时<br>
} else {<br>
clearTimeout(timer)<br>
timer = later()<br>
}<br>
}<br>
}<br>
/**</p>
<ul>
<li>underscore 节流函数，返回函数连续调⽤时，func 执⾏频率限定为 次 / wait</li>
<li></li>
<li>@param {function} func 回调函数</li>
<li>@param {number} wait 表示时间窗⼝的间隔</li>
<li>@param {object} options 如果想忽略开始函数的的调⽤，传⼊{leading:<br>
false}。</li>
<li>如果想忽略结尾函数的调⽤，传⼊{trailing:<br>
false}</li>
<li>两者不能共存，否则函数不能执⾏</li>
<li>@return {function} 返回客户调⽤函数<br>
<em>/<br>
_.throttle = function(func, wait, options) {<br>
var context, args, result;<br>
var timeout = null;<br>
// 之前的时间戳<br>
var previous = 0;<br>
// 如果 options 没传则设为空对象<br>
if (!options) options = {};<br>
// 定时器回调函数<br>
var later = function() {<br>
// 如果设置了 leading，就将 previous 设为 0<br>
// ⽤于下⾯函数的第⼀个 if 判断<br>
previous = options.leading === false ? 0 : _.now();<br>
// 置空⼀是为了防⽌内存泄漏，⼆是为了下⾯的定时器判断<br>
timeout = null;<br>
result = func.apply(context, args);<br>
if (!timeout) context = args = null;<br>
};<br>
return function() {<br>
// 获得当前时间戳<br>
var now = <em>.now();<br>
// ⾸次进⼊前者肯定为 true<br>
// 如果需要第⼀次不执⾏函数<br>
// 就将上次时间戳设为当前的<br>
// 这样在接下来计算 remaining 的值时会⼤于0<br>
if (!previous &amp;&amp; options.leading === false) previous = now;<br>
// 计算剩余时间<br>
var remaining = wait - (now - previous);<br>
context = this;<br>
args = arguments;<br>
// 如果当前调⽤已经⼤于上次调⽤时间 + wait<br>
// 或者⽤户⼿动调了时间<br>
// 如果设置了 trailing，只会进⼊这个条件<br>
// 如果没有设置 leading，那么第⼀次会进⼊这个条件<br>
// 还有⼀点，你可能会觉得开启了定时器那么应该不会进⼊这个 if 条件了<br>
// 其实还是会进⼊的，因为定时器的延时<br>
// 并不是准确的时间，很可能你设置了2秒<br>
// 但是他需要2.2秒才触发，这时候就会进⼊这个条件<br>
if (remaining &lt;= 0 || remaining &gt; wait) {<br>
继承<br>
在 ES5 中，我们可以使⽤如下⽅式解决继承的问题<br>
// 如果存在定时器就清理掉否则会调⽤⼆次回调<br>
if (timeout) {<br>
clearTimeout(timeout);<br>
timeout = null;<br>
}<br>
previous = now;<br>
result = func.apply(context, args);<br>
if (!timeout) context = args = null;<br>
} else if (!timeout &amp;&amp; options.trailing !== false) {<br>
// 判断是否设置了定时器和 trailing<br>
// 没有的话就开启⼀个定时器<br>
// 并且不能不能同时设置 leading 和 trailing<br>
timeout = setTimeout(later, remaining);<br>
}<br>
return result;<br>
};<br>
};<br>
function Super() {}<br>
Super.prototype.getNumber = function() {<br>
return 1<br>
}<br>
function Sub() {}<br>
let s = new Sub()<br>
Sub.prototype = Object.create(Super.prototype, {<br>
constructor: {<br>
value: Sub,<br>
enumerable: false,<br>
writable: true,<br>
configurable: true<br>
以上继承实现思路就是将⼦类的原型设置为⽗类的原型<br>
在 ES6 中，我们可以通过 class 语法轻松解决这个问题<br>
但是 ES6 不是所有浏览器都兼容，所以我们需要使⽤ Babel 来编译这段代码。<br>
如果你使⽤编译过得代码调⽤ myDate.test() 你会惊奇地发现出现了报错<br>
因为在 JS 底层有限制，如果不是由 Date 构造出来的实例的话，是不能调⽤ Date ⾥的函<br>
数的。所以这也侧⾯的说明了：ES6 中的 class class 继承与 ES5 中的⼀般继承写法是不同的。<br>
既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承<br>
}<br>
})<br>
class MyDate extends Date {<br>
test() {<br>
return this.getTime()<br>
}<br>
}<br>
let myDate = new MyDate()<br>
myDate.test()<br>
以上继承实现思路：先创建⽗类实例 =&gt; 改变实例原先的 <em>proto</em></em> 转⽽连接到⼦类的<br>
prototype =&gt; ⼦类的 prototype 的 <strong>proto</strong> 改为⽗类的 prototype 。<br>
通过以上⽅法实现的继承就可以完美解决 JS 底层的这个限制。<br>
call, apply, bind 区别<br>
⾸先说下前两者的区别。<br>
call 和 apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不<br>
同。<br>
除了第⼀个参数外， call 可以接收⼀个参数列表， apply 只接受⼀个参数数组。<br>
function MyData() {<br>
}<br>
MyData.prototype.test = function () {<br>
return this.getTime()<br>
}<br>
let d = new Date()<br>
Object.setPrototypeOf(d, MyData.prototype)<br>
Object.setPrototypeOf(MyData.prototype, Date.prototype)<br>
let a = {<br>
value: 1<br>
}<br>
function getValue(name, age) {<br>
console.log(name)<br>
console.log(age)<br>
console.log(this.value)<br>
}<br>
getValue.call(a, 'yck', '24')<br>
getValue.apply(a, ['yck', '24'])<br>
模拟实现 call 和 apply<br>
可以从以下⼏点来考虑如何实现<br>
不传⼊第⼀个参数，那么默认为 window<br>
改变了 this 指向，让新的对象可以执⾏该函数。那么思路是否可以变成给新的对象添加<br>
⼀个函数，然后在执⾏完以后删除？<br>
以上就是 call 的思路， apply 的实现也类似<br>
Function.prototype.myCall = function (context) {<br>
var context = context || window<br>
// 给 context 添加⼀个属性<br>
// getValue.call(a, 'yck', '24') =&gt; a.fn = getValue<br>
context.fn = this<br>
// 将 context 后⾯的参数取出来<br>
var args = [...arguments].slice(1)<br>
// getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24')<br>
var result = context.fn(...args)<br>
// 删除 fn<br>
delete context.fn<br>
return result<br>
}<br>
Function.prototype.myApply = function (context) {<br>
var context = context || window<br>
context.fn = this<br>
var result<br>
// 需要判断是否存储第⼆个参数<br>
// 如果存在，就将第⼆个参数展开<br>
if (arguments[1]) {<br>
result = context.fn(...arguments[1])<br>
} else {<br>
result = context.fn()<br>
bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过<br>
bind 实现柯⾥化。<br>
同样的，也来模拟实现下 bind<br>
Promise 实现<br>
Promise 是 ES6 新增的语法，解决了回调地狱的问题。<br>
可以把 Promise 看成⼀个状态机。初始是 pending 状态，可以通过函数 resolve 和<br>
reject ，将状态转变为 resolved 或者 rejected 状态，状态⼀旦改变就不能再次变化。<br>
}<br>
delete context.fn<br>
return result<br>
}<br>
Function.prototype.myBind = function (context) {<br>
if (typeof this !== 'function') {<br>
throw new TypeError('Error')<br>
}<br>
var _this = this<br>
var args = [...arguments].slice(1)<br>
// 返回⼀个函数<br>
return function F() {<br>
// 因为返回了⼀个函数，我们可以 new F()，所以需要判断<br>
if (this instanceof F) {<br>
return new _this(...args, ...arguments)<br>
}<br>
return _this.apply(context, args.concat(...arguments))<br>
}<br>
}<br>
then 函数会返回⼀个 Promise 实例，并且该返回值是⼀个新的实例⽽不是之前的实例。因<br>
为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是⼀个相<br>
同实例的话，多个 then 调⽤就失去意义了。<br>
对于 then 来说，本质上可以把它看成是 flatMap<br>
// 三种状态<br>
const PENDING = &quot;pending&quot;;<br>
const RESOLVED = &quot;resolved&quot;;<br>
const REJECTED = &quot;rejected&quot;;<br>
// promise 接收⼀个函数参数，该函数会⽴即执⾏<br>
function MyPromise(fn) {<br>
let _this = this;<br>
_this.currentState = PENDING;<br>
_this.value = undefined;<br>
// ⽤于保存 then 中的回调，只有当 promise<br>
// 状态为 pending 时才会缓存，并且每个实例⾄多缓存⼀个<br>
_this.resolvedCallbacks = [];<br>
_this.rejectedCallbacks = [];<br>
_this.resolve = function (value) {<br>
if (value instanceof MyPromise) {<br>
// 如果 value 是个 Promise，递归执⾏<br>
return value.then(_this.resolve, _this.reject)<br>
}<br>
setTimeout(() =&gt; { // 异步执⾏，保证执⾏顺序<br>
if (_this.currentState === PENDING) {<br>
_this.currentState = RESOLVED;<br>
_this.value = value;<br>
_this.resolvedCallbacks.forEach(cb =&gt; cb());<br>
}<br>
})<br>
};<br>
_this.reject = function (reason) {<br>
setTimeout(() =&gt; { // 异步执⾏，保证执⾏顺序<br>
if (_this.currentState === PENDING) {<br>
_this.currentState = REJECTED;<br>
_this.value = reason;<br>
_this.rejectedCallbacks.forEach(cb =&gt; cb());<br>
}<br>
})<br>
}<br>
// ⽤于解决以下问题<br>
// new Promise(() =&gt; throw Error('error))<br>
try {<br>
fn(_this.resolve, _this.reject);<br>
} catch (e) {<br>
_this.reject(e);<br>
}<br>
}<br>
MyPromise.prototype.then = function (onResolved, onRejected) {<br>
var self = this;<br>
// 规范 2.2.7，then 必须返回⼀个新的 promise<br>
var promise2;<br>
// 规范 2.2.onResolved 和 onRejected 都为可选参数<br>
// 如果类型不是函数需要忽略，同时也实现了透传<br>
// Promise.resolve(4).then().then((value) =&gt; console.log(value))<br>
onResolved = typeof onResolved === 'function' ? onResolved : v =&gt; v;<br>
onRejected = typeof onRejected === 'function' ? onRejected : r =&gt;<br>
throw r;<br>
if (self.currentState === RESOLVED) {<br>
return (promise2 = new MyPromise(function (resolve, reject) {<br>
// 规范 2.2.4，保证 onFulfilled，onRjected 异步执⾏<br>
// 所以⽤了 setTimeout 包裹下<br>
setTimeout(function () {<br>
try {<br>
var x = onResolved(self.value);<br>
resolutionProcedure(promise2, x, resolve, reject);<br>
} catch (reason) {<br>
reject(reason);<br>
}<br>
});<br>
}));<br>
}<br>
if (self.currentState === REJECTED) {<br>
return (promise2 = new MyPromise(function (resolve, reject) {<br>
setTimeout(function () {<br>
// 异步执⾏onRejected<br>
try {<br>
var x = onRejected(self.value);<br>
resolutionProcedure(promise2, x, resolve, reject);<br>
} catch (reason) {<br>
reject(reason);<br>
}<br>
});<br>
}));<br>
}<br>
if (self.currentState === PENDING) {<br>
return (promise2 = new MyPromise(function (resolve, reject) {<br>
self.resolvedCallbacks.push(function () {<br>
// 考虑到可能会有报错，所以使⽤ try/catch 包裹<br>
try {<br>
var x = onResolved(self.value);<br>
resolutionProcedure(promise2, x, resolve, reject);<br>
} catch (r) {<br>
reject(r);<br>
}<br>
});<br>
self.rejectedCallbacks.push(function () {<br>
try {<br>
var x = onRejected(self.value);<br>
resolutionProcedure(promise2, x, resolve, reject);<br>
} catch (r) {<br>
reject(r);<br>
}<br>
});<br>
}));<br>
}<br>
};<br>
// 规范 2.3<br>
function resolutionProcedure(promise2, x, resolve, reject) {<br>
// 规范 2.3.1，x 不能和 promise2 相同，避免循环引⽤<br>
if (promise2 === x) {<br>
return reject(new TypeError(&quot;Error&quot;));<br>
}<br>
// 规范 2.3.2<br>
// 如果 x 为 Promise，状态为 pending 需要继续等待否则执⾏<br>
if (x instanceof MyPromise) {<br>
if (x.currentState === PENDING) {<br>
x.then(function (value) {<br>
// 再次调⽤该函数是为了确认 x resolve 的<br>
// 参数是什么类型，如果是基本类型就再次 resolve<br>
// 把值传给下个 then<br>
resolutionProcedure(promise2, value, resolve, reject);<br>
}, reject);<br>
} else {<br>
x.then(resolve, reject);<br>
}<br>
return;<br>
}<br>
// 规范 2.3.3.3.3<br>
// reject 或者 resolve 其中⼀个执⾏过得话，忽略其他的<br>
let called = false;<br>
// 规范 2.3.3，判断 x 是否为对象或者函数<br>
if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;))<br>
{<br>
// 规范 2.3.3.2，如果不能取出 then，就 reject<br>
try {<br>
// 规范 2.3.3.1<br>
let then = x.then;<br>
// 如果 then 是函数，调⽤ x.then<br>
if (typeof then === &quot;function&quot;) {<br>
// 规范 2.3.3.3<br>
then.call(<br>
x,<br>
y =&gt; {<br>
if (called) return;<br>
called = true;<br>
// 规范 2.3.3.3.1<br>
resolutionProcedure(promise2, y, resolve, reject);<br>
},<br>
e =&gt; {<br>
if (called) return;<br>
called = true;<br>
reject(e);<br>
}<br>
);<br>
} else {<br>
// 规范 2.3.3.4<br>
resolve(x);<br>
}<br>
} catch (e) {<br>
if (called) return;<br>
called = true;<br>
reject(e);<br>
}<br>
} else {<br>
// 规范 2.3.4，x 为基本类型<br>
resolve(x);<br>
}<br>
}<br>
以上就是根据 Promise / A+ 规范来实现的代码，可以通过 promises-aplus-tests 的完整<br>
测试<br>
Generator 实现<br>
Generator 是 ES6 中新增的语法，和 Promise ⼀样，都可以⽤来异步编程<br>
// 使⽤ * 表示这是⼀个 Generator 函数<br>
// 内部可以通过 yield 暂停代码<br>
// 通过调⽤ next 恢复执⾏<br>
function</em> test() {<br>
let a = 1 + 2;<br>
yield 2;<br>
yield 3;<br>
}<br>
let b = test();<br>
console.log(b.next()); // &gt; { value: 2, done: false }<br>
console.log(b.next()); // &gt; { value: 3, done: false }<br>
console.log(b.next()); // &gt; { value: undefined, done: true }<br>
从以上代码可以发现，加上 * 的函数执⾏后拥有了 next 函数，也就是说函数执⾏后返回<br>
了⼀个对象。每次调⽤ next 函数可以继续执⾏被暂停的代码。以下是 Generator 函数的简<br>
单实现<br>
// cb 也就是编译过的 test 函数<br>
function generator(cb) {<br>
return (function() {<br>
var object = {<br>
next: 0,<br>
stop: function() {}<br>
};<br>
return {<br>
next: function() {<br>
var ret = cb(object);<br>
if (ret === undefined) return { value: undefined, done: true };<br>
return {<br>
value: ret,<br>
done: false<br>
};<br>
}<br>
};<br>
})();<br>
}<br>
// 如果你使⽤ babel 编译后可以发现 test 函数变成了这样<br>
function test() {<br>
var a;<br>
return generator(function(_context) {<br>
while (1) {<br>
switch ((_context.prev = _context.next)) {<br>
// 可以发现通过 yield 将代码分割成⼏块<br>
// 每次执⾏ next 函数就执⾏⼀块代码<br>
// 并且表明下次需要执⾏哪块代码<br>
case 0:<br>
a = 1 + 2;<br>
Map、FlatMap 和 Reduce<br>
Map 作⽤是⽣成⼀个新数组，遍历原数组，将每个元素拿出来做⼀些变换然后 append 到新<br>
的数组中。<br>
Map 有三个参数，分别是当前索引元素，索引，原数组<br>
FlatMap 和 map 的作⽤⼏乎是相同的，但是对于多维数组来说，会将原数组降维。可以将<br>
FlatMap 看成是 map + flatten ，⽬前该函数在浏览器中还不⽀持。<br>
_context.next = 4;<br>
return 2;<br>
case 4:<br>
_context.next = 6;<br>
return 3;<br>
// 执⾏完毕<br>
case 6:<br>
case &quot;end&quot;:<br>
return _context.stop();<br>
}<br>
}<br>
});<br>
}<br>
[1, 2, 3].map((v) =&gt; v + 1)<br>
// -&gt; [2, 3, 4]<br>
['1','2','3'].map(parseInt)<br>
// parseInt('1', 0) -&gt; 1<br>
// parseInt('2', 1) -&gt; NaN<br>
// parseInt('3', 2) -&gt; NaN<br>
[1, [2], 3].flatMap((v) =&gt; v + 1)<br>
// -&gt; [2, 3, 4]<br>
如果想将⼀个多维数组彻底的降维，可以这样实现<br>
Reduce 作⽤是数组中的值组合起来，最终得到⼀个值<br>
async 和 await<br>
⼀个函数如果加上 async ，那么该函数就会返回⼀个 Promise<br>
可以把 async 看成将函数返回值使⽤ Promise.resolve() 包裹了下。<br>
await 只能在 async 函数中使⽤<br>
const flattenDeep = (arr) =&gt; Array.isArray(arr)<br>
? arr.reduce( (a, b) =&gt; [...a, ...flattenDeep(b)] , [])<br>
: [arr]<br>
flattenDeep([1, [[2], [3, [4]], 5]])<br>
function a() {<br>
console.log(1);<br>
}<br>
function b() {<br>
console.log(2);<br>
}<br>
[a, b].reduce((a, b) =&gt; a(b()))<br>
// -&gt; 2 1<br>
async function test() {<br>
return &quot;1&quot;;<br>
}<br>
console.log(test()); // -&gt; Promise {<resolved>: &quot;1&quot;}<br>
上⾯代码会先打印 finish 然后再打印 object 。因为 await 会等待 sleep 函数<br>
resolve ，所以即使后⾯是同步代码，也不会先去执⾏同步代码再来执⾏异步代码。<br>
async 和 await 相⽐直接使⽤ Promise 来说，优势在于处理 then 的调⽤链，能够更清<br>
晰准确的写出代码。缺点在于滥⽤ await 可能会导致性能问题，因为 await 会阻塞代码，<br>
也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。<br>
下⾯来看⼀个使⽤ await 的代码。<br>
对于以上代码你可能会有疑惑，这⾥说明下原理<br>
function sleep() {<br>
return new Promise(resolve =&gt; {<br>
setTimeout(() =&gt; {<br>
console.log('finish')<br>
resolve(&quot;sleep&quot;);<br>
}, 2000);<br>
});<br>
}<br>
async function test() {<br>
let value = await sleep();<br>
console.log(&quot;object&quot;);<br>
}<br>
test()<br>
var a = 0<br>
var b = async () =&gt; {<br>
a = a + await 10<br>
console.log('2', a) // -&gt; '2' 10<br>
a = (await 10) + a<br>
console.log('3', a) // -&gt; '3' 20<br>
}<br>
b()<br>
a++<br>
console.log('1', a) // -&gt; '1' 1<br>
⾸先函数 b 先执⾏，在执⾏到 await 10 之前变量 a 还是 0，因为在 await 内部实<br>
现了 generators ， generators 会保留堆栈中东⻄，所以这时候 a = 0 被保存了下<br>
来<br>
因为 await 是异步操作，遇到 await 就会⽴即返回⼀个 pending 状态的 Promise 对<br>
象，暂时返回执⾏代码的控制权，使得函数外的代码得以继续执⾏，所以会先执⾏<br>
console.log('1', a)<br>
这时候同步代码执⾏完毕，开始执⾏异步代码，将保存下来的值拿出来使⽤，这时候 a<br>
= 10<br>
然后后⾯就是常规执⾏代码了<br>
Proxy<br>
Proxy 是 ES6 中新增的功能，可以⽤来⾃定义对象中的操作<br>
可以很⽅便的使⽤ Proxy 来实现⼀个数据绑定和监听<br>
let p = new Proxy(target, handler);<br>
// <code>target</code> 代表需要添加代理的对象<br>
// <code>handler</code> ⽤来⾃定义对象中的操作<br>
let onWatch = (obj, setBind, getLogger) =&gt; {<br>
let handler = {<br>
get(target, property, receiver) {<br>
getLogger(target, property)<br>
return Reflect.get(target, property, receiver);<br>
},<br>
set(target, property, value, receiver) {<br>
setBind(value);<br>
return Reflect.set(target, property, value);<br>
}<br>
};<br>
return new Proxy(obj, handler);<br>
};<br>
let obj = { a: 1 }<br>
为什么 0.1 + 0.2 != 0.3<br>
因为 JS 采⽤ IEEE 754 双精度版本（64位），并且只要采⽤ IEEE 754 的语⾔都有该问题。<br>
我们都知道计算机表示⼗进制是采⽤⼆进制表示的，所以 0.1 在⼆进制表示为<br>
那么如何得到这个⼆进制的呢，我们可以来演算下<br>
let value<br>
let p = onWatch(obj, (v) =&gt; {<br>
value = v<br>
}, (target, property) =&gt; {<br>
console.log(<code>Get '${property}' = ${target[property]}</code>);<br>
})<br>
p.a = 2 // bind <code>value</code> to <code>2</code><br>
p.a // -&gt; Get 'a' = 2<br>
// (0011) 表示循环<br>
0.1 = 2^-4 * 1.10011(0011)<br>
⼩数算⼆进制和整数不同。乘法计算时，只计算⼩数位，整数位⽤作每⼀位的⼆进制，并且<br>
得到的第⼀位为最⾼位。所以我们得出 0.1 = 2^-4 * 1.10011(0011) ，那么 0.2 的演算<br>
也基本如上所示，只需要去掉第⼀步乘法，所以得出 0.2 = 2^-3 * 1.10011(0011) 。<br>
回来继续说 IEEE 754 双精度。六⼗四位中符号位占⼀位，整数位占⼗⼀位，其余五⼗⼆位都<br>
为⼩数位。因为 0.1 和 0.2 都是⽆限循环的⼆进制了，所以在⼩数位末尾处需要判断是否<br>
进位（就和⼗进制的四舍五⼊⼀样）。<br>
所以 2^-4 * 1.10011...001 进位后就变成了 2^-4 * 1.10011(0011 * 12次)010 。那么<br>
把这两个⼆进制加起来会得出 2^-2 * 1.0011(0011 * 11次)0100 , 这个值算成⼗进制就是<br>
0.30000000000000004<br>
元字<br>
符<br>
作⽤<br>
. 匹配任意字符除了换⾏符和回⻋符<br>
[] 匹配⽅括号内的任意字符。⽐如 [0-9] 就可以⽤来匹配任意数字<br>
^ ^9，这样使⽤代表匹配以 9 开头。[ ^ 9]，这样使⽤代表不匹配⽅括号内除了 9<br>
的字符<br>
{1, 2} 匹配 1 到 2 位字符<br>
(yck) 只匹配和 yck 相同字符串<br>
| 匹配 | 前后任意字符<br>
\ 转义</li>
<li>只匹配出现 0 次及以上 * 前的字符</li>
</ul>
<ul>
<li>只匹配出现 1 次及以上 + 前的字符<br>
? ? 之前字符可选<br>
修饰语 作⽤<br>
i 忽略⼤⼩写<br>
g 全局搜索<br>
m 多⾏<br>
下⾯说⼀下原⽣解决办法，如下代码所示<br>
正则表达式<br>
元字符<br>
修饰语<br>
parseFloat((0.1 + 0.2).toFixed(10))<br>
简写 作⽤<br>
\w 匹配字⺟数字或下划线<br>
\W 和上⾯相反<br>
\s 匹配任意的空⽩符<br>
\S 和上⾯相反<br>
\d 匹配数字<br>
\D 和上⾯相反<br>
\b 匹配单词的开始或结束<br>
\B 和上⾯相反<br>
字符简写<br>
V8 下的垃圾回收机制<br>
V8 实现了准确式 GC，GC 算法采⽤了分代式垃圾回收机制。因此，V8 将内存（堆）分为新<br>
⽣代和⽼⽣代两部分。<br>
新⽣代算法<br>
新⽣代中的对象⼀般存活时间较短，使⽤ Scavenge GC 算法。<br>
在新⽣代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必<br>
定有⼀个空间是使⽤的，另⼀个空间是空闲的。新分配的对象会被放⼊ From 空间中，当<br>
From 空间被占满时，新⽣代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到<br>
To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样<br>
GC 就结束了。<br>
⽼⽣代算法<br>
⽼⽣代中的对象⼀般存活时间较⻓且数量也多，使⽤了两个算法，分别是标记清除算法和标<br>
记压缩算法。<br>
在讲算法前，先来说下什么情况下对象会出现在⽼⽣代空间中：<br>
新⽣代中的对象是否已经经历过⼀次 Scavenge 算法，如果经历过的话，会将对象从新⽣<br>
代空间移到⽼⽣代空间中。<br>
To 空间的对象占⽐⼤⼩超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从<br>
新⽣代空间移到⽼⽣代空间中。<br>
⽼⽣代中的空间很复杂，有如下⼏个空间<br>
在⽼⽣代中，以下情况会先启动标记清除算法：<br>
某⼀个空间没有分块的时候<br>
空间中被对象超过⼀定限制<br>
空间不能保证新⽣代中的对象移动到⽼⽣代中<br>
在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有<br>
被标记的对象。在标记⼤型对内存时，可能需要⼏百毫秒才能完成⼀次标记。这就会导致⼀<br>
些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标<br>
志。在增量标记期间，GC 将标记⼯作分解为更⼩的模块，可以让 JS 应⽤逻辑在模块间隙执<br>
⾏⼀会，从⽽不⾄于让应⽤出现停顿情况。但在 2018 年，GC 技术⼜有了⼀个重⼤突破，这<br>
项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运⾏，你可以点击<br>
enum AllocationSpace {<br>
// TODO(v8:7464): Actually map this space's memory as read-only.<br>
RO_SPACE, // 不变的对象空间<br>
NEW_SPACE, // 新⽣代⽤于 GC 复制算法的空间<br>
OLD_SPACE, // ⽼⽣代常驻对象空间<br>
CODE_SPACE, // ⽼⽣代代码对象空间<br>
MAP_SPACE, // ⽼⽣代 map 对象<br>
LO_SPACE, // ⽼⽣代⼤空间对象<br>
NEW_LO_SPACE, // 新⽣代⼤空间对象<br>
FIRST_SPACE = RO_SPACE,<br>
LAST_SPACE = NEW_LO_SPACE,<br>
FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,<br>
LAST_GROWABLE_PAGED_SPACE = MAP_SPACE<br>
};<br>
该博客 详细阅读。<br>
清除对象后会造成堆内存出现碎⽚的情况，当碎⽚超过⼀定限制后会启动压缩算法。在压缩<br>
过程中，将活的对象像⼀端移动，直到所有对象都移动完成然后清理掉不需要的内存。<br>
⽹络章节<br>
事件机制<br>
事件触发三阶段<br>
事件触发有三个阶段<br>
window 往事件触发处传播，遇到注册的捕获事件会触发<br>
传播到事件触发处时触发注册的事件<br>
从事件触发处往 window 传播，遇到注册的冒泡事件会触发<br>
事件触发⼀般来说会按照上⾯的顺序进⾏，但是也有特例，如果给⼀个⽬标节点同时注册冒<br>
泡和捕获事件，事件触发会按照注册的顺序执⾏。<br>
注册事件<br>
通常我们使⽤ addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是<br>
对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。 useCapture 决定了<br>
注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使⽤以下⼏个属性<br>
// 以下会先打印冒泡然后是捕获<br>
node.addEventListener('click',(event) =&gt;{<br>
console.log('冒泡')<br>
},false);<br>
node.addEventListener('click',(event) =&gt;{<br>
console.log('捕获 ')<br>
},true)<br>
capture ，布尔值，和 useCapture 作⽤⼀样<br>
once ，布尔值，值为 true 表示该回调只会调⽤⼀次，调⽤后会移除监听<br>
passive ，布尔值，表示永远不会调⽤ preventDefault<br>
⼀般来说，我们只希望事件只触发在⽬标上，这时候可以使⽤ stopPropagation 来阻⽌事<br>
件的进⼀步传播。通常我们认为 stopPropagation 是⽤来阻⽌事件冒泡的，其实该函数也<br>
可以阻⽌捕获事件。 stopImmediatePropagation 同样也能实现阻⽌事件，但是还能阻⽌该<br>
事件⽬标执⾏别的注册事件。<br>
事件代理<br>
如果⼀个节点中的⼦节点是动态⽣成的，那么⼦节点需要注册事件的话应该注册在⽗节点上<br>
node.addEventListener('click',(event) =&gt;{<br>
event.stopImmediatePropagation()<br>
console.log('冒泡')<br>
},false);<br>
// 点击 node 只会执⾏上⾯的函数，该函数不会执⾏<br>
node.addEventListener('click',(event) =&gt; {<br>
console.log('捕获 ')<br>
},true)<br>
事件代理的⽅式相对于直接给⽬标注册事件来说，有以下优点<br>
节省内存<br>
不需要给⼦节点注销事件<br>
跨域<br>
因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端⼝有⼀个不同就<br>
是跨域，Ajax 请求会失败。<br>
我们可以通过以下⼏种常⽤⽅法解决跨域的问题<br>
JSONP<br>
JSONP 的原理很简单，就是利⽤ <script> 标签没有跨域限制的漏洞。通过 <script> 标<br>
签指向⼀个需要访问的地址并提供⼀个回调函数来接收数据当需要通讯时。</li>
</ul>
<ul id="ul">
 <li>1</li>
 <li>2</li>
 <li>3</li>
 <li>4</li>
 <li>5</li>
</ul>
<script>
 let ul = document.querySelector('#ul')
 ul.addEventListener('click', (event) => {
 console.log(event.target);
 })
</script>
JSONP 使⽤简单且兼容性不错，但是只限于 get 请求。
在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要⾃⼰封装⼀个
JSONP，以下是简单实现
<script src="http://domain/api?param1=a&param2=b&callback=jsonp">
</script>
<script>
 function jsonp(data) {
 console.log(data)
 }
</script>
function jsonp(url, jsonpCallback, success) {
 let script = document.createElement("script");
 script.src = url;
 script.async = true;
 script.type = "text/javascript";
 window[jsonpCallback] = function(data) {
 success && success(data);
 };
 document.body.appendChild(script);
}
jsonp(
 "http://xxx",
 "callback",
 function(value) {
 console.log(value);
 }
);
CORS
CORS需要浏览器和后端同时⽀持。IE 8 和 9 需要通过 XDomainRequest 来实现。
浏览器会⾃动进⾏ CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就
实现了跨域。
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以
访问资源，如果设置通配符则表示所有⽹站都可以访问资源。
document.domain
该⽅式只能⽤于⼆级域名相同的情况下，⽐如 a.test.com 和 b.test.com 适⽤于该⽅式。
只需要给⻚⾯添加 document.domain = 'test.com' 表示⼆级域名都相同就可以实现跨域
postMessage
这种⽅式通常⽤于获取嵌⼊⻚⾯中的第三⽅⻚⾯数据。⼀个⻚⾯发送消息，另⼀个⻚⾯判断
来源并接收消息
// 发送消息端
window.parent.postMessage('message', 'http://test.com');
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener('message', (event) => {
 var origin = event.origin || event.originalEvent.origin;
 if (origin === 'http://test.com') {
 console.log('验证通过')
 }
});
Event loop
众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的。如果
JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加
节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题。
JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异
步的代码，会被挂起并加⼊到 Task（有多种 task） 队列中。⼀旦执⾏栈为空，Event Loop
就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说 JS 中的异步
还是同步⾏为。
以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数
第⼆个参数不得⼩于 4 毫秒，不⾜会⾃动增加。所以 setTimeout 还是会在 script end
之后打印。
不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任
务（macrotask）。在 ES6 规范中，microtask 称为 jobs ，macrotask 称为 task 。
console.log('script start');
setTimeout(function() {
 console.log('setTimeout');
}, 0);
console.log('script end');
console.log('script start');
setTimeout(function() {
 console.log('setTimeout');
}, 0);
new Promise((resolve) => {
 console.log('Promise')
 resolve()
以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务⽽
setTimeout 属于宏任务，所以会有以上的打印。
微任务包括 process.nextTick ， promise ， Object.observe ， MutationObserver
宏任务包括 script ， setTimeout ， setInterval ， setImmediate ， I/O ， UI
rendering
很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，
浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务。
所以正确的⼀次 Event loop 顺序是这样的
1. 执⾏同步代码，这属于宏任务
2. 执⾏栈为空，查询是否有微任务需要执⾏
3. 执⾏所有微任务
4. 必要的话渲染 UI
5. 然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码
通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有⼤量的计算并且需要操作
DOM 的话，为了更快的 界⾯响应，我们可以把操作 DOM 放⼊微任务中。
}).then(function() {
 console.log('promise1');
}).then(function() {
 console.log('promise2');
});
console.log('script end');
// script start => Promise => script end => promise1 => promise2 =>
setTimeout
Node 中的 Event loop
Node 中的 Event loop 和浏览器中的不相同。
Node 的 Event loop 分为6个阶段，它们会按照顺序反复运⾏
timer
timers 阶段会执⾏ setTimeout 和 setInterval
⼀个 timer 指定的时间并不是准确时间，⽽是在达到这个时间后尽快执⾏回调，可能会因为
系统正在执⾏别的事务⽽延迟。
下限的时间有⼀个范围： [1, 2147483647] ，如果设定的时间不在这个范围，将被设置为
1。
!"""""""""""""""""""""""#
!">$ timers $
$ %""""""""""&""""""""""""'
$ !""""""""""(""""""""""""#
$ $ I/O callbacks $
$ %""""""""""&""""""""""""'
$ !""""""""""(""""""""""""#
$ $ idle, prepare $
$ %""""""""""&""""""""""""' !"""""""""""""""#
$ !""""""""""(""""""""""""# $ incoming: $
$ $ poll $<""connections""" $
$ %""""""""""&""""""""""""' $ data, etc. $
$ !""""""""""(""""""""""""# %"""""""""""""""'
$ $ check $
$ %""""""""""&""""""""""""'
$ !""""""""""(""""""""""""#
%"") close callbacks $
 %"""""""""""""""""""""""'
I/O
I/O 阶段会执⾏除了 close 事件，定时器和 setImmediate 的回调
idle, prepare
idle, prepare 阶段内部实现
poll
poll 阶段很重要，这⼀阶段中，系统会做两件事情
1. 执⾏到点的定时器
2. 执⾏ poll 队列中的事件
并且当 poll 中没有定时器的情况下，会发现以下两件事情
如果 poll 队列不为空，会遍历回调队列并同步执⾏，直到队列为空或者系统限制
如果 poll 队列为空，会有两件事发⽣
如果有 setImmediate 需要执⾏，poll 阶段会停⽌并且进⼊到 check 阶段执⾏
setImmediate
如果没有 setImmediate 需要执⾏，会等待回调被加⼊到队列中并⽴即执⾏回调
如果有别的定时器需要被执⾏，会回到 timer 阶段执⾏回调。
check
check 阶段执⾏ setImmediate
close callbacks
close callbacks 阶段执⾏ close 事件
并且在 Node 中，有些情况下的定时器执⾏顺序是随机的
当然在这种情况下，执⾏顺序是相同的
上⾯介绍的都是 macrotask 的执⾏情况，microtask 会在以上每个阶段完成后⽴即执⾏。
setTimeout(() => {
 console.log('setTimeout');
}, 0);
setImmediate(() => {
 console.log('setImmediate');
})
// 这⾥可能会输出 setTimeout，setImmediate
// 可能也会相反的输出，这取决于性能
// 因为可能进⼊ event loop ⽤了不到 1 毫秒，这时候会执⾏ setImmediate
// 否则会执⾏ setTimeout
var fs = require('fs')
fs.readFile(__filename, () => {
 setTimeout(() => {
 console.log('timeout');
 }, 0);
 setImmediate(() => {
 console.log('immediate');
 });
});
// 因为 readFile 的回调在 poll 中执⾏
// 发现有 setImmediate ，所以会⽴即跳到 check 阶段执⾏回调
// 再去 timer 阶段执⾏ setTimeout
// 所以以上输出⼀定是 setImmediate，setTimeout
setTimeout(()=>{
 console.log('timer1')
 Promise.resolve().then(function() {
Node 中的 process.nextTick 会先于其他 microtask 执⾏。
 console.log('promise1')
 })
}, 0)
setTimeout(()=>{
 console.log('timer2')
 Promise.resolve().then(function() {
 console.log('promise2')
 })
}, 0)
// 以上代码在浏览器和 node 中打印情况是不同的
// 浏览器中⼀定打印 timer1, promise1, timer2, promise2
// node 中可能打印 timer1, timer2, promise1, promise2
// 也可能打印 timer1, promise1, timer2, promise2
setTimeout(() => {
 console.log("timer1");
 Promise.resolve().then(function() {
 console.log("promise1");
 });
}, 0);
process.nextTick(() => {
 console.log("nextTick");
});
// nextTick, timer1, promise1
特性 cookie localStorage sessionStorage indexDB
数据⽣
命周期
⼀般由服务器⽣成，可以设
置过期时间
除⾮被清理，否
则⼀直存在
⻚⾯关闭就清理 除⾮被清
理，否则
⼀直存在
数据存
储⼤⼩
4K 5M 5M ⽆限
与服务
端通信
每次都会携带在 header
中，对于请求性能影响
不参与 不参与 不参与
属性 作⽤
value 如果⽤于保存⽤户登录态，应该将该值加密，不能使⽤明⽂的⽤户标识
http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击
secure 只能在协议为 HTTPS 的请求中携带
same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击
存储
cookie，localStorage，sessionStorage，indexDB
从上表可以看到， cookie 已经不建议⽤于存储。如果没有⼤量数据存储需求的话，可以使
⽤ localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使⽤ localStorage
存储，否则可以⽤ sessionStorage 存储。
对于 cookie ，我们还需要注意安全性。
Service Worker
Service workers 本质上充当Web应⽤程序与浏览器之间的代理服务器，也可以在⽹
络可⽤时作为浏览器和⽹络间的代理。它们旨在（除其他之外）使得能够创建有效的
离线体验，拦截⽹络请求并基于⽹络是否可⽤以及更新的资源是否驻留在服务器上来
采取适当的动作。他们还允许访问推送通知和后台同步API。
⽬前该技术通常⽤来做缓存⽂件，提⾼⾸屏速度，可以试着来实现这个功能。
// index.js
if (navigator.serviceWorker) {
 navigator.serviceWorker
 .register("sw.js")
 .then(function(registration) {
 console.log("service worker 注册成功");
 })
 .catch(function(err) {
 console.log("servcie worker 注册失败");
 });
}
// sw.js
// 监听 `install` 事件，回调中缓存所需⽂件
self.addEventListener("install", e => {
 e.waitUntil(
 caches.open("my-cache").then(function(cache) {
 return cache.addAll(["./index.html", "./index.js"]);
 })
 );
});
// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接⽤缓存，否则去请求数据
self.addEventListener("fetch", e => {
 e.respondWith(
 caches.match(e.request).then(function(response) {
 if (response) {
 return response;
 }
 console.log("fetch source");
 })
 );
});
打开⻚⾯，可以在开发者⼯具中的 Application 看到 Service Worker 已经启动了
在 Cache 中也可以发现我们所需的⽂件已被缓存
当我们重新刷新⻚⾯可以发现我们缓存的数据是从 Service Worker 中读取的
渲染机制
浏览器的渲染机制⼀般分为以下⼏个步骤
1. 处理 HTML 并构建 DOM 树。
2. 处理 CSS 构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成⼀个渲染树。
4. 根据渲染树来布局，计算每个节点的位置。
5. 调⽤ GPU 绘制，合成图层，显示在屏幕上。
在构建 CSSOM 树时，会阻塞渲染，直⾄ CSSOM 树构建完成。并且构建 CSSOM 树是⼀个
⼗分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择
器，执⾏速度越慢。
当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地⽅重新开始。也
就是说，如果你想⾸屏渲染的越快，就越不应该在⾸屏就加载 JS ⽂件。并且 CSS 也会影响
JS 的执⾏，只有当解析完样式表才会执⾏ JS，所以也可以认为这种情况下，CSS 也会暂停
构建 DOM。
Load 和 DOMContentLoaded 区别
Load 事件触发代表⻚⾯中的 DOM，CSS，JS，图⽚已经全部加载完毕。
DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，
JS，图⽚加载。
图层
⼀般来说，可以把普通⽂档流看成⼀个图层。特定的属性可以⽣成⼀个新的图层。不同的图
层渲染互不影响，所以对于某些频繁需要渲染的建议单独⽣成⼀个新图层，提⾼性能。但也
不能⽣成过多的图层，会引起反作⽤。
通过以下⼏个常⽤属性可以⽣成新图层
3D 变换： translate3d 、 translateZ
will-change
video 、 iframe 标签
通过动画实现的 opacity 动画转换
position: fixed
重绘（Repaint）和回流（Reflow）
重绘和回流是渲染步骤中的⼀⼩节，但是这两个步骤对于性能影响很⼤。
重绘是当节点需要更改外观⽽不会影响布局的，⽐如改变 color 就叫称为重绘
回流是布局或者⼏何属性需要改变就称为回流。
回流必定会发⽣重绘，重绘不⼀定会引发回流。回流所需的成本⽐重绘⾼的多，改变深层次
的节点很可能导致⽗节点的⼀系列回流。
所以以下⼏个动作可能会导致性能问题：
改变 window ⼤⼩
改变字体
添加或删除样式
⽂字改变
定位或者浮动
盒模型
很多⼈不知道的是，重绘和回流其实和 Event loop 有关。
1. 当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是
60Hz 的刷新率，每 16ms 才会更新⼀次。
2. 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和
scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执⾏ requestAnimationFrame 回调
7. 执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载
上，但是兼容性不好
8. 更新界⾯
9. 以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏
requestIdleCallback 回调。
以上内容来⾃于 HTML ⽂档
减少重绘和回流
使⽤ translate 替代 top
<div class="test"></div>
<style>
 .test {
 position: absolute;
 top: 10px;
 width: 100px;
 height: 100px;
 background: red;
 }
</style>
<script>
 setTimeout(() => {
 // 引起回流
 document.querySelector('.test').style.top = '100px'
 }, 1000)
</script>
使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流
（改变了布局）
把 DOM 离线后修改，⽐如：先把 DOM 给 display:none (有⼀次 Reflow)，然后你修
改100次，然后再把它显示出来
不要把 DOM 结点的属性值放在⼀个循环⾥当成循环⾥的变量
不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局
动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤
requestAnimationFrame
CSS 选择符从右往左匹配查找，避免 DOM 深度过深
将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。⽐如对于 video
标签，浏览器会⾃动将该节点变为图层。
for(let i = 0; i < 1000; i++) {
 // 获取 offsetTop 会导致回流，因为需要去获取正确的值
 console.log(document.querySelector('.test').style.offsetTop)
}
性能章节
DNS 预解析
DNS 解析也是需要时间的，可以通过预解析的⽅式来预先获得域名所对应的 IP。
缓存
缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提⾼
⽹⻚的整体加载速度。
通常浏览器缓存策略分为两种：强缓存和协商缓存。
强缓存
实现强缓存可以通过两种响应头实现： Expires 和 Cache-Control 。强缓存表示在缓存期
间不需要请求， state code 为 200
Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过
期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存
失效。
Cache-Control 出现于 HTTP / 1.1，优先级⾼于 Expires 。该属性表示资源会在 30 秒后
过期，需要再次请求。
<link rel="dns-prefetch" href="//yuchengkai.cn">
Expires: Wed, 22 Oct 2018 08:41:00 GMT
Cache-control: max-age=30
协商缓存
如果缓存过期了，我们就可以使⽤协商缓存来解决问题。协商缓存需要请求，如果缓存有效
会返回 304。
协商缓存需要客户端和服务端共同实现，和强缓存⼀样，也有两种实现⽅式。
Last-Modified 和 If-Modified-Since
Last-Modified 表示本地⽂件最后修改⽇期， If-Modified-Since 会将 Last-Modified
的值发送给服务器，询问服务器在该⽇期后资源是否有更新，有更新的话就会将新的资源发
送回来。
但是如果在本地打开缓存⽂件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现
了 ETag 。
ETag 和 If-None-Match
ETag 类似于⽂件指纹， If-None-Match 会将当前 ETag 发送给服务器，询问该资源
ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级⽐ LastModified ⾼。
选择合适的缓存策略
对于⼤部分的场景都可以使⽤强缓存配合协商缓存解决，但是在⼀些特殊的地⽅可能需要选
择特殊的缓存策略
对于某些不需要缓存的资源，可以使⽤ Cache-control: no-store ，表示该资源不需
要缓存
对于频繁变动的资源，可以使⽤ Cache-Control: no-cache 并配合 ETag 使⽤，表示
该资源已被缓存，但是每次都会发送请求询问资源是否更新。
对于代码⽂件来说，通常使⽤ Cache-Control: max-age=31536000 并配合策略缓存使
⽤，然后对⽂件进⾏指纹处理，⼀旦⽂件名变动就会⽴刻下载新的⽂件。
使⽤ HTTP / 2.0
因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建⽴和断开，消耗了好
⼏个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积⼤的⽂件会需要更多的时间。
在 HTTP / 2.0 中引⼊了多路复⽤，能够让多个请求使⽤同⼀个 TCP 链接，极⼤的加快了⽹
⻚的加载速度。并且还⽀持 Header 压缩，进⼀步的减少了请求的数据⼤⼩。
更详细的内容你可以查看 该⼩节
预加载
在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候
就可以使⽤预加载。
预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以
使⽤以下代码开启预加载
预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后
加载，唯⼀缺点就是兼容性不好。
预渲染
可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染
预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则
就⽩⽩浪费资源去渲染
<link rel="preload" href="http://example.com">
<link rel="prerender" href="http://example.com">
优化渲染过程
对于代码层⾯的优化，你可以查阅浏览器系列中的 相关内容。
懒执⾏
懒执⾏就是将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于某些耗时逻辑
并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。懒执⾏需要唤醒，⼀般可以通过定时器或者
事件的调⽤来唤醒。
懒加载
懒加载就是将不关键的资源延后加载。
懒加载的原理就是只加载⾃定义区域（通常是可视区域，但也可以是即将进⼊可视区域）内
需要加载的东⻄。对于图⽚来说，先设置图⽚标签的 src 属性为⼀张占位图，将真实的图⽚
资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域时，就将⾃定义属性替换为 src 属性，这样
图⽚就会去下载资源，实现了图⽚懒加载。
懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频等
等。
⽂件优化
图⽚优化
计算图⽚⼤⼩
对于⼀张 100 * 100 像素的图⽚来说，图像上有 10000 个像素点，如果每个像素的值是
RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字
节），所以该图⽚⼤⼩⼤概为 39KB（10000 * 1 * 4 / 1024）。
但是在实际项⽬中，⼀张图⽚可能并不需要使⽤那么多颜⾊去显示，我们可以通过减少每个
像素的调⾊板来相应缩⼩图⽚的⼤⼩。
了解了如何计算图⽚⼤⼩的知识，那么对于如何优化图⽚，想必⼤家已经有 2 个思路了：
减少像素点
减少每个像素点能够显示的颜⾊
图⽚加载优化
1. 不⽤图⽚。很多时候会使⽤到很多修饰类图⽚，其实这类修饰图⽚完全可以⽤ CSS 去代
替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。⼀般图⽚都⽤
CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图⽚。
3. ⼩图使⽤ base64 格式
4. 将多个图标⽂件整合到⼀张图⽚中（雪碧图）
5. 选择正确的图⽚格式：
对于能够显示 WebP 格式的浏览器尽量使⽤ WebP 格式。因为 WebP 格式具有更好
的图像数据压缩算法，能带来更⼩的图⽚体积，⽽且拥有⾁眼识别⽆差异的图像质
量，缺点就是兼容性并不好
⼩图使⽤ PNG，其实对于⼤部分图标这类图⽚，完全可以使⽤ SVG 代替
照⽚使⽤ JPEG
其他⽂件优化
CSS ⽂件放在 head 中
服务端开启⽂件压缩功能
将 script 标签放在 body 底部，因为 JS ⽂件执⾏会阻塞渲染。当然也可以把
script 标签放在任意位置然后加上 defer ，表示该⽂件会并⾏下载，但是会放到
HTML 解析完成后顺序执⾏。对于没有任何依赖的 JS ⽂件可以加上 async ，表示加载
和渲染后续⽂档元素的过程将和 JS ⽂件的加载与执⾏并⾏⽆序进⾏。
执⾏ JS 代码过⻓会卡住渲染，对于需要很多时间计算的代码可以考虑使⽤
Webworker 。 Webworker 可以让我们另开⼀个线程执⾏脚本⽽不影响渲染。
CDN
静态资源尽量使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个
CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带
上主站的 Cookie。
其他
使⽤ Webpack 优化项⽬
对于 Webpack4，打包项⽬使⽤ production 模式，这样会⾃动开启代码压缩
使⽤ ES6 模块来开启 tree shaking，这个技术可以移除没有使⽤的代码
优化图⽚，对于⼩图可以使⽤ base64 的⽅式写⼊⽂件中
按照路由拆分代码，实现按需加载
给打包出来的⽂件名添加哈希，实现浏览器缓存⽂件
监控
对于代码运⾏错误，通常的办法是使⽤ window.onerror 拦截报错。该⽅法能拦截到⼤部分
的详细报错信息，但是也有例外
对于跨域的代码运⾏错误会显示 Script error. 对于这种情况我们需要给 script 标
签添加 crossorigin 属性
对于某些浏览器可能不会显示调⽤栈信息，这种情况可以通过
arguments.callee.caller 来做栈递归
对于异步代码来说，可以使⽤ catch 的⽅式捕获错误。⽐如 Promise 可以直接使⽤
catch 函数， async await 可以使⽤ try catch
但是要注意线上运⾏的代码都是压缩过的，需要在打包时⽣成 sourceMap ⽂件便于 debug。
对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起⼀个请求。
⾯试题
如何渲染⼏万条数据并不卡住界⾯
这道题考察了如何在不卡住⻚⾯的情况下渲染数据，也就是说不能⼀次性将⼏万条都渲染出
来，⽽应该⼀次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷
新⼀次。
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <meta http-equiv="X-UA-Compatible" content="ie=edge">
 <title>Document</title>
</head>
<body>
 <ul>控件</ul>
 <script>
 setTimeout(() => {
 // 插⼊⼗万条数据
 const total = 100000
 // ⼀次插⼊ 20 条，如果觉得性能不好就减少
 const once = 20
 // 渲染数据总共需要⼏次
 const loopCount = total / once
 let countOfRender = 0
 let ul = document.querySelector("ul");
 function add() {
 // 优化性能，插⼊不会造成回流
 const fragment = document.createDocumentFragment();
 for (let i = 0; i < once; i++) {
 const li = document.createElement("li");
 li.innerText = Math.floor(Math.random() * total);
 fragment.appendChild(li);
 }
 ul.appendChild(fragment);
 countOfRender += 1;
 loop();
 }
 function loop() {
 if (countOfRender < loopCount) {
 window.requestAnimationFrame(add);
 }
框架基本原理篇
MVVM
MVVM 由以下三个内容组成
View：界⾯
Model：数据模型
ViewModel：作为桥梁负责沟通 View 和 Model
在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务
的逻辑就和⻚⾯有强耦合。
在 MVVM 中，UI 是通过数据驱动的，数据⼀旦改变就会相应的刷新对应的 UI，UI 如果改
变，也会改变对应的数据。这种⽅式就可以在业务处理中只关⼼数据的流转，⽽⽆需直接和
⻚⾯打交道。ViewModel 只关⼼数据和业务的处理，不关⼼ View 如何处理数据，在这种情况
下，View 和 Model 都可以独⽴出来，任何⼀⽅改变了也不⼀定需要改变另⼀⽅，并且可以将
⼀些可复⽤的逻辑放在⼀个 ViewModel 中，让多个 View 复⽤这个 ViewModel。
在 MVVM 中，最核⼼的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫
持。
 }
 loop();
 }, 0);
 </script>
</body>
</html>
脏数据检测
当触发了指定事件后会进⼊脏数据检测，这时会调⽤ $digest 循环遍历所有的数据观察者，
判断当前值是否和先前的值有区别，如果检测到变化的话，会调⽤ $watch 函数，然后再次
调⽤ $digest 循环直到发现没有变化。循环⾄少为⼆次 ，⾄多为⼗次。
脏数据检测虽然存在低效的问题，但是不关⼼数据是通过什么⽅式改变的，都可以完成任
务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的
值，再去统⼀更新 UI，⼤⼤减少了操作 DOM 的次数。所以低效也是相对的，这就仁者⻅仁
智者⻅智了。
数据劫持
Vue 内部使⽤了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到
set 和 get 的事件。
var data = { name: 'yck' }
observe(data)
let name = data.name // -> get value
data.name = 'yyy' // -> change value
function observe(obj) {
 // 判断类型
 if (!obj || typeof obj !== 'object') {
 return
 }
 Object.keys(obj).forEach(key => {
 defineReactive(obj, key, obj[key])
 })
}
function defineReactive(obj, key, val) {
 // 递归⼦属性
 observe(val)
 Object.defineProperty(obj, key, {
 enumerable: true,
以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需
要在适当的时候给属性添加发布订阅
::: v-pre
在解析如上模板代码时，遇到 {{name}} 就会给属性 name 添加发布订阅。
:::
 configurable: true,
 get: function reactiveGetter() {
 console.log('get value')
 return val
 },
 set: function reactiveSetter(newVal) {
 console.log('change value')
 val = newVal
 }
 })
}
<div>
 {{name}}
</div>
// 通过 Dep 解耦
class Dep {
 constructor() {
 this.subs = []
 }
 addSub(sub) {
 // sub 是 Watcher 实例
 this.subs.push(sub)
 }
 notify() {
 this.subs.forEach(sub => {
 sub.update()
 })
 }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null
function update(value) {
 document.querySelector('div').innerText = value
}
class Watcher {
 constructor(obj, key, cb) {
 // 将 Dep.target 指向⾃⼰
 // 然后触发属性的 getter 添加监听
 // 最后将 Dep.target 置空
 Dep.target = this
 this.cb = cb
 this.obj = obj
 this.key = key
 this.value = obj[key]
 Dep.target = null
 }
 update() {
 // 获得新值
 this.value = this.obj[this.key]
 // 调⽤ update ⽅法更新 Dom
 this.cb(this.value)
 }
}
var data = { name: 'yck' }
observe(data)
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update)
// update Dom innerText
data.name = 'yyy'
接下来,对 defineReactive 函数进⾏改造
以上实现了⼀个简易的双向绑定，核⼼思路就是⼿动触发⼀次属性的 getter 来实现发布订阅
的添加。
Proxy 与 Object.defineProperty 对⽐
Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。
1. 只能对属性进⾏数据劫持，所以需要深度遍历整个对象
2. 对于数组不能监听到数据的变化
function defineReactive(obj, key, val) {
 // 递归⼦属性
 observe(val)
 let dp = new Dep()
 Object.defineProperty(obj, key, {
 enumerable: true,
 configurable: true,
 get: function reactiveGetter() {
 console.log('get value')
 // 将 Watcher 添加到订阅
 if (Dep.target) {
 dp.addSub(Dep.target)
 }
 return val
 },
 set: function reactiveSetter(newVal) {
 console.log('change value')
 val = newVal
 // 执⾏ watcher 的 update ⽅法
 dp.notify()
 }
 })
}
虽然 Vue 中确实能检测到数组数据的变化，但是其实是使⽤了 hack 的办法，并且也是有缺
陷的。
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
// hack 以下⼏个函数
const methodsToPatch = [
 'push',
 'pop',
 'shift',
 'unshift',
 'splice',
 'sort',
 'reverse'
]
methodsToPatch.forEach(function (method) {
 // 获得原⽣函数
 const original = arrayProto[method]
 def(arrayMethods, method, function mutator (...args) {
 // 调⽤原⽣函数
 const result = original.apply(this, args)
 const ob = this.__ob__
 let inserted
 switch (method) {
 case 'push':
 case 'unshift':
 inserted = args
 break
 case 'splice':
 inserted = args.slice(2)
 break
 }
 if (inserted) ob.observeArray(inserted)
 // 触发更新
 ob.dep.notify()
反观 Proxy 就没以上的问题，原⽣⽀持监听数组变化，并且可以直接对整个对象进⾏拦截，
所以 Vue 也将在下个⼤版本中使⽤ Proxy 替换 Object.defineProperty
 return result
 })
})
let onWatch = (obj, setBind, getLogger) => {
 let handler = {
 get(target, property, receiver) {
 getLogger(target, property)
 return Reflect.get(target, property, receiver);
 },
 set(target, property, value, receiver) {
 setBind(value);
 return Reflect.set(target, property, value);
 }
 };
 return new Proxy(obj, handler);
};
let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
 value = v
}, (target, property) => {
 console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
路由原理
前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的
⻚⾯，并且⽆须刷新。⽬前单⻚⾯使⽤的路由就只有两种实现⽅式
hash 模式
history 模式
www.test.com/#/ 就是 Hash URL，当 # 后⾯的哈希值发⽣变化时，不会向服务器请求数
据，可以通过 hashchange 事件来监听到 URL 的变化，从⽽进⾏跳转⻚⾯。
History 模式是 HTML5 新推出的功能，⽐之 Hash URL 更加美观
Virtual Dom
代码地址
为什么需要 Virtual Dom
众所周知，操作 DOM 是很耗费性能的⼀件事情，既然如此，我们可以考虑通过 JS 对象来模
拟 DOM 对象，毕竟操作 JS 对象⽐操作 DOM 省时的多。
举个例⼦
从上述例⼦中，我们⼀眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。
如果以上操作对应到 DOM 中，那么就是以下代码
// 假设这⾥模拟⼀个 ul，其中包含了 5 个 li
[1, 2, 3, 4, 5]
// 这⾥替换上⾯的 li
[1, 2, 5, 4]
当然在实际操作中，我们还需要给每个节点⼀个标识，作为判断是同⼀个节点的依据。所以
这也是 Vue 和 React 中官⽅推荐列表⾥的节点使⽤唯⼀的 key 来保证性能。
那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的
DOM
以下是⼀个 JS 对象模拟 DOM 对象的简单实现
// 删除第三个 li
ul.childNodes[2].remove()
// 将第四个 li 和第五个交换位置
let fromNode = ul.childNodes[4]
let toNode = node.childNodes[3]
let cloneFromNode = fromNode.cloneNode(true)
let cloenToNode = toNode.cloneNode(true)
ul.replaceChild(cloneFromNode, toNode)
ul.replaceChild(cloenToNode, fromNode)
export default class Element {
 /**
 * @param {String} tag 'div'
 * @param {Object} props { class: 'item' }
 * @param {Array} children [ Element1, 'text']
 * @param {String} key option
 */
 constructor(tag, props, children, key) {
 this.tag = tag
 this.props = props
 if (Array.isArray(children)) {
 this.children = children
 } else if (isString(children)) {
 this.key = children
 this.children = null
 }
 if (key) this.key = key
 }
 // 渲染
 render() {
 let root = this._createElement(
 this.tag,
 this.props,
 this.children,
 this.key
 )
 document.body.appendChild(root)
 return root
 }
 create() {
 return this._createElement(this.tag, this.props, this.children,
this.key)
 }
 // 创建节点
 _createElement(tag, props, child, key) {
 // 通过 tag 创建节点
 let el = document.createElement(tag)
 // 设置节点属性
 for (const key in props) {
 if (props.hasOwnProperty(key)) {
 const value = props[key]
 el.setAttribute(key, value)
 }
 }
 if (key) {
 el.setAttribute('key', key)
 }
 // 递归添加⼦节点
 if (child) {
 child.forEach(element => {
 let child
 if (element instanceof Element) {
 child = this._createElement(
Virtual Dom 算法简述
既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新
的对象之间的差异。
DOM 是多叉树的结构，如果需要完整的对⽐两颗树的差异，那么需要的时间复杂度会是 O(n
^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来
对⽐差异。
实现 O(n) 复杂度的关键就是只对⽐同层的节点，⽽不是跨层对⽐，这也是考虑到在实际业务
中很少会去跨层的移动 DOM 元素。
所以判断差异的算法就分为了两步
⾸先从上⾄下，从左往右遍历对象，也就是树的深度遍历，这⼀步中会给每个节点添加索
引，便于最后渲染差异
⼀旦节点有⼦元素，就去判断⼦元素是否有不同
 element.tag,
 element.props,
 element.children,
 element.key
 )
 } else {
 child = document.createTextNode(element)
 }
 el.appendChild(child)
 })
 }
 return el
 }
}
Virtual Dom 算法实现
树的递归
⾸先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对⽐会有⼏种情况
1. 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也
不再需要遍历新旧节点的⼦元素了，因为整个旧节点都被删掉了
2. 新的节点的 tagName 和 key （可能都没有）和旧的相同，开始遍历⼦树
3. 没有新的节点，那么什么都不⽤做
import { StateEnums, isString, move } from './util'
import Element from './element'
export default function diff(oldDomTree, newDomTree) {
 // ⽤于记录差异
 let pathchs = {}
 // ⼀开始的索引为 0
 dfs(oldDomTree, newDomTree, 0, pathchs)
 return pathchs
}
function dfs(oldNode, newNode, index, patches) {
 // ⽤于保存⼦树的更改
 let curPatches = []
 // 需要判断三种情况
 // 1.没有新的节点，那么什么都不⽤做
 // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换
 // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历⼦树
 if (!newNode) {
 } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key)
{
 // 判断属性是否变更
 let props = diffProps(oldNode.props, newNode.props)
 if (props.length) curPatches.push({ type: StateEnums.ChangeProps,
props })
判断属性的更改
判断属性的更改也分三个步骤
1. 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中
2. 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化
3. 在第⼆步中同时查看是否有属性不存在与旧的属性列列表中
 // 遍历⼦树
 diffChildren(oldNode.children, newNode.children, index, patches)
 } else {
 // 节点不同，需要替换
 curPatches.push({ type: StateEnums.Replace, node: newNode })
 }
 if (curPatches.length) {
 if (patches[index]) {
 patches[index] = patches[index].concat(curPatches)
 } else {
 patches[index] = curPatches
 }
 }
}
function diffProps(oldProps, newProps) {
 // 判断 Props 分以下三步骤
 // 先遍历 oldProps 查看是否存在删除的属性
 // 然后遍历 newProps 查看是否有属性值被修改
 // 最后查看是否有属性新增
 let change = []
 for (const key in oldProps) {
 if (oldProps.hasOwnProperty(key) && !newProps[key]) {
 change.push({
 prop: key
 })
判断列表差异算法实现
这个算法是整个 Virtual Dom 中最核⼼的算法，且让我⼀⼀为你道来。
这⾥的主要步骤其实和判断属性差异是类似的，也是分为三步
1. 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中
2. 遍历新的节点列表，判断是否有新的节点
3. 在第⼆步中同时判断节点是否有移动
PS：该算法只对有 key 的节点做处理
 }
 }
 for (const key in newProps) {
 if (newProps.hasOwnProperty(key)) {
 const prop = newProps[key]
 if (oldProps[key] && oldProps[key] !== newProps[key]) {
 change.push({
 prop: key,
 value: newProps[key]
 })
 } else if (!oldProps[key]) {
 change.push({
 prop: key,
 value: newProps[key]
 })
 }
 }
 }
 return change
}
function listDiff(oldList, newList, index, patches) {
 // 为了遍历⽅便，先取出两个 list 的所有 keys
 let oldKeys = getKeys(oldList)
 let newKeys = getKeys(newList)
 let changes = []
 // ⽤于保存变更后的节点数据
 // 使⽤该数组保存有以下好处
 // 1.可以正确获得被删除节点索引
 // 2.交换节点位置只需要操作⼀遍 DOM
 // 3.⽤于 `diffChildren` 函数中的判断，只需要遍历
 // 两个树中都存在的节点，⽽对于新增或者删除的节点来说，完全没必要
 // 再去判断⼀遍
 let list = []
 oldList &&
 oldList.forEach(item => {
 let key = item.key
 if (isString(item)) {
 key = item
 }
 // 寻找新的 children 中是否含有当前节点
 // 没有的话需要删除
 let index = newKeys.indexOf(key)
 if (index === -1) {
 list.push(null)
 } else list.push(key)
 })
 // 遍历变更后的数组
 let length = list.length
 // 因为删除数组元素是会更改索引的
 // 所有从后往前删可以保证索引不变
 for (let i = length - 1; i >= 0; i--) {
 // 判断当前元素是否为空，为空表示需要删除
 if (!list[i]) {
 list.splice(i, 1)
 changes.push({
 type: StateEnums.Remove,
 index: i
 })
 }
 }
 // 遍历新的 list，判断是否有节点新增或移动
 // 同时也对 `list` 做节点新增和移动节点的操作
 newList &&
 newList.forEach((item, i) => {
 let key = item.key
 if (isString(item)) {
 key = item
 }
 // 寻找旧的 children 中是否含有当前节点
 let index = list.indexOf(key)
 // 没找到代表新节点，需要插⼊
 if (index === -1 || key == null) {
 changes.push({
 type: StateEnums.Insert,
 node: item,
 index: i
 })
 list.splice(i, 0, key)
 } else {
 // 找到了，需要判断是否需要移动
 if (index !== i) {
 changes.push({
 type: StateEnums.Move,
 from: index,
 to: i
 })
 move(list, index, i)
 }
 }
 })
 return { changes, list }
}
function getKeys(list) {
遍历⼦元素打标识
对于这个函数来说，主要功能就两个
1. 判断两个列表差异
2. 给节点打上标记
总体来说，该函数实现的功能很简单
 let keys = []
 let text
 list &&
 list.forEach(item => {
 let key
 if (isString(item)) {
 key = [item]
 } else if (item instanceof Element) {
 key = item.key
 }
 keys.push(key)
 })
 return keys
}
function diffChildren(oldChild, newChild, index, patches) {
 let { changes, list } = listDiff(oldChild, newChild, index, patches)
 if (changes.length) {
 if (patches[index]) {
 patches[index] = patches[index].concat(changes)
 } else {
 patches[index] = changes
 }
 }
 // 记录上⼀个遍历过的节点
 let last = null
 oldChild &&
渲染差异
通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新
DOM 了，下⾯就让我们来看看 Virtual Dom 算法的最后⼀步骤
这个函数主要两个功能
1. 深度遍历树，将需要做变更操作的取出来
2. 局部更新 DOM
整体来说这部分代码还是很好理解的
 oldChild.forEach((item, i) => {
 let child = item && item.children
 if (child) {
 index =
 last && last.children ? index + last.children.length + 1 :
index + 1
 let keyIndex = list.indexOf(item.key)
 let node = newChild[keyIndex]
 // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历
 if (node) {
 dfs(item, node, index, patches)
 }
 } else index += 1
 last = item
 })
}
let index = 0
export default function patch(node, patchs) {
 let changes = patchs[index]
 let childNodes = node && node.childNodes
 // 这⾥的深度遍历和 diff 中是⼀样的
 if (!childNodes) index += 1
 if (changes && changes.length && patchs[index]) {
 changeDom(node, changes)
 }
 let last = null
 if (childNodes && childNodes.length) {
 childNodes.forEach((item, i) => {
 index =
 last && last.children ? index + last.children.length + 1 : index
+ 1
 patch(item, patchs)
 last = item
 })
 }
}
function changeDom(node, changes, noChild) {
 changes &&
 changes.forEach(change => {
 let { type } = change
 switch (type) {
 case StateEnums.ChangeProps:
 let { props } = change
 props.forEach(item => {
 if (item.value) {
 node.setAttribute(item.prop, item.value)
 } else {
 node.removeAttribute(item.prop)
 }
 })
 break
 case StateEnums.Remove:
 node.childNodes[change.index].remove()
 break
 case StateEnums.Insert:
 let dom
 if (isString(change.node)) {
 dom = document.createTextNode(change.node)
最后
Virtual Dom 算法的实现也就是以下三步
1. 通过 JS 来模拟创建 DOM 对象
2. 判断两个对象的差异
3. 渲染差异
 } else if (change.node instanceof Element) {
 dom = change.node.create()
 }
 node.insertBefore(dom, node.childNodes[change.index])
 break
 case StateEnums.Replace:
 node.parentNode.replaceChild(change.node.create(), node)
 break
 case StateEnums.Move:
 let fromNode = node.childNodes[change.from]
 let toNode = node.childNodes[change.to]
 let cloneFromNode = fromNode.cloneNode(true)
 let cloenToNode = toNode.cloneNode(true)
 node.replaceChild(cloneFromNode, toNode)
 node.replaceChild(cloenToNode, fromNode)
 break
 default:
 break
 }
 })
}
let test4 = new Element('div', { class: 'my-div' }, ['test4'])
let test5 = new Element('ul', { class: 'my-div' }, ['test5'])
let test1 = new Element('div', { class: 'my-div' }, [test4])
当然⽬前的实现还略显粗糙，但是对于理解 Virtual Dom 算法来说已经是完全⾜够的了。
Vue 章节
NextTick 原理分析
nextTick 可以让我们在下次 DOM 更新循环结束之后执⾏延迟回调，⽤于获得更新后的
DOM。
在 Vue 2.4 之前都是使⽤的 microtasks，但是 microtasks 的优先级过⾼，在某些情况下可能
会出现⽐事件冒泡更快的情况，但如果都使⽤ macrotasks ⼜可能会出现渲染的性能问题。所
以在新版本中，会默认使⽤ microtasks，但在特殊情况下会使⽤ macrotasks，⽐如 v-on。
对于实现 macrotasks ，会先判断是否能使⽤ setImmediate ，不能的话降级为
MessageChannel ，以上都不⾏的话就使⽤ setTimeout
let test2 = new Element('div', { id: '11' }, [test5, test4])
let root = test1.render()
let pathchs = diff(test1, test2)
console.log(pathchs)
setTimeout(() => {
 console.log('开始更新')
 patch(root, pathchs)
 console.log('结束更新')
}, 1000)
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
 macroTimerFunc = () => {
 setImmediate(flushCallbacks)
nextTick 同时也⽀持 Promise 的使⽤，会判断是否实现了 Promise
 }
} else if (
 typeof MessageChannel !== 'undefined' &&
 (isNative(MessageChannel) ||
 // PhantomJS
 MessageChannel.toString() === '[object MessageChannelConstructor]')
) {
 const channel = new MessageChannel()
 const port = channel.port2
 channel.port1.onmessage = flushCallbacks
 macroTimerFunc = () => {
 port.postMessage(1)
 }
} else {
 /* istanbul ignore next */
 macroTimerFunc = () => {
 setTimeout(flushCallbacks, 0)
 }
}
export function nextTick(cb?: Function, ctx?: Object) {
 let _resolve
 // 将回调函数整合进⼀个数组中
 callbacks.push(() => {
 if (cb) {
 try {
 cb.call(ctx)
 } catch (e) {
 handleError(e, ctx, 'nextTick')
 }
 } else if (_resolve) {
 _resolve(ctx)
 }
⽣命周期分析
⽣命周期函数就是组件在初始化或者数据更新时会触发的钩⼦函数。
 })
 if (!pending) {
 pending = true
 if (useMacroTask) {
 macroTimerFunc()
 } else {
 microTimerFunc()
 }
 }
 // 判断是否可以使⽤ Promise
 // 可以的话给 _resolve 赋值
 // 这样回调函数就能以 promise 的⽅式调⽤
 if (!cb && typeof Promise !== 'undefined') {
 return new Promise(resolve => {
 _resolve = resolve
 })
 }
}
<p>在初始化时，会调⽤以下代码，⽣命周期就是通过 callHook 调⽤的<br>
可以发现在以上代码中， beforeCreate 调⽤的时候，是获取不到 props 或者 data 中的数据<br>
的，因为这些数据的初始化都在 initState 中。<br>
接下来会执⾏挂载函数<br>
Vue.prototype._init = function(options) {<br>
initLifecycle(vm)<br>
initEvents(vm)<br>
initRender(vm)<br>
callHook(vm, 'beforeCreate') // 拿不到 props data<br>
initInjections(vm)<br>
initState(vm)<br>
initProvide(vm)<br>
callHook(vm, 'created')<br>
}<br>
beforeMount 就是在挂载前执⾏的，然后开始创建 VDOM 并替换成真实 DOM，最后执⾏<br>
mounted 钩⼦。这⾥会有个判断逻辑，如果是外部 new Vue({}) 的话，不会存在 <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …// ...
 if (vm.'>vnode
，所以直接执⾏ mounted 钩⼦了。如果有⼦组件的话，会递归挂载⼦组件，只有当所有⼦组
件全部挂载完毕，才会执⾏根组件的挂载钩⼦。
接下来是数据更新时会调⽤的钩⼦函数
export function mountComponent {
 callHook(vm, &#039;beforeMount&#039;)
 // ...
 if (vm.</span>vnode == null) {<br>
vm._isMounted = true<br>
callHook(vm, 'mounted')<br>
}<br>
}<br>
function flushSchedulerQueue() {<br>
// ...<br>
for (index = 0; index &lt; queue.length; index++) {<br>
watcher = queue[index]<br>
if (watcher.before) {<br>
watcher.before() // 调⽤ beforeUpdate<br>
}<br>
id = watcher.id<br>
has[id] = null<br>
watcher.run()<br>
// in dev build, check and stop circular updates.<br>
if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) {<br>
circular[id] = (circular[id] || 0) + 1<br>
if (circular[id] &gt; MAX_UPDATE_COUNT) {<br>
warn(<br>
'You may have an infinite update loop ' +<br>
(watcher.user<br>
? <code>in watcher with expression &quot;${watcher.expression}&quot;</code><br>
: <code>in a component render function.</code>),<br>
上图还有两个⽣命周期没有说，分别为 activated 和 deactivated ，这两个钩⼦函数是<br>
keep-alive 组件独有的。⽤ keep-alive 包裹的组件在切换时不会进⾏销毁，⽽是缓存到<br>
内存中并执⾏ deactivated 钩⼦函数，命中缓存渲染后会执⾏ actived 钩⼦函数。<br>
最后就是销毁组件的钩⼦函数了<br>
watcher.vm<br>
)<br>
break<br>
}<br>
}<br>
}<br>
callUpdatedHooks(updatedQueue)<br>
}<br>
function callUpdatedHooks(queue) {<br>
let i = queue.length<br>
while (i--) {<br>
const watcher = queue[i]<br>
const vm = watcher.vm<br>
if (vm._watcher === watcher &amp;&amp; vm._isMounted) {<br>
callHook(vm, 'updated')<br>
}<br>
}<br>
}<br>
Vue.prototype.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …st parent = vm.'>destroy = function() {
 // ...
 callHook(vm, &#039;beforeDestroy&#039;)
 vm._isBeingDestroyed = true
 // remove self from parent
 const parent = vm.</span>parent<br>
if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: … remove(parent.'>options.abstract) {
 remove(parent.</span>children, vm)<br>
}<br>
在执⾏销毁操作前会调⽤ beforeDestroy 钩⼦函数，然后进⾏⼀系列的销毁操作，如果有<br>
⼦组件的话，也会递归销毁⼦组件，所有⼦组件都销毁完毕后才会执⾏根组件的 destroyed<br>
钩⼦函数。<br>
// teardown watchers<br>
if (vm._watcher) {<br>
vm._watcher.teardown()<br>
}<br>
let i = vm._watchers.length<br>
while (i--) {<br>
vm._watchers[i].teardown()<br>
}<br>
// remove reference from data ob<br>
// frozen object may not have observer.<br>
if (vm._data.<strong>ob</strong>) {<br>
vm._data.<strong>ob</strong>.vmCount--<br>
}<br>
// call the last hook...<br>
vm._isDestroyed = true<br>
// invoke destroy hooks on current rendered tree<br>
vm.<strong>patch</strong>(vm._vnode, null)<br>
// fire destroyed hook<br>
callHook(vm, 'destroyed')<br>
// turn off all instance listeners.<br>
vm.<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 18: …f()
 // remove _̲_vue__ referenc…'>off()
 // remove __vue__ reference
 if (vm.</span>el) {<br>
vm.<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 4: el._̲_vue__ = null
 …'>el.__vue__ = null
 }
 // release circular reference (#6759)
 if (vm.</span>vnode) {<br>
vm.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 22: …parent = null
 }̲
}
VueRouter 源码…'>vnode.parent = null
 }
}
VueRouter 源码解析
重要函数思维导图
以下思维导图罗列了源码中重要的⼀些函数
路由注册
在开始之前，推荐⼤家 clone ⼀份源码对照着看。因为篇幅较⻓，函数间的跳转也很多。
使⽤路由之前，需要调⽤ Vue.use(VueRouter) ，这是因为让插件可以使⽤ Vue
export function initUse (Vue: GlobalAPI) {
 Vue.use = function (plugin: Function | Object) {
 // 判断重复安装插件
 const installedPlugins = (this._installedPlugins ||
(this._installedPlugins = []))
 if (installedPlugins.indexOf(plugin) &gt; -1) {
 return this
 }
 const args = toArray(arguments, 1)
 // 插⼊ Vue
 args.unshift(this)
 // ⼀般插件都会有⼀个 install 函数
接下来看下 install 函数的部分实现
 // 通过该函数让插件可以使⽤ Vue
 if (typeof plugin.install === &#039;function&#039;) {
 plugin.install.apply(plugin, args)
 } else if (typeof plugin === &#039;function&#039;) {
 plugin.apply(null, args)
 }
 installedPlugins.push(plugin)
 return this
 }
}
export function install (Vue) {
 // 确保 install 调⽤⼀次
 if (install.installed &amp;&amp; _Vue === Vue) return
 install.installed = true
 // 把 Vue 赋值给全局变量
 _Vue = Vue
 const registerInstance = (vm, callVal) =&gt; {
 let i = vm.</span>options._parentVnode<br>
if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i =<br>
i.registerRouteInstance)) {<br>
i(vm, callVal)<br>
}<br>
}<br>
// 给每个组件的钩⼦函数混⼊实现<br>
// 可以发现在 <code>beforeCreate</code> 钩⼦执⾏时<br>
// 会初始化路由<br>
Vue.mixin({<br>
beforeCreate () {<br>
// 判断组件是否存在 router 对象，该对象只在根组件上有<br>
if (isDef(this.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …_router = this.'>options.router)) {
 // 根路由设置为⾃⼰
 this._routerRoot = this
对于路由注册来说，核⼼就是调⽤ Vue.use(VueRouter) ，使得 VueRouter 可以使⽤ Vue。
然后通过 Vue 来调⽤ VueRouter 的 install 函数。在该函数中，核⼼就是给组件混⼊钩⼦
函数和全局注册两个路由组件。
VueRouter 实例化
在安装插件后，对 VueRouter 进⾏实例化。
 this._router = this.</span>options.router<br>
// 初始化路由<br>
this._router.init(this)<br>
// 很重要，为 _route 属性实现双向绑定<br>
// 触发组件渲染<br>
Vue.util.defineReactive(this, '_route',<br>
this._router.history.current)<br>
} else {<br>
// ⽤于 router-view 层级判断<br>
this._routerRoot = (this.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 8: parent &amp;̲&amp; this.'>parent &amp;&amp; this.</span>parent._routerRoot) ||<br>
this<br>
}<br>
registerInstance(this, this)<br>
},<br>
destroyed () {<br>
registerInstance(this)<br>
}<br>
})<br>
// 全局注册组件 router-link 和 router-view<br>
Vue.component('RouterView', View)<br>
Vue.component('RouterLink', Link)<br>
}<br>
const Home = { template: '<div>home</div>' }<br>
const Foo = { template: '<div>foo</div>' }<br>
const Bar = { template: '<div>bar</div>' }<br>
来看⼀下 VueRouter 的构造函数<br>
// 3. Create the router<br>
const router = new VueRouter({<br>
mode: 'hash',<br>
base: __dirname,<br>
routes: [<br>
{ path: '/', component: Home }, // all paths are defined without the<br>
hash.<br>
{ path: '/foo', component: Foo },<br>
{ path: '/bar', component: Bar }<br>
]<br>
})<br>
constructor(options: RouterOptions = {}) {<br>
// ...<br>
// 路由匹配对象<br>
this.matcher = createMatcher(options.routes || [], this)<br>
// 根据 mode 采取不同的路由⽅式<br>
let mode = options.mode || 'hash'<br>
this.fallback =<br>
mode === 'history' &amp;&amp; !supportsPushState &amp;&amp; options.fallback !==<br>
false<br>
if (this.fallback) {<br>
mode = 'hash'<br>
}<br>
if (!inBrowser) {<br>
mode = 'abstract'<br>
}<br>
this.mode = mode<br>
switch (mode) {<br>
case 'history':<br>
this.history = new HTML5History(this, options.base)<br>
在实例化 VueRouter 的过程中，核⼼是创建⼀个路由匹配对象，并且根据 mode 来采取不同<br>
的路由⽅式。<br>
创建路由匹配对象<br>
break<br>
case 'hash':<br>
this.history = new HashHistory(this, options.base,<br>
this.fallback)<br>
break<br>
case 'abstract':<br>
this.history = new AbstractHistory(this, options.base)<br>
break<br>
default:<br>
if (process.env.NODE_ENV !== 'production') {<br>
assert(false, <code>invalid mode: ${mode}</code>)<br>
}<br>
}<br>
}<br>
export function createMatcher (<br>
routes: Array<RouteConfig>,<br>
router: VueRouter<br>
): Matcher {<br>
// 创建路由映射表<br>
const { pathList, pathMap, nameMap } = createRouteMap(routes)</p>
<p>function addRoutes (routes) {<br>
createRouteMap(routes, pathList, pathMap, nameMap)<br>
}<br>
// 路由匹配<br>
function match (<br>
raw: RawLocation,<br>
currentRoute?: Route,<br>
redirectedFrom?: Location<br>
createMatcher 函数的作⽤就是创建路由映射表，然后通过闭包的⽅式让 addRoutes 和<br>
match 函数能够使⽤路由映射表的⼏个对象，最后返回⼀个 Matcher 对象。<br>
接下来看 createMatcher 函数时如何创建映射表的<br>
): Route {<br>
//...<br>
}<br>
return {<br>
match,<br>
addRoutes<br>
}<br>
}<br>
export function createRouteMap (<br>
routes: Array<RouteConfig>,<br>
oldPathList?: Array<string>,<br>
oldPathMap?: Dictionary<RouteRecord>,<br>
oldNameMap?: Dictionary<RouteRecord><br>
): {<br>
pathList: Array<string>;<br>
pathMap: Dictionary<RouteRecord>;<br>
nameMap: Dictionary<RouteRecord>;<br>
} {<br>
// 创建映射表<br>
const pathList: Array<string> = oldPathList || []<br>
const pathMap: Dictionary<RouteRecord> = oldPathMap ||<br>
Object.create(null)<br>
const nameMap: Dictionary<RouteRecord> = oldNameMap ||<br>
Object.create(null)<br>
// 遍历路由配置，为每个配置添加路由记录<br>
routes.forEach(route =&gt; {<br>
addRouteRecord(pathList, pathMap, nameMap, route)<br>
})<br>
// 确保通配符在最后<br>
for (let i = 0, l = pathList.length; i &lt; l; i++) {<br>
if (pathList[i] === '<em>') {<br>
pathList.push(pathList.splice(i, 1)[0])<br>
l--<br>
i--<br>
}<br>
}<br>
return {<br>
pathList,<br>
pathMap,<br>
nameMap<br>
}<br>
}<br>
// 添加路由记录<br>
function addRouteRecord (<br>
pathList: Array<string>,<br>
pathMap: Dictionary<RouteRecord>,<br>
nameMap: Dictionary<RouteRecord>,<br>
route: RouteConfig,<br>
parent?: RouteRecord,<br>
matchAs?: string<br>
) {<br>
// 获得路由配置下的属性<br>
const { path, name } = route<br>
const pathToRegexpOptions: PathToRegexpOptions =<br>
route.pathToRegexpOptions || {}<br>
// 格式化 url，替换 /<br>
const normalizedPath = normalizePath(<br>
path,<br>
parent,<br>
pathToRegexpOptions.strict<br>
)<br>
// ⽣成记录对象<br>
const record: RouteRecord = {<br>
path: normalizedPath,<br>
regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),<br>
components: route.components || { default: route.component },<br>
instances: {},<br>
name,<br>
parent,<br>
matchAs,<br>
redirect: route.redirect,<br>
beforeEnter: route.beforeEnter,<br>
meta: route.meta || {},<br>
props: route.props == null<br>
? {}<br>
: route.components<br>
? route.props<br>
: { default: route.props }<br>
}<br>
if (route.children) {<br>
// 递归路由配置的 children 属性，添加路由记录<br>
route.children.forEach(child =&gt; {<br>
const childMatchAs = matchAs<br>
? cleanPath(<code>${matchAs}/${child.path}</code>)<br>
: undefined<br>
addRouteRecord(pathList, pathMap, nameMap, child, record,<br>
childMatchAs)<br>
})<br>
}<br>
// 如果路由有别名的话<br>
// 给别名也添加路由记录<br>
if (route.alias !== undefined) {<br>
const aliases = Array.isArray(route.alias)<br>
? route.alias<br>
: [route.alias]<br>
aliases.forEach(alias =&gt; {<br>
const aliasRoute = {<br>
path: alias,<br>
以上就是创建路由匹配对象的全过程，通过⽤户配置的路由规则来创建对应的路由映射表。<br>
children: route.children<br>
}<br>
addRouteRecord(<br>
pathList,<br>
pathMap,<br>
nameMap,<br>
aliasRoute,<br>
parent,<br>
record.path || '/' // matchAs<br>
)<br>
})<br>
}<br>
// 更新映射表<br>
if (!pathMap[record.path]) {<br>
pathList.push(record.path)<br>
pathMap[record.path] = record<br>
}<br>
// 命名路由添加记录<br>
if (name) {<br>
if (!nameMap[name]) {<br>
nameMap[name] = record<br>
} else if (process.env.NODE_ENV !== 'production' &amp;&amp; !matchAs) {<br>
warn(<br>
false,<br>
<code>Duplicate named routes definition:</code> +<br>
<code>{ name: &quot;${name}&quot;, path: &quot;${record.path}&quot; }</code><br>
)<br>
}<br>
}<br>
}<br>
路由初始化<br>
当根组件调⽤ beforeCreate 钩⼦函数时，会执⾏以下代码<br>
接下来看下路由初始化会做些什么<br>
beforeCreate () {<br>
// 只有根组件有 router 属性，所以根组件初始化时会初始化路由<br>
if (isDef(this.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …_router = this.'>options.router)) {
 this._routerRoot = this
 this._router = this.</span>options.router<br>
this._router.init(this)<br>
Vue.util.defineReactive(this, '_route',<br>
this._router.history.current)<br>
} else {<br>
this._routerRoot = (this.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 8: parent &amp;̲&amp; this.'>parent &amp;&amp; this.</span>parent._routerRoot) ||<br>
this<br>
}<br>
registerInstance(this, this)<br>
}<br>
init(app: any /</em> Vue component instance */) {<br>
// 保存组件实例<br>
this.apps.push(app)<br>
// 如果根组件已经有了就返回<br>
if (this.app) {<br>
return<br>
}<br>
this.app = app<br>
// 赋值路由模式<br>
const history = this.history<br>
// 判断路由模式，以哈希模式为例<br>
if (history instanceof HTML5History) {<br>
history.transitionTo(history.getCurrentLocation())<br>
} else if (history instanceof HashHistory) {<br>
在路由初始化时，核⼼就是进⾏路由的跳转，改变 URL 然后渲染对应的组件。接下来来看⼀<br>
下路由是如何进⾏跳转的。<br>
路由跳转<br>
// 添加 hashchange 监听<br>
const setupHashListener = () =&gt; {<br>
history.setupListeners()<br>
}<br>
// 路由跳转<br>
history.transitionTo(<br>
history.getCurrentLocation(),<br>
setupHashListener,<br>
setupHashListener<br>
)<br>
}<br>
// 该回调会在 transitionTo 中调⽤<br>
// 对组件的 _route 属性进⾏赋值，触发组件渲染<br>
history.listen(route =&gt; {<br>
this.apps.forEach(app =&gt; {<br>
app._route = route<br>
})<br>
})<br>
}<br>
transitionTo (location: RawLocation, onComplete?: Function, onAbort?:<br>
Function) {<br>
// 获取匹配的路由信息<br>
const route = this.router.match(location, this.current)<br>
// 确认切换路由<br>
this.confirmTransition(route, () =&gt; {<br>
// 以下为切换路由成功或失败的回调<br>
// 更新路由信息，对组件的 _route 属性进⾏赋值，触发组件渲染<br>
// 调⽤ afterHooks 中的钩⼦函数<br>
this.updateRoute(route)<br>
在路由跳转中，需要先获取匹配的路由信息，所以先来看下如何获取匹配的路由信息<br>
// 添加 hashchange 监听<br>
onComplete &amp;&amp; onComplete(route)<br>
// 更新 URL<br>
this.ensureURL()<br>
// 只执⾏⼀次 ready 回调<br>
if (!this.ready) {<br>
this.ready = true<br>
this.readyCbs.forEach(cb =&gt; { cb(route) })<br>
}<br>
}, err =&gt; {<br>
// 错误处理<br>
if (onAbort) {<br>
onAbort(err)<br>
}<br>
if (err &amp;&amp; !this.ready) {<br>
this.ready = true<br>
this.readyErrorCbs.forEach(cb =&gt; { cb(err) })<br>
}<br>
})<br>
}<br>
function match (<br>
raw: RawLocation,<br>
currentRoute?: Route,<br>
redirectedFrom?: Location<br>
): Route {<br>
// 序列化 url<br>
// ⽐如对于该 url 来说 /abc?foo=bar&amp;baz=qux#hello<br>
// 会序列化路径为 /abc<br>
// 哈希为 #hello<br>
// 参数为 foo: 'bar', baz: 'qux'<br>
const location = normalizeLocation(raw, currentRoute, false, router)<br>
const { name } = location<br>
// 如果是命名路由，就判断记录中是否有该命名路由配置<br>
if (name) {<br>
const record = nameMap[name]<br>
// 没找到表示没有匹配的路由<br>
if (!record) return _createRoute(null, location)<br>
const paramNames = record.regex.keys<br>
.filter(key =&gt; !key.optional)<br>
.map(key =&gt; key.name)<br>
// 参数处理<br>
if (typeof location.params !== 'object') {<br>
location.params = {}<br>
}<br>
if (currentRoute &amp;&amp; typeof currentRoute.params === 'object') {<br>
for (const key in currentRoute.params) {<br>
if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {<br>
location.params[key] = currentRoute.params[key]<br>
}<br>
}<br>
}<br>
if (record) {<br>
location.path = fillParams(record.path, location.params, <code>named route &quot;${name}&quot;</code>)<br>
return _createRoute(record, location, redirectedFrom)<br>
}<br>
} else if (location.path) {<br>
// ⾮命名路由处理<br>
location.params = {}<br>
for (let i = 0; i &lt; pathList.length; i++) {<br>
// 查找记录<br>
const path = pathList[i]<br>
const record = pathMap[path]<br>
// 如果匹配路由，则创建路由<br>
if (matchRoute(record.regex, location.path, location.params)) {<br>
return _createRoute(record, location, redirectedFrom)<br>
}<br>
}<br>
接下来看看如何创建路由<br>
}<br>
// 没有匹配的路由<br>
return _createRoute(null, location)<br>
}<br>
// 根据条件创建不同的路由<br>
function _createRoute(<br>
record: ?RouteRecord,<br>
location: Location,<br>
redirectedFrom?: Location<br>
): Route {<br>
if (record &amp;&amp; record.redirect) {<br>
return redirect(record, redirectedFrom || location)<br>
}<br>
if (record &amp;&amp; record.matchAs) {<br>
return alias(record, location, record.matchAs)<br>
}<br>
return createRoute(record, location, redirectedFrom, router)<br>
}<br>
export function createRoute (<br>
record: ?RouteRecord,<br>
location: Location,<br>
redirectedFrom?: ?Location,<br>
router?: VueRouter<br>
): Route {<br>
const stringifyQuery = router &amp;&amp; router.options.stringifyQuery<br>
// 克隆参数<br>
let query: any = location.query || {}<br>
try {<br>
query = clone(query)<br>
} catch (e) {}<br>
// 创建路由对象<br>
⾄此匹配路由已经完成，我们回到 transitionTo 函数中，接下来执⾏<br>
confirmTransition<br>
const route: Route = {<br>
name: location.name || (record &amp;&amp; record.name),<br>
meta: (record &amp;&amp; record.meta) || {},<br>
path: location.path || '/',<br>
hash: location.hash || '',<br>
query,<br>
params: location.params || {},<br>
fullPath: getFullPath(location, stringifyQuery),<br>
matched: record ? formatMatch(record) : []<br>
}<br>
if (redirectedFrom) {<br>
route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)<br>
}<br>
// 让路由对象不可修改<br>
return Object.freeze(route)<br>
}<br>
// 获得包含当前路由的所有嵌套路径⽚段的路由记录<br>
// 包含从根路由到当前路由的匹配记录，从上⾄下<br>
function formatMatch(record: ?RouteRecord): Array<RouteRecord> {<br>
const res = []<br>
while (record) {<br>
res.unshift(record)<br>
record = record.parent<br>
}<br>
return res<br>
}<br>
transitionTo (location: RawLocation, onComplete?: Function, onAbort?:<br>
Function) {<br>
// 确认切换路由<br>
this.confirmTransition(route, () =&gt; {}<br>
}<br>
confirmTransition(route: Route, onComplete: Function, onAbort?:<br>
Function) {<br>
const current = this.current<br>
// 中断跳转路由函数<br>
const abort = err =&gt; {<br>
if (isError(err)) {<br>
if (this.errorCbs.length) {<br>
this.errorCbs.forEach(cb =&gt; {<br>
cb(err)<br>
})<br>
} else {<br>
warn(false, 'uncaught error during route navigation:')<br>
console.error(err)<br>
}<br>
}<br>
onAbort &amp;&amp; onAbort(err)<br>
}<br>
// 如果是相同的路由就不跳转<br>
if (<br>
isSameRoute(route, current) &amp;&amp;<br>
route.matched.length === current.matched.length<br>
) {<br>
this.ensureURL()<br>
return abort()<br>
}<br>
// 通过对⽐路由解析出可复⽤的组件，需要渲染的组件，失活的组件<br>
const { updated, deactivated, activated } = resolveQueue(<br>
this.current.matched,<br>
route.matched<br>
)</p>
<p>function resolveQueue(<br>
current: Array<RouteRecord>,<br>
next: Array<RouteRecord><br>
): {<br>
updated: Array<RouteRecord>,<br>
activated: Array<RouteRecord>,<br>
deactivated: Array<RouteRecord><br>
} {<br>
let i<br>
const max = Math.max(current.length, next.length)<br>
for (i = 0; i &lt; max; i++) {<br>
// 当前路由路径和跳转路由路径不同时跳出遍历<br>
if (current[i] !== next[i]) {<br>
break<br>
}<br>
}<br>
return {<br>
// 可复⽤的组件对应路由<br>
updated: next.slice(0, i),<br>
// 需要渲染的组件对应路由<br>
activated: next.slice(i),<br>
// 失活的组件对应路由<br>
deactivated: current.slice(i)<br>
}<br>
}<br>
// 导航守卫数组<br>
const queue: Array&lt;?NavigationGuard&gt; = [].concat(<br>
// 失活的组件钩⼦<br>
extractLeaveGuards(deactivated),<br>
// 全局 beforeEach 钩⼦<br>
this.router.beforeHooks,<br>
// 在当前路由改变，但是该组件被复⽤时调⽤<br>
extractUpdateHooks(updated),<br>
// 需要渲染组件 enter 守卫钩⼦<br>
activated.map(m =&gt; m.beforeEnter),<br>
// 解析异步路由组件<br>
resolveAsyncComponents(activated)<br>
)<br>
// 保存路由<br>
this.pending = route<br>
// 迭代器，⽤于执⾏ queue 中的导航守卫钩⼦<br>
const iterator = (hook: NavigationGuard, next) =&gt; {<br>
// 路由不相等就不跳转路由<br>
if (this.pending !== route) {<br>
return abort()<br>
}<br>
try {<br>
// 执⾏钩⼦<br>
hook(route, current, (to: any) =&gt; {<br>
// 只有执⾏了钩⼦函数中的 next，才会继续执⾏下⼀个钩⼦函数<br>
// 否则会暂停跳转<br>
// 以下逻辑是在判断 next() 中的传参<br>
if (to === false || isError(to)) {<br>
// next(false)<br>
this.ensureURL(true)<br>
abort(to)<br>
} else if (<br>
typeof to === 'string' ||<br>
(typeof to === 'object' &amp;&amp;<br>
(typeof to.path === 'string' || typeof to.name ===<br>
'string'))<br>
) {<br>
// next('/') 或者 next({ path: '/' }) -&gt; 重定向<br>
abort()<br>
if (typeof to === 'object' &amp;&amp; to.replace) {<br>
this.replace(to)<br>
} else {<br>
this.push(to)<br>
}<br>
} else {<br>
// 这⾥执⾏ next<br>
// 也就是执⾏下⾯函数 runQueue 中的 step(index + 1)<br>
next(to)<br>
}<br>
})<br>
} catch (e) {<br>
abort(e)<br>
}<br>
}<br>
// 经典的同步执⾏异步函数<br>
runQueue(queue, iterator, () =&gt; {<br>
const postEnterCbs = []<br>
const isValid = () =&gt; this.current === route<br>
// 当所有异步组件加载完成后，会执⾏这⾥的回调，也就是 runQueue 中的 cb()<br>
// 接下来执⾏ 需要渲染组件的导航守卫钩⼦<br>
const enterGuards = extractEnterGuards(activated, postEnterCbs,<br>
isValid)<br>
const queue = enterGuards.concat(this.router.resolveHooks)<br>
runQueue(queue, iterator, () =&gt; {<br>
// 跳转完成<br>
if (this.pending !== route) {<br>
return abort()<br>
}<br>
this.pending = null<br>
onComplete(route)<br>
if (this.router.app) {<br>
this.router.app.$nextTick(() =&gt; {<br>
postEnterCbs.forEach(cb =&gt; {<br>
cb()<br>
})<br>
})<br>
}<br>
})<br>
})<br>
}<br>
export function runQueue (queue: Array&lt;?NavigationGuard&gt;, fn: Function,<br>
cb: Function) {<br>
const step = index =&gt; {<br>
// 队列中的函数都执⾏完毕，就执⾏回调函数<br>
if (index &gt;= queue.length) {<br>
cb()<br>
} else {<br>
if (queue[index]) {<br>
接下来介绍导航守卫<br>
第⼀步是先执⾏失活组件的钩⼦函数<br>
// 执⾏迭代器，⽤户在钩⼦函数中执⾏ next() 回调<br>
// 回调中判断传参，没有问题就执⾏ next()，也就是 fn 函数中的第⼆个参数<br>
fn(queue[index], () =&gt; {<br>
step(index + 1)<br>
})<br>
} else {<br>
step(index + 1)<br>
}<br>
}<br>
}<br>
// 取出队列中第⼀个钩⼦函数<br>
step(0)<br>
}<br>
const queue: Array&lt;?NavigationGuard&gt; = [].concat(<br>
// 失活的组件钩⼦<br>
extractLeaveGuards(deactivated),<br>
// 全局 beforeEach 钩⼦<br>
this.router.beforeHooks,<br>
// 在当前路由改变，但是该组件被复⽤时调⽤<br>
extractUpdateHooks(updated),<br>
// 需要渲染组件 enter 守卫钩⼦<br>
activated.map(m =&gt; m.beforeEnter),<br>
// 解析异步路由组件<br>
resolveAsyncComponents(activated)<br>
)<br>
function extractLeaveGuards(deactivated: Array<RouteRecord>): Array&lt;?<br>
Function&gt; {<br>
// 传⼊需要执⾏的钩⼦函数名<br>
return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)<br>
}<br>
function extractGuards(<br>
records: Array<RouteRecord>,<br>
name: string,<br>
bind: Function,<br>
reverse?: boolean<br>
): Array&lt;?Function&gt; {<br>
const guards = flatMapComponents(records, (def, instance, match, key)<br>
=&gt; {<br>
// 找出组件中对应的钩⼦函数<br>
const guard = extractGuard(def, name)<br>
if (guard) {<br>
// 给每个钩⼦函数添加上下⽂对象为组件⾃身<br>
return Array.isArray(guard)<br>
? guard.map(guard =&gt; bind(guard, instance, match, key))<br>
: bind(guard, instance, match, key)<br>
}<br>
})<br>
// 数组降维，并且判断是否需要翻转数组<br>
// 因为某些钩⼦函数需要从⼦执⾏到⽗<br>
return flatten(reverse ? guards.reverse() : guards)<br>
}<br>
export function flatMapComponents (<br>
matched: Array<RouteRecord>,<br>
fn: Function<br>
): Array&lt;?Function&gt; {<br>
// 数组降维<br>
return flatten(matched.map(m =&gt; {<br>
// 将组件中的对象传⼊回调函数中，获得钩⼦函数数组<br>
return Object.keys(m.components).map(key =&gt; fn(<br>
m.components[key],<br>
m.instances[key],<br>
m, key<br>
))<br>
}))<br>
}<br>
第⼆步执⾏全局 beforeEach 钩⼦函数<br>
在 VueRouter 类中有以上代码，每当给 VueRouter 实例添加 beforeEach 函数时就会将函数<br>
push 进 beforeHooks 中。<br>
第三步执⾏ beforeRouteUpdate 钩⼦函数，调⽤⽅式和第⼀步相同，只是传⼊的函数名不<br>
同，在该函数中可以访问到 this 对象。<br>
第四步执⾏ beforeEnter 钩⼦函数，该函数是路由独享的钩⼦函数。<br>
第五步是解析异步组件。<br>
beforeEach(fn: Function): Function {<br>
return registerHook(this.beforeHooks, fn)<br>
}<br>
function registerHook(list: Array<any>, fn: Function): Function {<br>
list.push(fn)<br>
return () =&gt; {<br>
const i = list.indexOf(fn)<br>
if (i &gt; -1) list.splice(i, 1)<br>
}<br>
}<br>
export function resolveAsyncComponents (matched: Array<RouteRecord>):<br>
Function {<br>
return (to, from, next) =&gt; {<br>
let hasAsync = false<br>
let pending = 0<br>
let error = null<br>
// 该函数作⽤之前已经介绍过了<br>
flatMapComponents(matched, (def, _, match, key) =&gt; {<br>
// 判断是否是异步组件<br>
if (typeof def === 'function' &amp;&amp; def.cid === undefined) {<br>
hasAsync = true<br>
pending++<br>
// 成功回调<br>
// once 函数确保异步组件只加载⼀次<br>
const resolve = once(resolvedDef =&gt; {<br>
if (isESModule(resolvedDef)) {<br>
resolvedDef = resolvedDef.default<br>
}<br>
// 判断是否是构造函数<br>
// 不是的话通过 Vue 来⽣成组件构造函数<br>
def.resolved = typeof resolvedDef === 'function'<br>
? resolvedDef<br>
: _Vue.extend(resolvedDef)<br>
// 赋值组件<br>
// 如果组件全部解析完毕，继续下⼀步<br>
match.components[key] = resolvedDef<br>
pending--<br>
if (pending &lt;= 0) {<br>
next()<br>
}<br>
})<br>
// 失败回调<br>
const reject = once(reason =&gt; {<br>
const msg = <code>Failed to resolve async component ${key}: ${reason}</code><br>
process.env.NODE_ENV !== 'production' &amp;&amp; warn(false, msg)<br>
if (!error) {<br>
error = isError(reason)<br>
? reason<br>
: new Error(msg)<br>
next(error)<br>
}<br>
})<br>
let res<br>
try {<br>
// 执⾏异步组件函数<br>
res = def(resolve, reject)<br>
以上就是第⼀个 runQueue 中的逻辑，第五步完成后会执⾏第⼀个 runQueue 中回调函数<br>
} catch (e) {<br>
reject(e)<br>
}<br>
if (res) {<br>
// 下载完成执⾏回调<br>
if (typeof res.then === 'function') {<br>
res.then(resolve, reject)<br>
} else {<br>
const comp = res.component<br>
if (comp &amp;&amp; typeof comp.then === 'function') {<br>
comp.then(resolve, reject)<br>
}<br>
}<br>
}<br>
}<br>
})<br>
// 不是异步组件直接下⼀步<br>
if (!hasAsync) next()<br>
}<br>
}<br>
// 该回调⽤于保存 <code>beforeRouteEnter</code> 钩⼦中的回调函数<br>
const postEnterCbs = []<br>
const isValid = () =&gt; this.current === route<br>
// beforeRouteEnter 导航守卫钩⼦<br>
const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)<br>
// beforeResolve 导航守卫钩⼦<br>
const queue = enterGuards.concat(this.router.resolveHooks)<br>
runQueue(queue, iterator, () =&gt; {<br>
if (this.pending !== route) {<br>
return abort()<br>
}<br>
this.pending = null<br>
第六步是执⾏ beforeRouteEnter 导航守卫钩⼦， beforeRouteEnter 钩⼦不能访问<br>
this 对象，因为钩⼦在导航确认前被调⽤，需要渲染的组件还没被创建。但是该钩⼦函数<br>
是唯⼀⼀个⽀持在回调中获取 this 对象的函数，回调会在路由确认执⾏。<br>
下⾯来看看是如何⽀持在回调中拿到 this 对象的<br>
// 这⾥会执⾏ afterEach 导航守卫钩⼦<br>
onComplete(route)<br>
if (this.router.app) {<br>
this.router.app.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 63: … cb()
 })
 })
 }̲
})
beforeRoute…'>nextTick(() =&gt; {
 postEnterCbs.forEach(cb =&gt; {
 cb()
 })
 })
 }
})
beforeRouteEnter (to, from, next) {
 next(vm =&gt; {
 // 通过 `vm` 访问组件实例
 })
}
function extractEnterGuards(
 activated: Array&lt;RouteRecord&gt;,
 cbs: Array&lt;Function&gt;,
 isValid: () =&gt; boolean
): Array&lt;?Function&gt; {
// 这⾥和之前调⽤导航守卫基本⼀致
 return extractGuards(
 activated,
 &#039;beforeRouteEnter&#039;,
 (guard, _, match, key) =&gt; {
 return bindEnterGuard(guard, match, key, cbs, isValid)
 }
 )
}
function bindEnterGuard(
 guard: NavigationGuard,
 match: RouteRecord,
 key: string,
 cbs: Array&lt;Function&gt;,
 isValid: () =&gt; boolean
): NavigationGuard {
 return function routeEnterGuard(to, from, next) {
 return guard(to, from, cb =&gt; {
 // 判断 cb 是否是函数
 // 是的话就 push 进 postEnterCbs
 next(cb)
 if (typeof cb === &#039;function&#039;) {
 cbs.push(() =&gt; {
 // 循环直到拿到组件实例
 poll(cb, match.instances, key, isValid)
 })
 }
 })
 }
}
// 该函数是为了解决 issus #750
// 当 router-view 外⾯包裹了 mode 为 out-in 的 transition 组件
// 会在组件初次导航到时获得不到组件实例对象
function poll(
 cb: any, // somehow flow cannot infer this is a function
 instances: Object,
 key: string,
 isValid: () =&gt; boolean
) {
 if (
 instances[key] &amp;&amp;
 !instances[key]._isBeingDestroyed // do not reuse being destroyed
instance
第七步是执⾏ beforeResolve 导航守卫钩⼦，如果注册了全局 beforeResolve 钩⼦就会
在这⾥执⾏。
第⼋步就是导航确认，调⽤ afterEach 导航守卫钩⼦了。
以上都执⾏完成后，会触发组件的渲染
以上回调会在 updateRoute 中调⽤
 ) {
 cb(instances[key])
 } else if (isValid()) {
 // setTimeout 16ms 作⽤和 nextTick 基本相同
 setTimeout(() =&gt; {
 poll(cb, instances, key, isValid)
 }, 16)
 }
}
history.listen(route =&gt; {
 this.apps.forEach(app =&gt; {
 app._route = route
 })
})
updateRoute(route: Route) {
 const prev = this.current
 this.current = route
 this.cb &amp;&amp; this.cb(route)
 this.router.afterHooks.forEach(hook =&gt; {
 hook &amp;&amp; hook(route, prev)
 })
}
⾄此，路由跳转已经全部分析完毕。核⼼就是判断需要跳转的路由是否存在于记录中，然后
执⾏各种导航守卫函数，最后完成 URL 的改变和组件的渲染。
React 章节
React ⽣命周期分析
在 V16 版本中引⼊了 Fiber 机制。这个机制⼀定程度上的影响了部分⽣命周期的调⽤，并且
也引⼊了新的 2 个 API 来解决问题。
在之前的版本中，如果你拥有⼀个很复杂的复合组件，然后改动了最上层组件的 state ，那
么调⽤栈可能会很⻓
调⽤栈过⻓，再加上中间进⾏了复杂的操作，就可能导致⻓时间阻塞主线程，带来不好的⽤
户体验。Fiber 就是为了解决该问题⽽⽣。
Fiber 本质上是⼀个虚拟的堆栈帧，新的调度器会按照优先级⾃由调度这些帧，从⽽将之前的
同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。
对于如何区别优先级，React 有⾃⼰的⼀套逻辑。对于动画这种实时性很⾼的东⻄，也就是
16 ms 必须渲染⼀次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停⼀下更新，返回
来继续渲染动画。
对于异步渲染，现在渲染有两个阶段： reconciliation 和 commit 。前者过程是可以打断
的，后者不能暂停，会⼀直更新界⾯直到完成。
Reconciliation 阶段
componentWillMount
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
Commit 阶段
componentDidMount
componentDidUpdate
componentWillUnmount
因为 reconciliation 阶段是可以被打断的，所以 reconciliation 阶段会执⾏的⽣命周
期函数就可能会出现调⽤多次的情况，从⽽引起 Bug。所以对于 reconciliation 阶段调⽤
的⼏个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使⽤，并且 V16 中也
引⼊了新的 API 来解决这个问题。
getDerivedStateFromProps ⽤于替换 componentWillReceiveProps ，该函数会在初始化
和 update 时被调⽤
getSnapshotBeforeUpdate ⽤于替换 componentWillUpdate ，该函数会在 update 后
DOM 更新前被调⽤，⽤于读取最新的 DOM 数据。
V16 ⽣命周期函数⽤法建议
class ExampleComponent extends React.Component {
 // Initialize state in constructor,
 // Or with a property initializer.
 state = {};
 static getDerivedStateFromProps(nextProps, prevState) {
 if (prevState.someMirroredValue !== nextProps.someValue) {
 return {
 derivedData: computeDerivedState(nextProps),
 someMirroredValue: nextProps.someValue
 };
 }
 // Return null to indicate no change to state.
 return null;
 }
}
class ExampleComponent extends React.Component {
 // ⽤于初始化 state
 constructor() {}
setState
setState 在 React 中是经常使⽤的⼀个 API，但是它存在⼀些问题，可能会导致犯错，核
⼼原因就是因为这个 API 是异步的。
⾸先 setState 的调⽤并不会⻢上引起 state 的改变，并且如果你⼀次调⽤了多个
setState ，那么结果可能并不如你期待的⼀样。
 // ⽤于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被
调⽤
 // 因为该函数是静态函数，所以取不到 `this`
 // 如果需要对⽐ `prevProps` 需要单独在 `state` 中维护
 static getDerivedStateFromProps(nextProps, prevState) {}
 // 判断是否需要更新组件，多⽤于组件性能优化
 shouldComponentUpdate(nextProps, nextState) {}
 // 组件挂载后调⽤
 // 可以在该函数中进⾏请求或者订阅
 componentDidMount() {}
 // ⽤于获得最新的 DOM 数据
 getSnapshotBeforeUpdate() {}
 // 组件即将销毁
 // 可以在此处移除订阅，定时器等等
 componentWillUnmount() {}
 // 组件销毁后调⽤
 componentDidUnMount() {}
 // 组件更新后调⽤
 componentDidUpdate() {}
 // 渲染组件函数
 render() {}
 // 以下函数不建议使⽤
 UNSAFE_componentWillMount() {}
 UNSAFE_componentWillUpdate(nextProps, nextState) {}
 UNSAFE_componentWillReceiveProps(nextProps) {}
}
第⼀，两次的打印都为 0，因为 setState 是个异步 API，只有同步代码运⾏完毕才会执
⾏。 setState 异步的原因我认为在于， setState 可能会导致 DOM 的重绘，如果调⽤⼀
次就⻢上去进⾏重绘，那么调⽤多次就会造成不必要的性能损失。设计成异步的话，就可以
将多次调⽤放⼊⼀个队列中，在恰当的时候统⼀进⾏更新过程。
第⼆，虽然调⽤了三次 setState ，但是 count 的值还是为 1。因为多次调⽤会合并为⼀
次，只有当更新结束后 state 才会改变，三次调⽤等同于如下代码
当然你也可以通过以下⽅式来实现调⽤三次 setState 使得 count 为 3
如果你想在每次调⽤ setState 后获得正确的 state ，可以通过如下代码实现
handle() {
 // 初始化 `count` 为 0
 console.log(this.state.count) // -&gt; 0
 this.setState({ count: this.state.count + 1 })
 this.setState({ count: this.state.count + 1 })
 this.setState({ count: this.state.count + 1 })
 console.log(this.state.count) // -&gt; 0
}
Object.assign(
 {},
 { count: this.state.count + 1 },
 { count: this.state.count + 1 },
 { count: this.state.count + 1 },
)
handle() {
 this.setState((prevState) =&gt; ({ count: prevState.count + 1 }))
 this.setState((prevState) =&gt; ({ count: prevState.count + 1 }))
 this.setState((prevState) =&gt; ({ count: prevState.count + 1 }))
}
Redux 源码分析
⾸先让我们来看下 combineReducers 函数
handle() {
 this.setState((prevState) =&gt; ({ count: prevState.count + 1 }), () =&gt;
{
 console.log(this.state)
 })
}
// 传⼊⼀个 object
export default function combineReducers(reducers) {
// 获取该 Object 的 key 值
 const reducerKeys = Object.keys(reducers)
 // 过滤后的 reducers
 const finalReducers = {}
 // 获取每⼀个 key 对应的 value
 // 在开发环境下判断值是否为 undefined
 // 然后将值类型是函数的值放⼊ finalReducers
 for (let i = 0; i &lt; reducerKeys.length; i++) {
 const key = reducerKeys[i]
 if (process.env.NODE_ENV !== &#039;production&#039;) {
 if (typeof reducers[key] === &#039;undefined&#039;) {
 warning(`No reducer provided for key &quot;</span>{key}&quot;`)<br>
}<br>
}<br>
if (typeof reducers[key] === 'function') {<br>
finalReducers[key] = reducers[key]<br>
}<br>
}<br>
// 拿到过滤后的 reducers 的 key 值<br>
const finalReducerKeys = Object.keys(finalReducers)</p>
<p>// 在开发环境下判断，保存不期望 key 的缓存⽤以下⾯做警告<br>
let unexpectedKeyCache<br>
if (process.env.NODE_ENV !== 'production') {<br>
unexpectedKeyCache = {}<br>
}</p>
<p>let shapeAssertionError<br>
try {<br>
// 该函数解析在下⾯<br>
assertReducerShape(finalReducers)<br>
} catch (e) {<br>
shapeAssertionError = e<br>
}<br>
// combineReducers 函数返回⼀个函数，也就是合并后的 reducer 函数<br>
// 该函数返回总的 state<br>
// 并且你也可以发现这⾥使⽤了闭包，函数⾥⾯使⽤到了外⾯的⼀些属性<br>
return function combination(state = {}, action) {<br>
if (shapeAssertionError) {<br>
throw shapeAssertionError<br>
}<br>
// 该函数解析在下⾯<br>
if (process.env.NODE_ENV !== 'production') {<br>
const warningMessage = getUnexpectedStateShapeWarningMessage(<br>
state,<br>
finalReducers,<br>
action,<br>
unexpectedKeyCache<br>
)<br>
if (warningMessage) {<br>
warning(warningMessage)<br>
}<br>
}<br>
// state 是否改变<br>
let hasChanged = false<br>
// 改变后的 state<br>
combineReducers 函数总的来说很简单，总结来说就是接收⼀个对象，将参数过滤后返回⼀<br>
个函数。该函数⾥有⼀个过滤参数后的对象 finalReducers，遍历该对象，然后执⾏对象中的<br>
每⼀个 reducer 函数，最后将新的 state 返回。<br>
接下来让我们来看看 combinrReducers 中⽤到的两个函数<br>
const nextState = {}<br>
for (let i = 0; i &lt; finalReducerKeys.length; i++) {<br>
// 拿到相应的 key<br>
const key = finalReducerKeys[i]<br>
// 获得 key 对应的 reducer 函数<br>
const reducer = finalReducers[key]<br>
// state 树下的 key 是与 finalReducers 下的 key 相同的<br>
// 所以你在 combineReducers 中传⼊的参数的 key 即代表了 各个 reducer 也<br>
代表了各个 state<br>
const previousStateForKey = state[key]<br>
// 然后执⾏ reducer 函数获得该 key 值对应的 state<br>
const nextStateForKey = reducer(previousStateForKey, action)<br>
// 判断 state 的值，undefined 的话就报错<br>
if (typeof nextStateForKey === 'undefined') {<br>
const errorMessage = getUndefinedStateErrorMessage(key, action)<br>
throw new Error(errorMessage)<br>
}<br>
// 然后将 value 塞进去<br>
nextState[key] = nextStateForKey<br>
// 如果 state 改变<br>
hasChanged = hasChanged || nextStateForKey !== previousStateForKey<br>
}<br>
// state 只要改变过，就返回新的 state<br>
return hasChanged ? nextState : state<br>
}<br>
}<br>
// 这是执⾏的第⼀个⽤于抛错的函数<br>
function assertReducerShape(reducers) {<br>
// 将 combineReducers 中的参数遍历<br>
Object.keys(reducers).forEach(key =&gt; {<br>
const reducer = reducers[key]<br>
// 给他传⼊⼀个 action<br>
const initialState = reducer(undefined, { type: ActionTypes.INIT })<br>
// 如果得到的 state 为 undefined 就抛错<br>
if (typeof initialState === 'undefined') {<br>
throw new Error(<br>
<code>Reducer &quot;${key}&quot; returned undefined during initialization.</code> +<br>
<code>If the state passed to the reducer is undefined, you must</code> +<br>
<code>explicitly return the initial state. The initial state may</code><br>
+<br>
<code>not be undefined. If you don't want to set a value for this reducer,</code> +<br>
<code>you can use null instead of undefined.</code><br>
)<br>
}<br>
// 再过滤⼀次，考虑到万⼀你在 reducer 中给 ActionTypes.INIT 返回了值<br>
// 传⼊⼀个随机的 action 判断值是否为 undefined<br>
const type =<br>
'@@redux/PROBE_UNKNOWN_ACTION_' +<br>
Math.random()<br>
.toString(36)<br>
.substring(7)<br>
.split('')<br>
.join('.')<br>
if (typeof reducer(undefined, { type }) === 'undefined') {<br>
throw new Error(<br>
<code>Reducer &quot;${key}&quot; returned undefined when probed with a random type.</code> +<br>
<code>Don't try to handle ${ ActionTypes.INIT } or other actions in &quot;redux/*&quot;</code> +<br>
<code>namespace. They are considered private. Instead, you must return the</code> +<br>
<code>current state for any unknown actions, unless it is undefined,</code> +<br>
<code>in which case you must return the initial state, regardless of the</code> +<br>
<code>action type. The initial state may not be undefined, but can be null.</code><br>
)<br>
}<br>
})<br>
}<br>
function getUnexpectedStateShapeWarningMessage(<br>
inputState,<br>
reducers,<br>
action,<br>
unexpectedKeyCache<br>
) {<br>
// 这⾥的 reducers 已经是 finalReducers<br>
const reducerKeys = Object.keys(reducers)<br>
const argumentName =<br>
action &amp;&amp; action.type === ActionTypes.INIT<br>
? 'preloadedState argument passed to createStore'<br>
: 'previous state received by the reducer'</p>
<p>// 如果 finalReducers 为空<br>
if (reducerKeys.length === 0) {<br>
return (<br>
'Store does not have a valid reducer. Make sure the argument<br>
passed ' +<br>
'to combineReducers is an object whose values are reducers.'<br>
)<br>
}<br>
// 如果你传⼊的 state 不是对象<br>
if (!isPlainObject(inputState)) {<br>
return (<br>
<code>The ${argumentName} has unexpected type of &quot;</code> +<br>
接下来让我们先来看看 compose 函数<br>
{}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] +<br>
<code>&quot;. Expected argument to be an object with the following</code> +<br>
<code>keys: &quot;${reducerKeys.join('&quot;, &quot;')}&quot;</code><br>
)<br>
}<br>
// 将参⼊的 state 于 finalReducers 下的 key 做⽐较，过滤出多余的 key<br>
const unexpectedKeys = Object.keys(inputState).filter(<br>
key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]<br>
)<br>
unexpectedKeys.forEach(key =&gt; {<br>
unexpectedKeyCache[key] = true<br>
})<br>
if (action &amp;&amp; action.type === ActionTypes.REPLACE) return<br>
// 如果 unexpectedKeys 有值的话<br>
if (unexpectedKeys.length &gt; 0) {<br>
return (<br>
<code>Unexpected ${unexpectedKeys.length &gt; 1 ? 'keys' : 'key'}</code> +<br>
<code>&quot;${unexpectedKeys.join('&quot;, &quot;')}&quot; found in ${argumentName}.</code> +<br>
<code>Expected to find one of the known reducer keys instead:</code> +<br>
<code>&quot;${reducerKeys.join('&quot;, &quot;')}&quot;. Unexpected keys will be ignored.</code><br>
)<br>
}<br>
}<br>
// 这个函数设计的很巧妙，通过传⼊函数引⽤的⽅式让我们完成多个函数的嵌套使⽤，术语叫做<br>
⾼阶函数<br>
// 通过使⽤ reduce 函数做到从右⾄左调⽤函数<br>
// 对于上⾯项⽬中的例⼦<br>
compose(<br>
applyMiddleware(thunkMiddleware),<br>
然后我们来解析 createStore 函数的部分代码<br>
window.devToolsExtension ? window.devToolsExtension() : f =&gt; f<br>
)<br>
// 经过 compose 函数变成了 applyMiddleware(thunkMiddleware)<br>
(window.devToolsExtension()())<br>
// 所以在找不到 window.devToolsExtension 时你应该返回⼀个函数<br>
export default function compose(...funcs) {<br>
if (funcs.length === 0) {<br>
return arg =&gt; arg<br>
}<br>
if (funcs.length === 1) {<br>
return funcs[0]<br>
}<br>
return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))<br>
}<br>
export default function createStore(reducer, preloadedState, enhancer) {<br>
// ⼀般 preloadedState ⽤的少，判断类型，如果第⼆个参数是函数且没有第三个参数，<br>
就调换位置<br>
if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer ===<br>
'undefined') {<br>
enhancer = preloadedState<br>
preloadedState = undefined<br>
}<br>
// 判断 enhancer 是否是函数<br>
if (typeof enhancer !== 'undefined') {<br>
if (typeof enhancer !== 'function') {<br>
throw new Error('Expected the enhancer to be a function.')<br>
}<br>
// 类型没错的话，先执⾏ enhancer，然后再执⾏ createStore 函数<br>
return enhancer(createStore)(reducer, preloadedState)<br>
}<br>
接下来先来介绍 applyMiddleware 函数<br>
在这之前我需要先来介绍⼀下函数柯⾥化，柯⾥化是⼀种将使⽤多个参数的⼀个函数转换成<br>
⼀系列使⽤⼀个参数的函数的技术。<br>
// 判断 reducer 是否是函数<br>
if (typeof reducer !== 'function') {<br>
throw new Error('Expected the reducer to be a function.')<br>
}<br>
// 当前 reducer<br>
let currentReducer = reducer<br>
// 当前状态<br>
let currentState = preloadedState<br>
// 当前监听函数数组<br>
let currentListeners = []<br>
// 这是⼀个很重要的设计，为的就是每次在遍历监听器的时候保证 currentListeners 数<br>
组不变<br>
// 可以考虑下只存在 currentListeners 的情况，如果我在某个 subscribe 中再次执<br>
⾏ subscribe<br>
// 或者 unsubscribe，这样会导致当前的 currentListeners 数组⼤⼩发⽣改变，从⽽<br>
可能导致<br>
// 索引出错<br>
let nextListeners = currentListeners<br>
// reducer 是否正在执⾏<br>
let isDispatching = false<br>
// 如果 currentListeners 和 nextListeners 相同，就赋值回去<br>
function ensureCanMutateNextListeners() {<br>
if (nextListeners === currentListeners) {<br>
nextListeners = currentListeners.slice()<br>
}<br>
}<br>
// ......<br>
}<br>
function add(a,b) { return a + b }<br>
add(1, 2) =&gt; 3<br>
// 对于以上函数如果使⽤柯⾥化可以这样改造<br>
function add(a) {<br>
return b =&gt; {<br>
return a + b<br>
}<br>
}<br>
add(1)(2) =&gt; 3<br>
// 你可以这样理解函数柯⾥化，通过闭包保存了外部的⼀个变量，然后返回⼀个接收参数的函<br>
数，在该函数中使⽤了保存的变量，然后再返回值。<br>
// 这个函数应该是整个源码中最难理解的⼀块了<br>
// 该函数返回⼀个柯⾥化的函数<br>
// 所以调⽤这个函数应该这样写 applyMiddleware(...middlewares)(createStore)<br>
(...args)<br>
export default function applyMiddleware(...middlewares) {<br>
return createStore =&gt; (...args) =&gt; {<br>
// 这⾥执⾏ createStore 函数，把 applyMiddleware 函数最后次调⽤的参数传进来<br>
const store = createStore(...args)<br>
let dispatch = () =&gt; {<br>
throw new Error(<br>
<code>Dispatching while constructing your middleware is not allowed.</code> +<br>
<code>Other middleware would not be applied to this dispatch.</code><br>
)<br>
}<br>
let chain = []<br>
// 每个中间件都应该有这两个函数<br>
const middlewareAPI = {<br>
getState: store.getState,<br>
dispatch: (...args) =&gt; dispatch(...args)<br>
}<br>
// 把 middlewares 中的每个中间件都传⼊ middlewareAPI<br>
chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))<br>
好了，我们现在将困难的部分都攻克了，来看⼀些简单的代码<br>
// 和之前⼀样，从右⾄左调⽤每个中间件，然后传⼊ store.dispatch<br>
dispatch = compose(...chain)(store.dispatch)<br>
// 这⾥只看这部分代码有点抽象，我这⾥放⼊ redux-thunk 的代码来结合分析<br>
// createThunkMiddleware返回了3层函数，第⼀层函数接收 middlewareAPI 参数<br>
// 第⼆次函数接收 store.dispatch<br>
// 第三层函数接收 dispatch 中的参数<br>
{function createThunkMiddleware(extraArgument) {<br>
return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {<br>
// 判断 dispatch 中的参数是否为函数<br>
if (typeof action === 'function') {<br>
// 是函数的话再把这些参数传进去，直到 action 不为函数，执⾏ dispatch({tyep:<br>
'XXX'})<br>
return action(dispatch, getState, extraArgument);<br>
}<br>
return next(action);<br>
};<br>
}<br>
const thunk = createThunkMiddleware();<br>
export default thunk;}<br>
// 最后把经过中间件加强后的 dispatch 于剩余 store 中的属性返回，这样你的<br>
dispatch<br>
return {<br>
...store,<br>
dispatch<br>
}<br>
}<br>
}<br>
// 这个没啥好说的，就是把当前的 state 返回，但是当正在执⾏ reducer 时不能执⾏该⽅<br>
法<br>
function getState() {<br>
if (isDispatching) {<br>
throw new Error(<br>
'You may not call store.getState() while the reducer is<br>
executing. ' +<br>
'The reducer has already received the state as an argument. '<br>
+<br>
'Pass it down from the top reducer instead of reading it from<br>
the store.'<br>
)<br>
}<br>
return currentState<br>
}<br>
// 接收⼀个函数参数<br>
function subscribe(listener) {<br>
if (typeof listener !== 'function') {<br>
throw new Error('Expected listener to be a function.')<br>
}<br>
// 这部分最主要的设计 nextListeners 已经讲过，其他基本没什么好说的<br>
if (isDispatching) {<br>
throw new Error(<br>
'You may not call store.subscribe() while the reducer is<br>
executing. ' +<br>
'If you would like to be notified after the store has been<br>
updated, subscribe from a ' +<br>
'component and invoke store.getState() in the callback to<br>
access the latest state. ' +<br>
'See http://redux.js.org/docs/api/Store.html#subscribe for<br>
more details.'<br>
)<br>
}<br>
let isSubscribed = true<br>
ensureCanMutateNextListeners()<br>
nextListeners.push(listener)<br>
// 返回⼀个取消订阅函数<br>
return function unsubscribe() {<br>
if (!isSubscribed) {<br>
return<br>
}<br>
if (isDispatching) {<br>
throw new Error(<br>
'You may not unsubscribe from a store listener while the<br>
reducer is executing. ' +<br>
'See http://redux.js.org/docs/api/Store.html#subscribe for<br>
more details.'<br>
)<br>
}<br>
isSubscribed = false<br>
ensureCanMutateNextListeners()<br>
const index = nextListeners.indexOf(listener)<br>
nextListeners.splice(index, 1)<br>
}<br>
}<br>
function dispatch(action) {<br>
// 原⽣的 dispatch 会判断 action 是否为对象<br>
if (!isPlainObject(action)) {<br>
throw new Error(<br>
'Actions must be plain objects. ' +<br>
'Use custom middleware for async actions.'<br>
)<br>
}<br>
if (typeof action.type === 'undefined') {<br>
throw new Error(<br>
'Actions may not have an undefined &quot;type&quot; property. ' +<br>
安全章节<br>
'Have you misspelled a constant?'<br>
)<br>
}<br>
// 注意在 Reducers 中是不能执⾏ dispatch 函数的<br>
// 因为你⼀旦在 reducer 函数中执⾏ dispatch，会引发死循环<br>
if (isDispatching) {<br>
throw new Error('Reducers may not dispatch actions.')<br>
}<br>
// 执⾏ combineReducers 组合后的函数<br>
try {<br>
isDispatching = true<br>
currentState = currentReducer(currentState, action)<br>
} finally {<br>
isDispatching = false<br>
}<br>
// 然后遍历 currentListeners，执⾏数组中保存的函数<br>
const listeners = (currentListeners = nextListeners)<br>
for (let i = 0; i &lt; listeners.length; i++) {<br>
const listener = listeners[i]<br>
listener()<br>
}<br>
return action<br>
}<br>
// 然后在 createStore 末尾会发起⼀个 action dispatch({ type:<br>
ActionTypes.INIT });<br>
// ⽤以初始化 state<br>
XSS<br>
跨⽹站指令码（英语：Cross-site scripting，通常简称为：XSS）是⼀种⽹站应⽤程<br>
式的安全漏洞攻击，是代码注⼊的⼀种。它允许恶意使⽤者将程式码注⼊到⽹⻚上，<br>
其他使⽤者在观看⽹⻚时就会受到影响。这类攻击通常包含了 HTML 以及使⽤者端<br>
脚本语⾔。<br>
XSS 分为三种：反射型，存储型和 DOM-based<br>
如何攻击<br>
XSS 通过修改 HTML 节点或者执⾏ JS 代码来攻击⽹站。<br>
例如通过 URL 获取某些参数<br>
上述 URL 输⼊可能会将 HTML 改为 <div><script>alert(1)</script></div> ，这样⻚<br>
⾯中就凭空多了⼀段可执⾏脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻<br>
击。<br>
也有另⼀种场景，⽐如写了⼀篇包含攻击代码 <script>alert(1)</script> 的⽂章，那么<br>
可能浏览⽂章的⽤户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based<br>
攻击，并且这种攻击打击⾯更⼴。<br>
如何防御<br>
最普遍的做法是转义输⼊输出的内容，对于引号，尖括号，斜杠进⾏转义</p>
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>
通过转义可以将攻击代码 <script>alert(1)</script> 变成
对于显示富⽂本来说，不能通过上⾯的办法来转义所有字符，因为这样会把需要的格式也过
滤掉。这种情况通常采⽤⽩名单过滤的办法，当然也可以通过⿊名单过滤，但是考虑到需要
过滤的标签和标签属性实在太多，更加推荐使⽤⽩名单的⽅式。
以上示例使⽤了 js-xss 来实现。可以看到在输出中保留了 h1 标签且过滤了 script 标
签
CSP
内容安全策略 (CSP) 是⼀个额外的安全层，⽤于检测并削弱某些特定类型的攻击，
包括跨站脚本 (XSS) 和数据注⼊攻击等。⽆论是数据盗取、⽹站内容污染还是散发恶
意软件，这些攻击都是主要的⼿段。
function escape(str) {
 str = str.replace(/&/g, "&amp;");
 str = str.replace(/</g, "&lt;");
 str = str.replace(/>/g, "&gt;");
 str = str.replace(/"/g, "&quto;");
 str = str.replace(/'/g, "&#39;");
 str = str.replace(/`/g, "&#96;");
 str = str.replace(/\//g, "&#x2F;");
 return str
}
// -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt;
escape('<script>alert(1)</script>')
var xss = require("xss");
var html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");
</script>');
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html);
我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建⽴⽩名单，规定了浏览器只能
够执⾏特定来源的代码。
通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP
只允许加载本站资源
只允许加载 HTTPS 协议图⽚
允许加载任何来源框架
更多属性可以查看 这⾥
CSRF
跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或
者 session riding，通常缩写为 CSRF 或者 XSRF， 是⼀种挟制⽤户在当前已登录
的Web应⽤程序上执⾏⾮本意的操作的攻击⽅法。[1] 跟跨網站指令碼（XSS）相
⽐，XSS 利⽤的是⽤户对指定⽹站的信任，CSRF 利⽤的是⽹站对⽤户⽹⻚浏览器
的信任。
简单点说，CSRF 就是利⽤⽤户的登录态发起恶意请求。
如何攻击
假设⽹站中有⼀个通过 Get 请求提交⽤户评论的接⼝，那么攻击者就可以在钓⻥⽹站中加⼊
⼀个图⽚，图⽚的地址就是评论接⼝
Content-Security-Policy: default-src ‘self’
Content-Security-Policy: img-src https://*
Content-Security-Policy: child-src 'none'
<img src="http://www.domain.com/xxx?comment='attack'"/>
如果接⼝是 Post 提交的，就相对麻烦点，需要⽤表单来提交接⼝
如何防御
防范 CSRF 可以遵循以下⼏种规则：
1. Get 请求不对数据进⾏修改
2. 不让第三⽅⽹站访问到⽤户 Cookie
3. 阻⽌第三⽅⽹站请求接⼝
4. 请求时附带验证信息，⽐如验证码或者 token
SameSite
可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以
很⼤程度减少 CSRF 的攻击，但是该属性⽬前并不是所有浏览器都兼容。
验证 Referer
对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三⽅⽹站发
起的。
Token
服务器下发⼀个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验
证 Token 是否有效。
密码安全
密码安全虽然⼤多是后端的事情，但是作为⼀名优秀的前端程序员也需要熟悉这⽅⾯的知
识。
<form action="http://www.domain.com/xxx" id="CSRF" method="post">
 <input name="comment" value="attack" type="hidden">
</form>
加盐
对于密码存储来说，必然是不能明⽂存储在数据库中的，否则⼀旦数据库泄露，会对⽤户造
成很⼤的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。
通常需要对密码加盐，然后进⾏⼏次不同加密算法的加密。
但是加盐并不能阻⽌别⼈盗取账号，只能确保即使数据库泄露，也不会暴露⽤户的真实密
码。⼀旦攻击者得到了⽤户的账号，可以通过暴⼒破解的⽅式破解密码。对于这种情况，通
常使⽤验证码增加延时或者限制尝试次数的⽅式。并且⼀旦⽤户输⼊了错误的密码，也不能
直接提示⽤户输错密码，⽽应该提示账号或密码错误。
⽹络章节
UDP
⾯向报⽂
UDP 是⼀个⾯向报⽂（报⽂可以理解为⼀段段的数据）的协议。意思就是 UDP 只是报⽂的
搬运⼯，不会对报⽂进⾏任何拆分和拼接操作。
具体来说
在发送端，应⽤层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加⼀个 UDP 头
标识下是 UDP 协议，然后就传递给⽹络层了
在接收端，⽹络层将数据传递给传输层，UDP 只去除 IP 报⽂头就传递给应⽤层，不会任
何拼接操作
// 加盐也就是给原密码添加字符串，增加原密码⻓度
sha256(sha1(md5(salt + password + salt)))
不可靠性
1. UDP 是⽆连接的，也就是说通信不需要建⽴和断开连接。
2. UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对⽅能
不能收到是不关⼼的
3. UDP 没有拥塞控制，⼀直会以恒定的速度发送数据。即使⽹络条件不好，也不会对发送
速率进⾏调整。这样实现的弊端就是在⽹络条件不好的情况下可能会导致丢包，但是优点
也很明显，在某些实时性要求⾼的场景（⽐如电话会议）就需要使⽤ UDP ⽽不是 TCP。
⾼效
因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销⼩，
只有⼋字节，相⽐ TCP 的⾄少⼆⼗字节要少得多，在传输数据报⽂时是很⾼效的。
头部包含了以下⼏个数据
两个⼗六位的端⼝号，分别为源端⼝（可选字段）和⽬标端⼝
整个数据报⽂的⻓度
整个数据报⽂的检验和（IPv4 可选 字段），该字段⽤于发现头部信息和数据中的错误
传输⽅式
UDP 不⽌⽀持⼀对⼀的传输⽅式，同样⽀持⼀对多，多对多，多对⼀的⽅式，也就是说 UDP
提供了单播，多播，⼴播的功能。
TCP
头部
TCP 头部⽐ UDP 头部复杂的多
对于 TCP 头部来说，以下⼏个字段是很重要的
Sequence number，这个序号保证了 TCP 传输的报⽂都是有序的，对端可以通过序号顺
序的拼接报⽂
Acknowledgement Number，这个序号表示数据接收端期望接收的下⼀个字节的编号是
多少，同时也表示上⼀个序号的数据已经收到
Window Size，窗⼝⼤⼩，表示还能接收多少字节的数据，⽤于流量控制
标识符
URG=1：该字段为⼀表示本数据报的数据部分包含紧急信息，是⼀个⾼优先级数据
报⽂，此时紧急指针有效。紧急数据⼀定位于当前数据包数据部分的最前⾯，紧急指
针标明了紧急数据的尾部。
ACK=1：该字段为⼀表示确认号字段有效。此外，TCP 还规定在连接建⽴后传送的
所有报⽂段都必须把 ACK 置为⼀。
PSH=1：该字段为⼀表示接收端应该⽴即将数据 push 给应⽤层，⽽不是等到缓冲区
满后再提交。
RST=1：该字段为⼀表示当前 TCP 连接出现严重问题，可能需要重新建⽴ TCP 连
接，也可以⽤于拒绝⾮法的报⽂段和拒绝连接请求。
SYN=1：当SYN=1，ACK=0时，表示当前报⽂段是⼀个连接请求报⽂。当SYN=1，
ACK=1时，表示当前报⽂段是⼀个同意建⽴连接的应答报⽂。
FIN=1：该字段为⼀表示此报⽂段是⼀个释放连接的请求报⽂。
状态机
HTTP 是⽆连接的，所以作为下层的 TCP 协议也是⽆连接的，虽然看似 TCP 将两端连接了起
来，但是其实只是两端共同维护了⼀个状态
TCP 的状态机是很复杂的，并且与建⽴断开连接时的握⼿息息相关，接下来就来详细描述下
两种握⼿。
在这之前需要了解⼀个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据
所需的往返时间。
建⽴连接三次握⼿
在 TCP 协议中，主动发起请求的⼀端为客户端，被动连接的⼀端称为服务端。不管是客户端
还是服务端，TCP 连接建⽴完后都能发送和接收数据，所以 TCP 也是⼀个全双⼯的协议。
起初，两端都为 CLOSED 状态。在通信开始前，双⽅都会创建 TCB。 服务器创建完 TCB 后
遍进⼊ LISTEN 状态，此时开始等待客户端发送数据。
第⼀次握⼿
客户端向服务端发送连接请求报⽂段。该报⽂段中包含⾃身的数据通讯初始序号。请求发送
后，客户端便进⼊ SYN-SENT 状态， x 表示客户端的数据通信初始序号。
第⼆次握⼿
服务端收到连接请求报⽂段后，如果同意连接，则会发送⼀个应答，该应答中也会包含⾃身
的数据通讯初始序号，发送完成后便进⼊ SYN-RECEIVED 状态。
第三次握⼿
当客户端收到连接同意的应答后，还要向服务端发送⼀个确认报⽂。客户端发完这个报⽂段
后便进⼊ESTABLISHED 状态，服务端收到这个应答后也进⼊ ESTABLISHED 状态，此时连
接建⽴成功。
PS：第三次握⼿可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握⼿的协
议，都可以使⽤类似 TFO 的⽅式，客户端和服务端存储相同 cookie，下次握⼿时发出
cookie 达到减少 RTT 的⽬的。
你是否有疑惑明明两次握⼿就可以建⽴起连接，为什么还需要第三次应答？
因为这是为了防⽌失效的连接请求报⽂段被服务端接收，从⽽产⽣错误。
可以想象如下场景。客户端发送了⼀个连接请求 A，但是因为⽹络原因造成了超时，这时
TCP 会启动超时重传的机制再次发送⼀个连接请求 B。此时请求顺利到达服务端，服务端应
答完就建⽴了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认
为客户端⼜需要建⽴ TCP 连接，从⽽应答了该请求并进⼊ ESTABLISHED 状态。此时客户端
其实是 CLOSED 状态，那么就会导致服务端⼀直等待，造成资源的浪费。
PS：在建⽴连接中，任意⼀端掉线，TCP 都会重发 SYN 包，⼀般会重试五次，在建⽴连接
中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者⼲脆在不能处
理的情况下拒绝请求。
断开链接四次握⼿
TCP 是全双⼯的，在断开连接时两端都需要发送 FIN 和 ACK。
第⼀次握⼿
若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。
第⼆次握⼿
B 收到连接释放请求后，会告诉应⽤层要释放 TCP 链接。然后会发送 ACK 包，并进⼊
CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连
接时双向的，所以 B 仍旧可以发送数据给 A。
第三次握⼿
B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进⼊
LAST-ACK 状态。
PS：通过延迟确认的技术（通常有时间限制，否则对⽅会误认为需要重传），可以将第⼆次
和第三次握⼿合并，延迟 ACK 包的发送。
第四次握⼿
A 收到释放请求后，向 B 发送确认应答，此时 A 进⼊ TIME-WAIT 状态。该状态会持续
2MSL（最⼤段⽣存期，指报⽂段在⽹络中⽣存的时间，超时会被抛弃） 时间，若该时间段
内没有 B 的重发请求的话，就进⼊ CLOSED 状态。当 B 收到确认应答后，也便进⼊
CLOSED 状态。
为什么 A 要进⼊ TIME-WAIT 状态，等待 2MSL 时间后才进⼊ CLOSED 状态？
为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进⼊ CLOSED 状态，如果确认
应答因为⽹络问题⼀直没有到达，那么会造成 B 不能正常关闭。
ARQ 协议
ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含
停⽌等待 ARQ 和连续 ARQ
停⽌等待 ARQ
正常传输过程
只要 A 向 B 发送⼀段报⽂，都要停⽌发送并启动⼀个定时器，等待对端回应，在定时器时间
内接收到对端应答就取消定时器并发送下⼀段报⽂。
报⽂丢失或出错
在报⽂传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数
据直到对端响应，所以需要每次都备份发送的数据。
即使报⽂正常的传输到对端，也可能出现在传输过程中报⽂出错的问题。这时候对端会抛弃
该报⽂并等待 A 端重传。
PS：⼀般定时器设定的时间都会⼤于⼀个 RTT 的平均时间。
ACK 超时或丢失
对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报⽂。
这时候 B 端收到相同序号的报⽂会丢弃该报⽂并重传应答，直到 A 端发送下⼀个序号的报
⽂。
在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接
收过只需要丢弃应答即可。
这个协议的缺点就是传输效率低，在良好的⽹络环境下每次发送报⽂都得等待对端的 ACK 。
连续 ARQ
在连续 ARQ 中，发送端拥有⼀个发送窗⼝，可以在没有收到应答的情况下持续发送窗⼝内的
数据，这样相⽐停⽌等待 ARQ 协议来说减少了等待时间，提⾼了效率。
累计确认
连续 ARQ 中，接收端会持续不断收到报⽂。如果和停⽌等待 ARQ 中接收⼀个报⽂就发送⼀
个应答⼀样，就太浪费资源了。通过累计确认，可以在收到多个报⽂以后统⼀回复⼀个应答
报⽂。报⽂中的 ACK 可以⽤来告诉发送端这个序号之前的数据已经全部接收到了，下次请发
送这个序号 + 1的数据。
但是累计确认也有⼀个弊端。在连续接收报⽂时，可能会遇到接收到序号 5 的报⽂后，并未
接到序号 6 的报⽂，然⽽序号 7 以后的报⽂已经接收。遇到这种情况时，ACK 只能回复 6，
这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下⽂说到。
滑动窗⼝
在上⾯⼩节中讲到了发送窗⼝。在 TCP 中，两端都维护着窗⼝：分别为发送端窗⼝和接收端
窗⼝。
发送端窗⼝包含已发送但未收到应答的数据和可以发送但是未发送的数据。
发送端窗⼝是由接收窗⼝剩余⼤⼩决定的。接收⽅会把当前接收窗⼝的剩余⼤⼩写⼊应答报
⽂，发送端收到应答后根据该值和当前⽹络拥塞情况设置发送窗⼝的⼤⼩，所以发送窗⼝的
⼤⼩是不断变化的。
当发送端接收到应答报⽂后，会随之将窗⼝进⾏滑动
滑动窗⼝实现了流量控制。接收⽅通过报⽂告知发送⽅还可以发送多少数据，从⽽保证接收
⽅能够来得及接收数据。
Zero 窗⼝
在发送报⽂的过程中，可能会遇到对端出现零窗⼝的情况。在该情况下，发送端会停⽌发送
数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗⼝⼤⼩。在
重试次数超过⼀定次数后，可能会中断 TCP 链接。
拥塞处理
拥塞处理和流量控制不同，后者是作⽤于接收⽅，保证接收⽅来得及接受数据。⽽前者是作
⽤于⽹络，防⽌过多的数据拥塞⽹络，避免出现⽹络负载过⼤的情况。
拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。
慢开始算法
慢开始算法，顾名思义，就是在传输开始时将发送窗⼝慢慢指数级扩⼤，从⽽避免⼀开始就
传输⼤量数据导致⽹络拥塞。
慢开始算法步骤具体如下
1. 连接初始设置拥塞窗⼝（Congestion Window） 为 1 MSS（⼀个分段的最⼤数据量）
2. 每过⼀个 RTT 就将窗⼝⼤⼩乘⼆
3. 指数级增⻓肯定不能没有限制的，所以有⼀个阈值限制，当窗⼝⼤⼩⼤于阈值时就会启动
拥塞避免算法。
拥塞避免算法
拥塞避免算法相⽐简单点，每过⼀个 RTT 窗⼝⼤⼩只加⼀，这样能够避免指数级增⻓导致⽹
络拥塞，慢慢将⼤⼩调整到最佳值。
在传输过程中可能定时器超时的情况，这时候 TCP 会认为⽹络拥塞了，会⻢上进⾏以下步
骤：
将阈值设为当前拥塞窗⼝的⼀半
将拥塞窗⼝设为 1 MSS
启动拥塞避免算法
快速重传
快速重传⼀般和快恢复⼀起出现。⼀旦接收端收到的报⽂出现失序的情况，接收端只会回复
最后⼀个顺序正确的报⽂序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，⽆需等
待定时器超时再重发⽽是启动快速重传。具体算法分为两种：
TCP Taho 实现如下
将阈值设为当前拥塞窗⼝的⼀半
将拥塞窗⼝设为 1 MSS
重新开始慢开始算法
TCP Reno 实现如下
拥塞窗⼝减半
将阈值设为当前拥塞窗⼝
进⼊快恢复阶段（重发对端需要的包，⼀旦收到⼀个新的 ACK 答复就退出该阶段）
使⽤拥塞避免算法
TCP New Ren 改进后的快恢复
TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到⼀个新
的 ACK 包，就会退出快恢复。
在 TCP New Reno 中，TCP 发送⽅先记下三个重复 ACK 的分段的最⼤序号。
假如我有⼀个分段数据是 1 ~ 10 这⼗个序号的报⽂，其中丢失了序号为 3 和 7 的报⽂，那么
该分段的最⼤序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的
报⽂，接收⽅顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未
收到，会继续发送序号为 7 的报⽂，接收⽅顺利接收并会发送 ACK 序号为 11 的应答，这时
发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。
HTTP
HTTP 协议是个⽆状态协议，不会保存状态。
Post 和 Get 的区别
先引⼊副作⽤和幂等的概念。
副作⽤指对服务器上的资源做改变，搜索是⽆副作⽤的，注册是副作⽤的。
幂等指发送 M 和 N 次请求（两者不相同且都⼤于 1），服务器上资源的状态⼀致，⽐如注册
10 个和 11 个帐号是不幂等的，对⽂章进⾏更改 10 次和 11 次是幂等的。
在规范的应⽤场景上说，Get 多⽤于⽆副作⽤，幂等的场景，例如搜索关键字。Post 多⽤于
副作⽤，不幂等的场景，例如注册。
在技术上说：
Get 请求能缓存，Post 不能
Post 相对 Get 安全⼀点点，因为Get 请求都包含在 URL ⾥，且会被浏览器保存历史纪
录，Post 不会，但是在抓包的情况下都是⼀样的。
Post 可以通过 request body来传输⽐ Get 更多的数据，Get 没有这个技术
URL有⻓度限制，会影响 Get 请求，但是这个⻓度限制是浏览器规定的，不是 RFC 规定
的
Post ⽀持更多的编码类型且不对数据类型限制
常⻅状态码
2XX 成功
200 OK，表示从客户端发来的请求在服务器端被正确处理
204 No content，表示请求成功，但响应报⽂不含实体的主体部分
205 Reset Content，表示请求成功，但响应报⽂不含实体的主体部分，但是与 204 响应
不同在于要求请求⽅重置内容
206 Partial Content，进⾏范围请求
3XX 重定向
301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
302 found，临时性重定向，表示资源临时被分配了新的 URL
303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法获取资源
304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况
307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求⽅法不
变向新的地址发出请求
4XX 客户端错误
通⽤字段 作⽤
Cache-Control 控制缓存的⾏为
Connection 浏览器想要优先使⽤的连接类型，⽐如 keep-alive
Date 创建报⽂时间
Pragma 报⽂指令
Via 代理服务器相关信息
Transfer-Encoding 传输编码⽅式
Upgrade 要求客户端升级协议
Warning 在内容中可能存在错误
400 bad request，请求报⽂存在语法错误
401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
403 forbidden，表示对请求资源的访问被服务器拒绝
404 not found，表示在服务器上没有找到请求的资源
5XX 服务器错误
500 internal sever error，表示服务器端在执⾏请求时发⽣了错误
501 Not Implemented，表示服务器不⽀持当前请求所需要的某个功能
503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求
HTTP ⾸部
请求字段 作⽤
Accept 能正确接收的媒体类型
Accept-Charset 能正确接收的字符集
Accept-Encoding 能正确接收的编码格式列表
Accept-Language 能正确接收的语⾔列表
Expect 期待服务端的指定⾏为
From 请求⽅邮箱地址
Host 服务器的域名
If-Match 两端资源标记⽐较
If-Modified-Since 本地资源未修改返回 304（⽐较时间）
If-None-Match 本地资源未修改返回 304（⽐较标记）
User-Agent 客户端信息
Max-Forwards 限制可被代理及⽹关转发的次数
Proxy-Authorization 向代理服务器发送验证信息
Range 请求某个内容的⼀部分
Referer 表示浏览器所访问的前⼀个⻚⾯
TE 传输编码⽅式
响应字段 作⽤
Accept-Ranges 是否⽀持某些种类的范围
Age 资源在代理缓存中存在的时间
ETag 资源标识
Location 客户端重定向到某个 URL
Proxy-Authenticate 向代理服务器发送验证信息
Server 服务器名字
WWW-Authenticate 获取资源需要的验证信息
实体字段 作⽤
Allow 资源的正确请求⽅式
Content-Encoding 内容的编码格式
Content-Language 内容使⽤的语⾔
Content-Length request body ⻓度
Content-Location 返回数据的备⽤地址
Content-MD5 Base64加密格式的内容 MD5检验值
Content-Range 内容的位置范围
Content-Type 内容的媒体类型
Expires 内容的过期时间
Last_modified 内容的最后修改时间
PS：缓存相关已在别的模块中写完，你可以 阅读该⼩节
HTTPS
HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进⾏了加密。
TLS
TLS 协议位于传输层之上，应⽤层之下。⾸次进⾏ TLS 协议传输需要两个 RTT ，接下来可以
通过 Session Resumption 减少到⼀个 RTT。
在 TLS 中使⽤了两种加密技术，分别为：对称加密和⾮对称加密。
对称加密：
对称加密就是两边拥有相同的秘钥，两边都知道如何将密⽂加密解密。
⾮对称加密：
有公钥私钥之分，公钥所有⼈都可以知道，可以将数据⽤公钥加密，但是将数据解密必须使
⽤私钥解密，私钥只有分发公钥的⼀⽅才知道。
TLS 握⼿过程如下图：
1. 客户端发送⼀个随机值，需要的协议和加密⽅式
2. 服务端收到客户端的随机值，⾃⼰也产⽣⼀个随机值，并根据客户端需求的协议和加密⽅
式来使⽤对应的⽅式，发送⾃⼰的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，验证通过会再⽣成⼀个随机值，通过服务端证
书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带
证书
4. 服务端收到加密过的随机值并使⽤私钥解密获得第三个随机值，这时候两端都拥有了三个
随机值，可以通过这三个随机值按照之前约定的加密⽅式⽣成密钥，接下来的通信就可以
通过该密钥来加密解密
通过以上步骤可知，在 TLS 握⼿阶段，两端使⽤⾮对称加密的⽅式来通信，但是因为⾮对称
加密损耗的性能⽐对称加密⼤，所以在正式传输数据时，两端使⽤对称加密的⽅式通信。
PS：以上说明的都是 TLS 1.2 协议的握⼿情况，在 1.3 协议中，⾸次建⽴连接只需要⼀个
RTT，后⾯恢复连接不需要 RTT 了。
HTTP 2.0
HTTP 2.0 相⽐于 HTTP 1.X，可以说是⼤幅度提⾼了 web 的性能。
在 HTTP 1.X 中，为了性能考虑，我们会引⼊雪碧图、将⼩图内联、使⽤多个域名等等的⽅
式。这⼀切都是因为浏览器限制了同⼀个域名下的请求数量，当⻚⾯中需要请求很多资源的
时候，队头阻塞（Head of line blocking）会导致在达到最⼤请求数量时，剩余的资源需要等
待其他资源请求完成后才能发起请求。
你可以通过 该链接 感受下 HTTP 2.0 ⽐ HTTP 1.X 到底快了多少。
在 HTTP 1.X 中，因为队头阻塞的原因，你会发现请求是这样的
在 HTTP 2.0 中，因为引⼊了多路复⽤，你会发现请求是这样的
⼆进制传输
HTTP 2.0 中所有加强性能的核⼼点在于此。在之前的 HTTP 版本中，我们是通过⽂本的⽅式
传输数据。在 HTTP 2.0 中引⼊了新的编码机制，所有传输的数据都会被分割，并采⽤⼆进制
格式编码。
多路复⽤
在 HTTP 2.0 中，有两个⾮常重要的概念，分别是帧（frame）和流（stream）。
帧代表着最⼩的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据
流。
多路复⽤，就是在⼀个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，
对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队
头阻塞问题，极⼤的提⾼传输性能。
Header 压缩
在 HTTP 1.X 中，我们使⽤⽂本的形式传输 header，在 header 携带 cookie 的情况下，可能
每次都需要重复传输⼏百到⼏千的字节。
在 HTTP 2.0 中，使⽤了 HPACK 压缩格式对传输的 header 进⾏编码，减少了 header 的⼤
⼩。并在两端维护了索引表，⽤于记录出现过的 header ，后⾯在传输过程中就可以传输已经
记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
服务端 Push
在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。
可以想象以下情况，某些资源客户端是⼀定会请求的，这时就可以采取服务端 push 的技术，
提前给客户端推送必要的资源，这样就可以相对减少⼀点延迟时间。当然在浏览器兼容的情
况下你也可以使⽤ prefetch 。
QUIC
这是⼀个⾕歌出品的基于 UDP 实现的同为传输层的协议，⽬标很远⼤，希望替代 TCP 协
议。
该协议⽀持多路复⽤，虽然 HTTP 2.0 也⽀持多路复⽤，但是下层仍是 TCP，因为 TCP
的重传机制，只要⼀个包丢失就得判断丢失包并且重传，导致发⽣队头阻塞的问题，但是
UDP 没有这个机制
实现了⾃⼰的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已
经实现了 0-RTT 了
⽀持重传和纠错机制（向前恢复），在只丢失⼀个包的情况下不需要重传，使⽤纠错机制
恢复丢失的包
纠错机制：通过异或的⽅式，算出发出去的数据的异或值并单独发出⼀个包，服务端
在发现有⼀个包丢失的情况下，通过其他数据包和异或值包算出丢失包
在丢失两个包或以上的情况就使⽤重传机制，因为算不出来了
DNS
DNS 的作⽤就是通过域名查询到具体的 IP。
因为 IP 存在数字和英⽂的组合（IPv6），很不利于⼈类记忆，所以就出现了域名。你可以把
域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。
在 TCP 握⼿之前就已经进⾏了 DNS 查询，这个查询是操作系统⾃⼰做的。当你在浏览器中
想访问 www.google.com 时，会进⾏⼀下操作：
1. 操作系统会⾸先在本地缓存中查询
2. 没有的话会去系统配置的 DNS 服务器中查询
3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这⼀步查询会找出负责 com 这个
⼀级域名的服务器
4. 然后去该服务器查询 google 这个⼆级域名
5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置⼀个 IP，然后还
可以给别的三级域名配置⼀个 IP
以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者
是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。
PS：DNS 是基于 UDP 做的查询。
从输⼊ URL 到⻚⾯加载完成的过程
这是⼀个很经典的⾯试题，在这题中可以将本⽂讲得内容都串联起来。
1. ⾸先做 DNS 查询，如果这⼀步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址
回来
2. 接下来是 TCP 握⼿，应⽤层会下发数据给传输层，这⾥ TCP 协议会指明两端的端⼝号，
然后下发给⽹络层。⽹络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转
路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层⾯的传输了
3. TCP 握⼿结束后会进⾏ TLS 握⼿，然后就开始正式的传输数据
4. 数据在进⼊服务端之前，可能还会先经过负责负载均衡的服务器，它的作⽤就是将请求合
理的分发到多台服务器上，这时假设服务端会响应⼀个 HTML ⽂件
5. ⾸先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会
报错，如果 300 的话会进⾏重定向，这⾥会有个重定向计数器，避免过多次的重定向，
超过次数也会报错
6. 浏览器开始解析⽂件，如果是 gzip 格式的话会先解压⼀下，然后通过⽂件的编码格式知
道该如何去解码⽂件
7. ⽂件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去
构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer
，前者会并⾏进⾏下载并执⾏ JS，后者会先下载⽂件，然后等待 HTML 解析完成后顺序
执⾏，如果以上都没有，就会阻塞住渲染流程直到 JS 执⾏完毕。遇到⽂件下载的会去下
载⽂件，这⾥如果使⽤ HTTP 2.0 协议的话会极⼤的提⾼多图的下载效率。
8. 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件
9. CSSOM 树和 DOM 树构建完成后会开始⽣成 Render 树，这⼀步就是确定⻚⾯元素的布
局、样式等等诸多⽅⾯的东⻄
10. 在⽣成 Render 树的过程中，浏览器就开始调⽤ GPU 绘制，合成图层，将内容显示在屏
幕上了
数据结构章节
栈
概念
栈是⼀个线性结构，在计算机中是⼀个相当常⻅的数据结构。
栈的特点是只能在某⼀端添加或删除数据，遵循先进后出的原则
实现
每种数据结构都可以⽤很多种⽅式来实现，其实可以把栈看成是数组的⼀个⼦集，所以这⾥
使⽤数组来实现
class Stack {
 constructor() {
 this.stack = []
 }
 push(item) {
 this.stack.push(item)
 }
 pop() {
 this.stack.pop()
 }
 peek() {
 return this.stack[this.getCount() - 1]
应⽤
选取了 LeetCode 上序号为 20 的题⽬
题意是匹配括号，可以通过栈的特性来完成这道题⽬
 }
 getCount() {
 return this.stack.length
 }
 isEmpty() {
 return this.getCount() === 0
 }
}
var isValid = function (s) {
 let map = {
 '(': -1,
 ')': 1,
 '[': -2,
 ']': 2,
 '{': -3,
 '}': 3
 }
 let stack = []
 for (let i = 0; i < s.length; i++) {
 if (map[s[i]] < 0) {
 stack.push(s[i])
 } else {
 let last = stack.pop()
 if (map[last] + map[s[i]] != 0) return false
 }
 }
 if (stack.length > 0) return false
 return true
队列
概念
队列⼀个线性结构，特点是在某⼀端添加数据，在另⼀端删除数据，遵循先进先出的原则。
实现
这⾥会讲解两种实现队列的⽅式，分别是单链队列和循环队列。
单链队列
};
class Queue {
 constructor() {
 this.queue = []
 }
 enQueue(item) {
因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引⼊了循环队列。循环队列的
出队操作平均是 O(1) 的时间复杂度。
循环队列
 this.queue.push(item)
 }
 deQueue() {
 return this.queue.shift()
 }
 getHeader() {
 return this.queue[0]
 }
 getLength() {
 return this.queue.length
 }
 isEmpty() {
 return this.getLength() === 0
 }
}
class SqQueue {
 constructor(length) {
 this.queue = new Array(length + 1)
 // 队头
 this.first = 0
 // 队尾
 this.last = 0
 // 当前队列⼤⼩
 this.size = 0
 }
 enQueue(item) {
 // 判断队尾 + 1 是否为队头
 // 如果是就代表需要扩容数组
 // % this.queue.length 是为了防⽌数组越界
 if (this.first === (this.last + 1) % this.queue.length) {
 this.resize(this.getLength() * 2 + 1)
 }
 this.queue[this.last] = item
 this.size++
 this.last = (this.last + 1) % this.queue.length
 }
 deQueue() {
 if (this.isEmpty()) {
 throw Error('Queue is empty')
 }
 let r = this.queue[this.first]
 this.queue[this.first] = null
 this.first = (this.first + 1) % this.queue.length
 this.size--
 // 判断当前队列⼤⼩是否过⼩
 // 为了保证不浪费空间，在队列空间等于总⻓度四分之⼀时
 // 且不为 2 时缩⼩总⻓度为当前的⼀半
 if (this.size === this.getLength() / 4 && this.getLength() / 2 !==
0) {
 this.resize(this.getLength() / 2)
 }
 return r
 }
 getHeader() {
 if (this.isEmpty()) {
 throw Error('Queue is empty')
 }
 return this.queue[this.first]
 }
 getLength() {
 return this.queue.length - 1
 }
 isEmpty() {
 return this.first === this.last
 }
链表
概念
链表是⼀个线性结构，同时也是⼀个天然的递归结构。链表结构可以充分利⽤计算机内存空
间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了
结点的指针域，空间开销⽐较⼤。
实现
单向链表
 resize(length) {
 let q = new Array(length)
 for (let i = 0; i < length; i++) {
 q[i] = this.queue[(i + this.first) % this.queue.length]
 }
 this.queue = q
 this.first = 0
 this.last = this.size
 }
}
class Node {
 constructor(v, next) {
 this.value = v
 this.next = next
 }
}
class LinkList {
 constructor() {
 // 链表⻓度
 this.size = 0
 // 虚拟头部
 this.dummyNode = new Node(null, null)
 }
 find(header, index, currentIndex) {
 if (index === currentIndex) return header
 return this.find(header.next, index, currentIndex + 1)
 }
 addNode(v, index) {
 this.checkIndex(index)
 // 当往链表末尾插⼊时，prev.next 为空
 // 其他情况时，因为要插⼊节点，所以插⼊的节点
 // 的 next 应该是 prev.next
 // 然后设置 prev.next 为插⼊的节点
 let prev = this.find(this.dummyNode, index, 0)
 prev.next = new Node(v, prev.next)
 this.size++
 return prev.next
 }
 insertNode(v, index) {
 return this.addNode(v, index)
 }
 addToFirst(v) {
 return this.addNode(v, 0)
 }
 addToLast(v) {
 return this.addNode(v, this.size)
 }
 removeNode(index, isLast) {
 this.checkIndex(index)
 index = isLast ? index - 1 : index
 let prev = this.find(this.dummyNode, index, 0)
 let node = prev.next
 prev.next = node.next
树
⼆叉树
树拥有很多种结构，⼆叉树是树中最常⽤的结构，同时也是⼀个天然的递归结构。
⼆叉树拥有⼀个根节点，每个节点⾄多拥有两个⼦节点，分别为：左节点和右节点。树的最
底部节点称之为叶节点，当⼀颗树的叶数量数量为满时，该树可以称之为满⼆叉树。
 node.next = null
 this.size--
 return node
 }
 removeFirstNode() {
 return this.removeNode(0)
 }
 removeLastNode() {
 return this.removeNode(this.size, true)
 }
 checkIndex(index) {
 if (index < 0 || index > this.size) throw Error('Index error')
 }
 getNode(index) {
 this.checkIndex(index)
 if (this.isEmpty()) return
 return this.find(this.dummyNode, index, 0).next
 }
 isEmpty() {
 return this.size === 0
 }
 getSize() {
 return this.size
 }
}
⼆分搜索树
⼆分搜索树也是⼆叉树，拥有⼆叉树的特性。但是区别在于⼆分搜索树每个节点的值都⽐他
的左⼦树的值⼤，⽐右⼦树的值⼩。
这种存储⽅式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值⽐
根节点的值⼤，所以只需要在根节点的右⼦树上寻找，⼤⼤提⾼了搜索效率。
实现
class Node {
 constructor(value) {
 this.value = value
 this.left = null
 this.right = null
 }
}
class BST {
 constructor() {
 this.root = null
 this.size = 0
 }
 getSize() {
 return this.size
以上是最基本的⼆分搜索树实现，接下来实现树的遍历。
对于树的遍历来说，有三种遍历⽅法，分别是先序遍历、中序遍历、后序遍历。三种遍历的
区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到⾃⼰，
遍历左⼦树和遍历右⼦树。如果需要实现先序遍历，那么只需要第⼀次遍历到节点时进⾏操
作即可。
以下都是递归实现，如果你想学习⾮递归实现，可以 点击这⾥阅读
 }
 isEmpty() {
 return this.size === 0
 }
 addNode(v) {
 this.root = this._addChild(this.root, v)
 }
 // 添加节点时，需要⽐较添加的节点值和当前
 // 节点值的⼤⼩
 _addChild(node, v) {
 if (!node) {
 this.size++
 return new Node(v)
 }
 if (node.value > v) {
 node.left = this._addChild(node.left, v)
 } else if (node.value < v) {
 node.right = this._addChild(node.right, v)
 }
 return node
 }
}
// 先序遍历可⽤于打印树的结构
// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。
preTraversal() {
 this._pre(this.root)
}
_pre(node) {
 if (node) {
 console.log(node.value)
 this._pre(node.left)
 this._pre(node.right)
 }
}
// 中序遍历可⽤于排序
// 对于 BST 来说，中序遍历可以实现⼀次遍历就
// 得到有序的值
// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。
midTraversal() {
 this._mid(this.root)
}
_mid(node) {
 if (node) {
 this._mid(node.left)
 console.log(node.value)
 this._mid(node.right)
 }
}
// 后序遍历可⽤于先操作⼦节点
// 再操作⽗节点的场景
// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。
backTraversal() {
 this._back(this.root)
}
_back(node) {
 if (node) {
 this._back(node.left)
 this._back(node.right)
 console.log(node.value)
 }
}
以上的这⼏种遍历都可以称之为深度遍历，对应的还有种遍历叫做⼴度遍历，也就是⼀层层
地遍历树。对于⼴度遍历来说，我们需要利⽤之前讲过的队列结构来完成。
接下来先介绍如何在树中寻找最⼩值或最⼤数。因为⼆分搜索树的特性，所以最⼩值⼀定在
根节点的最左边，最⼤值相反
breadthTraversal() {
 if (!this.root) return null
 let q = new Queue()
 // 将根节点⼊队
 q.enQueue(this.root)
 // 循环判断队列是否为空，为空
 // 代表树遍历完毕
 while (!q.isEmpty()) {
 // 将队⾸出队，判断是否有左右⼦树
 // 有的话，就先左后右⼊队
 let n = q.deQueue()
 console.log(n.value)
 if (n.left) q.enQueue(n.left)
 if (n.right) q.enQueue(n.right)
 }
}
getMin() {
 return this._getMin(this.root).value
}
_getMin(node) {
 if (!node.left) return node
 return this._getMin(node.left)
}
getMax() {
 return this._getMax(this.root).value
}
_getMax(node) {
向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这⾥只介绍如何向下取
整。既然是向下取整，那么根据⼆分搜索树的特性，值⼀定在根节点的左侧。只需要⼀直遍
历左⼦树直到当前节点的值不再⼤于等于需要的值，然后判断节点是否还拥有右⼦树。如果
有的话，继续上⾯的递归判断。
排名，这是⽤于获取给定值的排名或者排名第⼏的节点的值，这两个操作也是相反的，所以
这个只介绍如何获取排名第⼏的节点的值。对于这个操作⽽⾔，我们需要略微的改造点代
码，让每个节点拥有⼀个 size 属性。该属性表示该节点下有多少⼦节点（包含⾃身）。
 if (!node.right) return node
 return this._getMin(node.right)
}
floor(v) {
 let node = this._floor(this.root, v)
 return node ? node.value : null
}
_floor(node, v) {
 if (!node) return null
 if (node.value === v) return v
 // 如果当前节点值还⽐需要的值⼤，就继续递归
 if (node.value > v) {
 return this._floor(node.left, v)
 }
 // 判断当前节点是否拥有右⼦树
 let right = this._floor(node.right, v)
 if (right) return right
 return node
}
class Node {
 constructor(value) {
 this.value = value
 this.left = null
 this.right = null
 // 修改代码
 this.size = 1
 }
}
// 新增代码
_getSize(node) {
 return node ? node.size : 0
}
_addChild(node, v) {
 if (!node) {
 return new Node(v)
 }
 if (node.value > v) {
 // 修改代码
 node.size++
 node.left = this._addChild(node.left, v)
 } else if (node.value < v) {
 // 修改代码
 node.size++
 node.right = this._addChild(node.right, v)
 }
 return node
}
select(k) {
 let node = this._select(this.root, k)
 return node ? node.value : null
}
_select(node, k) {
 if (!node) return null
 // 先获取左⼦树下有⼏个节点
 let size = node.left ? node.left.size : 0
 // 判断 size 是否⼤于 k
 // 如果⼤于 k，代表所需要的节点在左节点
 if (size > k) return this._select(node.left, k)
 // 如果⼩于 k，代表所需要的节点在右节点
 // 注意这⾥需要重新计算 k，减去根节点除了右⼦树的节点数量
接下来讲解的是⼆分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在
以下⼏种情况
需要删除的节点没有⼦树
需要删除的节点只有⼀条⼦树
需要删除的节点有左右两条树
对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删
除最⼩节点，对于删除最⼩节点来说，是不存在第三种情况的，删除最⼤节点操作是和删除
最⼩节点相反的，所以这⾥也就不再赘述。
最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个
难题的办法，也就是如何解决第三种情况。
 if (size < k) return this._select(node.right, k - size - 1)
 return node
}
delectMin() {
 this.root = this._delectMin(this.root)
 console.log(this.root)
}
_delectMin(node) {
 // ⼀直递归左⼦树
 // 如果左⼦树为空，就判断节点是否拥有右⼦树
 // 有右⼦树的话就把需要删除的节点替换为右⼦树
 if ((node != null) & !node.left) return node.right
 node.left = this._delectMin(node.left)
 // 最后需要重新维护下节点的 `size`
 node.size = this._getSize(node.left) + this._getSize(node.right) + 1
 return node
}
当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右⼦树的最⼩节点）来
替换需要删除的节点。然后将需要删除节点的左⼦树赋值给后继结点，右⼦树删除后继结点
后赋值给他。
你如果对于这个解决办法有疑问的话，可以这样考虑。因为⼆分搜索树的特性，⽗节点⼀定
⽐所有左⼦节点⼤，⽐所有右⼦节点⼩。那么当需要删除⽗节点时，势必需要拿出⼀个⽐⽗
节点⼤的节点来替换⽗节点。这个节点肯定不存在于左⼦树，必然存在于右⼦树。然后⼜需
要保持⽗节点都是⽐右⼦节点⼩的，那么就可以取出右⼦树中最⼩的那个节点来替换⽗节
点。
delect(v) {
 this.root = this._delect(this.root, v)
}
_delect(node, v) {
 if (!node) return null
 // 寻找的节点⽐当前节点⼩，去左⼦树找
 if (node.value < v) {
 node.right = this._delect(node.right, v)
 } else if (node.value > v) {
 // 寻找的节点⽐当前节点⼤，去右⼦树找
 node.left = this._delect(node.left, v)
 } else {
 // 进⼊这个条件说明已经找到节点
 // 先判断节点是否拥有拥有左右⼦树中的⼀个
 // 是的话，将⼦树返回出去，这⾥和 `_delectMin` 的操作⼀样
 if (!node.left) return node.right
 if (!node.right) return node.left
 // 进⼊这⾥，代表节点拥有左右⼦树
 // 先取出当前节点的后继结点，也就是取当前节点右⼦树的最⼩值
 let min = this._getMin(node.right)
 // 取出最⼩值后，删除最⼩值
 // 然后把删除节点后的⼦树赋值给最⼩值节点
 min.right = this._delectMin(node.right)
 // 左⼦树不动
 min.left = node.left
AVL 树
概念
⼆分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成
链表，⽐如加⼊⼀组升序的数字就会造成这种情况。
AVL 树改进了⼆分搜索树，在 AVL 树中任意节点的左右⼦树的⾼度差都不⼤于 1，这样保证
了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达
到⾼度的平衡。
实现
因为 AVL 树是改进了⼆分搜索树，所以部分代码是于⼆分搜索树重复的，对于重复内容不作
再次解析。
对于 AVL 树来说，添加节点会有四种情况
 node = min
 }
 // 维护 size
 node.size = this._getSize(node.left) + this._getSize(node.right) + 1
 return node
}
对于左左情况来说，新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为
搜索树的特性，节点⽐左节点⼤，⽐右节点⼩，所以旋转以后也要实现这个特性。
旋转之前：new < 2 < C < 3 < B < 5 < A，右旋之后节点 3 为根节点，这时候需要将节点 3 的
右节点加到节点 5 的左边，最后还需要更新节点的⾼度。
对于右右情况来说，相反于左左情况，所以不再赘述。
对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来
达到⽬的。
⾸先对节点的左节点左旋，这时树满⾜左左的情况，再对节点进⾏⼀次右旋就可以达到⽬
的。
class Node {
 constructor(value) {
 this.value = value
 this.left = null
 this.right = null
 this.height = 1
 }
}
class AVL {
 constructor() {
 this.root = null
 }
 addNode(v) {
 this.root = this._addChild(this.root, v)
 }
 _addChild(node, v) {
 if (!node) {
 return new Node(v)
 }
 if (node.value > v) {
 node.left = this._addChild(node.left, v)
 } else if (node.value < v) {
 node.right = this._addChild(node.right, v)
 } else {
 node.value = v
 }
 node.height =
 1 + Math.max(this._getHeight(node.left),
this._getHeight(node.right))
 let factor = this._getBalanceFactor(node)
 // 当需要右旋时，根节点的左树⼀定⽐右树⾼度⾼
 if (factor > 1 && this._getBalanceFactor(node.left) >= 0) {
 return this._rightRotate(node)
 }
 // 当需要左旋时，根节点的左树⼀定⽐右树⾼度矮
 if (factor < -1 && this._getBalanceFactor(node.right) <= 0) {
 return this._leftRotate(node)
 }
 // 左右情况
 // 节点的左树⽐右树⾼，且节点的左树的右树⽐节点的左树的左树⾼
 if (factor > 1 && this._getBalanceFactor(node.left) < 0) {
 node.left = this._leftRotate(node.left)
 return this._rightRotate(node)
 }
 // 右左情况
 // 节点的左树⽐右树矮，且节点的右树的右树⽐节点的右树的左树矮
 if (factor < -1 && this._getBalanceFactor(node.right) > 0) {
 node.right = this._rightRotate(node.right)
 return this._leftRotate(node)
 }
 return node
 }
 _getHeight(node) {
 if (!node) return 0
 return node.height
 }
 _getBalanceFactor(node) {
 return this._getHeight(node.left) - this._getHeight(node.right)
 }
 // 节点右旋
 // 5 2
 // / \ / \
 // 2 6 ==> 1 5
 // / \ / / \
 // 1 3 new 3 6
 // /
 // new
 _rightRotate(node) {
 // 旋转后新根节点
 let newRoot = node.left
 // 需要移动的节点
 let moveNode = newRoot.right
 // 节点 2 的右节点改为节点 5
 newRoot.right = node
 // 节点 5 左节点改为节点 3
 node.left = moveNode
 // 更新树的⾼度
 node.height =
 1 + Math.max(this._getHeight(node.left),
this._getHeight(node.right))
 newRoot.height =
 1 +
 Math.max(this._getHeight(newRoot.left),
this._getHeight(newRoot.right))
 return newRoot
 }
 // 节点左旋
 // 4 6
 // / \ / \
 // 2 6 ==> 4 7
 // / \ / \ \
 // 5 7 2 5 new
 // \
 // new
 _leftRotate(node) {
 // 旋转后新根节点
 let newRoot = node.right
 // 需要移动的节点
 let moveNode = newRoot.left
 // 节点 6 的左节点改为节点 4
 newRoot.left = node
 // 节点 4 右节点改为节点 5
 node.right = moveNode
 // 更新树的⾼度
 node.height =
 1 + Math.max(this._getHeight(node.left),
this._getHeight(node.right))
 newRoot.height =
Trie
概念
在计算机科学，trie，⼜称前缀树或字典树，是⼀种有序树，⽤于保存关联数组，其中的键通
常是字符串。
简单点来说，这个结构的作⽤⼤多是为了⽅便搜索字符串，该树有以下⼏个特点
根节点代表空字符串，每个节点都有 N（假如搜索英⽂字符，就有 26 条） 条链接，每条
链接代表⼀个字符
节点不存储字符，只有路径才存储，这点和其他的树结构不同
从根节点开始到任意⼀个节点，将沿途经过的字符连接起来就是该节点对应的字符串
 1 +
 Math.max(this._getHeight(newRoot.left),
this._getHeight(newRoot.right))
 return newRoot
 }
}
、
实现
总得来说 Trie 的实现相⽐别的树结构来说简单的很多，实现就以搜索英⽂字符为例。
class TrieNode {
 constructor() {
 // 代表每个字符经过节点的次数
 this.path = 0
 // 代表到该节点的字符串有⼏个
 this.end = 0
 // 链接
 this.next = new Array(26).fill(null)
 }
}
class Trie {
 constructor() {
 // 根节点，代表空字符
 this.root = new TrieNode()
 }
 // 插⼊字符串
 insert(str) {
 if (!str) return
 let node = this.root
 for (let i = 0; i < str.length; i++) {
 // 获得字符先对应的索引
 let index = str[i].charCodeAt() - 'a'.charCodeAt()
 // 如果索引对应没有值，就创建
 if (!node.next[index]) {
 node.next[index] = new TrieNode()
 }
 node.path += 1
 node = node.next[index]
 }
 node.end += 1
 }
 // 搜索字符串出现的次数
 search(str) {
 if (!str) return
 let node = this.root
 for (let i = 0; i < str.length; i++) {
 let index = str[i].charCodeAt() - 'a'.charCodeAt()
 // 如果索引对应没有值，代表没有需要搜素的字符串
 if (!node.next[index]) {
 return 0
 }
 node = node.next[index]
并查集
概念
并查集是⼀种特殊的树结构，⽤于处理⼀些不交集的合并及查询问题。该结构中每个节点都
有⼀个⽗节点，如果只有当前⼀个节点，那么该节点的⽗节点指向⾃⼰。
这个结构中有两个重要的操作，分别是：
Find：确定元素属于哪⼀个⼦集。它可以被⽤来确定两个元素是否属于同⼀⼦集。
Union：将两个⼦集合并成同⼀个集合。
 }
 return node.end
 }
 // 删除字符串
 delete(str) {
 if (!this.search(str)) return
 let node = this.root
 for (let i = 0; i < str.length; i++) {
 let index = str[i].charCodeAt() - 'a'.charCodeAt()
 // 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串
 // 已经⼀个，直接删除即可
 if (--node.next[index].path == 0) {
 node.next[index] = null
 return
 }
 node = node.next[index]
 }
 node.end -= 1
 }
}
实现
class DisjointSet {
 // 初始化样本
 constructor(count) {
 // 初始化时，每个节点的⽗节点都是⾃⼰
 this.parent = new Array(count)
 // ⽤于记录树的深度，优化搜索复杂度
 this.rank = new Array(count)
 for (let i = 0; i < count; i++) {
 this.parent[i] = i
 this.rank[i] = 1
 }
 }
 find(p) {
 // 寻找当前节点的⽗节点是否为⾃⼰，不是的话表示还没找到
 // 开始进⾏路径压缩优化
 // 假设当前节点⽗节点为 A
 // 将当前节点挂载到 A 节点的⽗节点上，达到压缩深度的⽬的
 while (p != this.parent[p]) {
 this.parent[p] = this.parent[this.parent[p]]
 p = this.parent[p]
 }
 return p
 }
 isConnected(p, q) {
堆
概念
堆通常是⼀个可以被看做⼀棵树的数组对象。
堆的实现通过构造⼆叉堆，实为⼆叉树的⼀种。这种数据结构具有以下性质。
任意节点⼩于（或⼤于）它的所有⼦节点
堆总是⼀棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填
⼊。
将根节点最⼤的堆叫做最⼤堆或⼤根堆，根节点最⼩的堆叫做最⼩堆或⼩根堆。
优先队列也完全可以⽤堆来实现，操作是⼀模⼀样的。
 return this.find(p) === this.find(q)
 }
 // 合并
 union(p, q) {
 // 找到两个数字的⽗节点
 let i = this.find(p)
 let j = this.find(q)
 if (i === j) return
 // 判断两棵树的深度，深度⼩的加到深度⼤的树下⾯
 // 如果两棵树深度相等，那就⽆所谓怎么加
 if (this.rank[i] < this.rank[j]) {
 this.parent[i] = j
 } else if (this.rank[i] > this.rank[j]) {
 this.parent[j] = i
 } else {
 this.parent[i] = j
 this.rank[j] += 1
 }
 }
}
实现⼤根堆
堆的每个节点的左边⼦节点索引是 i * 2 + 1 ，右边是 i * 2 + 2 ，⽗节点是 (i - 1)
/2 。
堆有两个核⼼的操作，分别是 shiftUp 和 shiftDown 。前者⽤于添加元素，后者⽤于删除
根节点。
shiftUp 的核⼼思路是⼀路将节点与⽗节点对⽐⼤⼩，如果⽐⽗节点⼤，就和⽗节点交换位
置。
shiftDown 的核⼼思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断
⽗节点和两个⼦节点的⼤⼩，如果⼦节点⼤，就把最⼤的⼦节点和⽗节点交换。
class MaxHeap {
 constructor() {
 this.heap = []
 }
 size() {
 return this.heap.length
 }
 empty() {
 return this.size() == 0
 }
 add(item) {
 this.heap.push(item)
 this._shiftUp(this.size() - 1)
 }
 removeMax() {
 this._shiftDown(0)
 }
 getParentIndex(k) {
 return parseInt((k - 1) / 2)
 }
 getLeftIndex(k) {
 return k * 2 + 1
 }
 _shiftUp(k) {
 // 如果当前节点⽐⽗节点⼤，就交换
 while (this.heap[k] > this.heap[this.getParentIndex(k)]) {
 this._swap(k, this.getParentIndex(k))
 // 将索引变成⽗节点
 k = this.getParentIndex(k)
 }
 }
 _shiftDown(k) {
 // 交换⾸位并删除末尾
 this._swap(k, this.size() - 1)
 this.heap.splice(this.size() - 1, 1)
 // 判断节点是否有左孩⼦，因为⼆叉堆的特性，有右必有左
 while (this.getLeftIndex(k) < this.size()) {
 let j = this.getLeftIndex(k)
 // 判断是否有右孩⼦，并且右孩⼦是否⼤于左孩⼦
 if (j + 1 < this.size() && this.heap[j + 1] > this.heap[j]) j++
 // 判断⽗节点是否已经⽐⼦节点都⼤
算法章节
时间复杂度
通常使⽤最差的时间复杂度来衡量⼀个算法的好坏。
常数时间 O(1) 代表这个操作和数据量没关系，是⼀个固定时间的操作，⽐如说四则运算。
对于⼀个算法来说，可能会计算出如下操作次数 aN + 1 ， N 代表数据量。那么该算法的时
间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是⾮常⼤的，这时候低
阶项和常数项可以忽略不计。
当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对⽐两个算法的好坏就要通过对⽐低
阶项和常数项了。
位运算
位运算在算法中很有⽤，速度可以⽐四则运算快很多。
在学习位运算之前应该知道⼗进制如何转⼆进制，⼆进制如何转⼗进制。这⾥说明下简单的
计算⽅式
 if (this.heap[k] >= this.heap[j]) break
 this._swap(k, j)
 k = j
 }
 }
 _swap(left, right) {
 let rightValue = this.heap[right]
 this.heap[right] = this.heap[left]
 this.heap[left] = rightValue
 }
}
⼗进制 33 可以看成是 32 + 1 ，并且 33 应该是六位⼆进制的（因为 33 近似 32 ，
⽽ 32 是 2 的五次⽅，所以是六位），那么 ⼗进制 33 就是 100001 ，只要是 2 的次
⽅，那么就是 1否则都为 0
那么⼆进制 100001 同理，⾸位是 2^5 ，末位是 2^0 ，相加得出 33
左移 <<
左移就是将⼆进制全部往左移动， 10 在⼆进制中表示为 1010 ，左移⼀位后变成 10100
，转换为⼗进制也就是 20，所以基本可以把左移看成以下公式 a * (2 ^ b)
算数右移 >>
算数右移就是将⼆进制全部往右移动并去除多余的右边， 10 在⼆进制中表示为 1010 ，右
移⼀位后变成 101 ，转换为⼗进制也就是 5，所以基本可以把右移看成以下公式 int v =
a / (2 ^ b)
右移很好⽤，⽐如可以⽤在⼆分算法中取中间值
按位操作
按位与
每⼀位都为 1，结果才为 1
按位或
10 << 1 // -> 20
10 >> 1 // -> 5
13 >> 1 // -> 6
8 & 7 // -> 0
// 1000 & 0111 -> 0000 -> 0
其中⼀位为 1，结果就是 1
按位异或
每⼀位都不同，结果才为 1
从以上代码中可以发现按位异或就是不进位加法
⾯试题：两个数不使⽤四则运算得出和
这道题中可以按位异或，因为按位异或就是不进位加法， 8 ^ 8 = 0 如果进位了，就是 16
了，所以我们只需要将两个数进⾏异或操作，然后进位。那么也就是说两个⼆进制都是 1 的
位置，左边应该有⼀个进位 1，所以可以得出以下公式 a + b = (a ^ b) + ((a & b) <<
1) ，然后通过迭代的⽅式模拟加法
8 | 7 // -> 15
// 1000 | 0111 -> 1111 -> 15
8 ^ 7 // -> 15
8 ^ 8 // -> 0
// 1000 ^ 0111 -> 1111 -> 15
// 1000 ^ 1000 -> 0000 -> 0
function sum(a, b) {
 if (a == 0) return b
 if (b == 0) return a
 let newA = a ^ b
 let newB = (a & b) << 1
 return sum(newA, newB)
}
排序
以下两个函数是排序中会⽤到的通⽤函数，就不⼀⼀写了
冒泡排序
冒泡排序的原理如下，从第⼀个元素开始，把当前元素和下⼀个索引元素进⾏⽐较。如果当
前元素⼤，那么就交换位置，重复操作直到⽐较到最后⼀个元素，那么此时最后⼀个元素就
是该数组中最⼤的数。下⼀轮重复以上操作，但是此时最后⼀个元素已经是最⼤数了，所以
不需要再⽐较最后⼀个元素，只需要⽐较到 length - 1 的位置。
以下是实现该算法的代码
function checkArray(array) {
 if (!array || array.length <= 2) return
}
function swap(array, left, right) {
 let rightValue = array[right]
 array[right] = array[left]
 array[left] = rightValue
}
该算法的操作次数是⼀个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时
间复杂度是 O(n * n)
插⼊排序
插⼊排序的原理如下。第⼀个元素默认是已排序元素，取出下⼀个元素和当前元素⽐较，如
果当前元素⼤就交换位置。那么此时第⼀个元素就是当前的最⼩数，所以下次取出操作从第
三个元素开始，向前对⽐，重复之前的操作。
以下是实现该算法的代码
function bubble(array) {
 checkArray(array);
 for (let i = array.length - 1; i > 0; i--) {
 // 从 0 到 `length - 1` 遍历
 for (let j = 0; j < i; j++) {
 if (array[j] > array[j + 1]) swap(array, j, j + 1)
 }
 }
 return array;
}
该算法的操作次数是⼀个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时
间复杂度是 O(n * n)
选择排序
选择排序的原理如下。遍历数组，设置最⼩值的索引为 0，如果取出的值⽐当前最⼩值⼩，就
替换最⼩值索引，遍历完成后，将第⼀个元素和最⼩值索引上的值交换。如上操作后，第⼀
个元素就是数组中的最⼩值，下次遍历就可以从索引 1 开始重复上述操作。
以下是实现该算法的代码
function insertion(array) {
 checkArray(array);
 for (let i = 1; i < array.length; i++) {
 for (let j = i - 1; j >= 0 && array[j] > array[j + 1]; j--)
 swap(array, j, j + 1);
 }
 return array;
}
该算法的操作次数是⼀个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时
间复杂度是 O(n * n)
归并排序
归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合
并，最终合并为排序好的数组。假设我有⼀组数组 [3, 1, 2, 8, 9, 7, 6] ，中间数索引
是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元
素（如果数组⻓度是奇数的话，会有⼀个拆分数组只包含⼀个元素）。然后排序数组 [3,
1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以
上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。
function selection(array) {
 checkArray(array);
 for (let i = 0; i < array.length - 1; i++) {
 let minIndex = i;
 for (let j = i + 1; j < array.length; j++) {
 minIndex = array[j] < array[minIndex] ? j : minIndex;
 }
 swap(array, i, minIndex);
 }
 return array;
}
以下是实现该算法的代码
function sort(array) {
 checkArray(array);
 mergeSort(array, 0, array.length - 1);
 return array;
}
function mergeSort(array, left, right) {
 // 左右索引相同说明已经只有⼀个数
 if (left === right) return;
 // 等同于 `left + (right - left) / 2`
 // 相⽐ `(left + right) / 2` 来说更加安全，不会溢出
 // 使⽤位运算是因为位运算⽐四则运算快
以上算法使⽤了递归的思想。递归的本质就是压栈，每递归执⾏⼀次函数，就将该函数的信
息（⽐如参数，内部的变量，执⾏到的⾏数）压栈，直到遇到终⽌条件，然后出栈并继续执
⾏函数。对于以上递归函数的调⽤轨迹如下
 let mid = parseInt(left + ((right - left) >> 1));
 mergeSort(array, left, mid);
 mergeSort(array, mid + 1, right);
 let help = [];
 let i = 0;
 let p1 = left;
 let p2 = mid + 1;
 while (p1 <= mid && p2 <= right) {
 help[i++] = array[p1] < array[p2] ? array[p1++] : array[p2++];
 }
 while (p1 <= mid) {
 help[i++] = array[p1++];
 }
 while (p2 <= right) {
 help[i++] = array[p2++];
 }
 for (let i = 0; i < help.length; i++) {
 array[left + i] = help[i];
 }
 return array;
}
mergeSort(data, 0, 6) // mid = 3
 mergeSort(data, 0, 3) // mid = 1
 mergeSort(data, 0, 1) // mid = 0
 mergeSort(data, 0, 0) // 遇到终⽌，回退到上⼀步
 mergeSort(data, 1, 1) // 遇到终⽌，回退到上⼀步
 // 排序 p1 = 0, p2 = mid + 1 = 1
 // 回退到 `mergeSort(data, 0, 3)` 执⾏下⼀个递归
 mergeSort(2, 3) // mid = 2
该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的⼀半，并且最后把整
个数组迭代了⼀次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。
根据该表达式可以套⽤ 该公式 得出时间复杂度为 O(N * logN)
快排
快排的原理如下。随机选取⼀个数组中的值作为基准值，从左⾄右取值与基准值对⽐⼤⼩。
⽐基准值⼩的放数组左边，⼤的放右边，对⽐完成后将基准值和第⼀个⽐基准值⼤的值交换
位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。
以下是实现该算法的代码
 mergeSort(3, 3) // 遇到终⽌，回退到上⼀步
 // 排序 p1 = 2, p2 = mid + 1 = 3
 // 回退到 `mergeSort(data, 0, 3)` 执⾏合并逻辑
 // 排序 p1 = 0, p2 = mid + 1 = 2
 // 执⾏完毕回退
 // 左边数组排序完毕，右边也是如上轨迹
function sort(array) {
 checkArray(array);
 quickSort(array, 0, array.length - 1);
 return array;
}
function quickSort(array, left, right) {
 if (left < right) {
 swap(array, , right)
 // 随机取值，然后和末尾交换，这样做⽐固定取⼀个位置的复杂度略低
 let indexs = part(array, parseInt(Math.random() * (right - left +
1)) + left, right);
 quickSort(array, left, indexs[0]);
 quickSort(array, indexs[1] + 1, right);
 }
}
function part(array, left, right) {
 let less = left - 1;
 let more = right;
 while (left < more) {
 if (array[left] < array[right]) {
 // 当前值⽐基准值⼩，`less` 和 `left` 都加⼀
 ++less;
 ++left;
 } else if (array[left] > array[right]) {
 // 当前值⽐基准值⼤，将当前值和右边的值交换
 // 并且不改变 `left`，因为当前换过来的值还没有判断过⼤⼩
 swap(array, --more, left);
 } else {
 // 和基准值相同，只移动下标
 left++;
 }
 }
 // 将基准值和⽐基准值⼤的第⼀个值交换位置
 // 这样数组就变成 `[⽐基准值⼩, 基准值, ⽐基准值⼤]`
 swap(array, right, more);
 return [less, more];
}
该算法的复杂度和归并排序是相同的，但是额外空间复杂度⽐归并排序少，只需 O(logN)，并
且相⽐归并排序来说，所需的常数时间也更少。
⾯试题
Sort Colors：该题⽬来⾃ LeetCode，题⽬需要我们将 [2,0,2,1,1,0] 排序成
[0,0,1,1,2,2] ，这个问题就可以使⽤三路快排的思想。
以下是代码实现
Kth Largest Element in an Array：该题⽬来⾃ LeetCode，题⽬需要找出数组中第 K ⼤的
元素，这问题也可以使⽤快排的思路。并且因为是找出第 K ⼤元素，所以在分离数组的过程
中，可以找出需要的元素在哪边，然后只需要排序相应的⼀边数组就好。
以下是代码实现
var sortColors = function(nums) {
 let left = -1;
 let right = nums.length;
 let i = 0;
 // 下标如果遇到 right，说明已经排序完成
 while (i < right) {
 if (nums[i] == 0) {
 swap(nums, i++, ++left);
 } else if (nums[i] == 1) {
 i++;
 } else {
 swap(nums, i, --right);
 }
 }
};
var findKthLargest = function(nums, k) {
 let l = 0
 let r = nums.length - 1
 // 得出第 K ⼤元素的索引位置
 k = nums.length - k
 while (l < r) {
 // 分离数组后获得⽐基准树⼤的第⼀个元素索引
 let index = part(nums, l, r)
 // 判断该索引和 k 的⼤⼩
 if (index < k) {
 l = index + 1
 } else if (index > k) {
 r = index - 1
 } else {
 break
 }
 }
 return nums[k]
};
function part(array, left, right) {
 let less = left - 1;
 let more = right;
 while (left < more) {
 if (array[left] < array[right]) {
 ++less;
 ++left;
 } else if (array[left] > array[right]) {
 swap(array, --more, left);
 } else {
 left++;
 }
 }
 swap(array, right, more);
 return more;
}
堆排序
堆排序利⽤了⼆叉堆的特性来做，⼆叉堆通常⽤数组表示，并且⼆叉堆是⼀颗完全⼆叉树
（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。⼆
叉堆⼜分为⼤根堆与⼩根堆。
⼤根堆是某个节点的所有⼦节点的值都⽐他⼩
⼩根堆是某个节点的所有⼦节点的值都⽐他⼤
堆排序的原理就是组成⼀个⼤根堆或者⼩根堆。以⼩根堆为例，某个节点的左边⼦节点索引
是 i * 2 + 1 ，右边是 i * 2 + 2 ，⽗节点是 (i - 1) /2 。
1. ⾸先遍历数组，判断该节点的⽗节点是否⽐他⼩，如果⼩就交换位置并继续判断，直到他
的⽗节点⽐他⼤
2. 重新以上操作 1，直到数组⾸位是最⼤值
3. 然后将⾸位和末尾交换位置并将数组⻓度减⼀，表示数组末尾已是最⼤值，不需要再⽐较
⼤⼩
4. 对⽐左右节点哪个⼤，然后记住⼤的节点的索引并且和⽗节点对⽐⼤⼩，如果⼦节点⼤就
交换位置
5. 重复以上操作 3 - 4 直到整个数组都是⼤根堆。
以下是实现该算法的代码
function heap(array) {
 checkArray(array);
 // 将最⼤值交换到⾸位
 for (let i = 0; i < array.length; i++) {
 heapInsert(array, i);
 }
 let size = array.length;
以上代码实现了⼩根堆，如果需要实现⼤根堆，只需要把节点对⽐反⼀下就好。
该算法的复杂度是 O(logN)
 // 交换⾸位和末尾
 swap(array, 0, --size);
 while (size > 0) {
 heapify(array, 0, size);
 swap(array, 0, --size);
 }
 return array;
}
function heapInsert(array, index) {
 // 如果当前节点⽐⽗节点⼤，就交换
 while (array[index] > array[parseInt((index - 1) / 2)]) {
 swap(array, index, parseInt((index - 1) / 2));
 // 将索引变成⽗节点
 index = parseInt((index - 1) / 2);
 }
}
function heapify(array, index, size) {
 let left = index * 2 + 1;
 while (left < size) {
 // 判断左右节点⼤⼩
 let largest =
 left + 1 < size && array[left] < array[left + 1] ? left + 1 :
left;
 // 判断⼦节点和⽗节点⼤⼩
 largest = array[index] < array[largest] ? largest : index;
 if (largest === index) break;
 swap(array, index, largest);
 index = largest;
 left = index * 2 + 1;
 }
}
系统⾃带排序实现
每个语⾔的排序内部实现都是不同的。
对于 JS 来说，数组⻓度⼤于 10 会采⽤快排，否则使⽤插⼊排序 源码实现 。选择插⼊排序
是因为虽然时间复杂度很差，但是在数据量很⼩的情况下和 O(N * logN) 相差⽆⼏，然⽽插
⼊排序需要的常数时间很⼩，所以相对别的排序来说更快。
对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采⽤稳定性好的
算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。
链表
反转单向链表
该题⽬来⾃ LeetCode，题⽬需要将⼀个单向链表反转。思路很简单，使⽤三个变量分别表示
当前节点和当前节点的前后节点，虽然这题很简单，但是却是⼀道⾯试常考题
以下是实现该算法的代码
树
⼆叉树的先序，中序，后序遍历
先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。
中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。
var reverseList = function(head) {
 // 判断下变量边界问题
 if (!head || !head.next) return head
 // 初始设置为空，因为第⼀个节点反转后就是尾部，尾部节点指向 null
 let pre = null
 let current = head
 let next
 // 判断当前节点是否为空
 // 不为空就先获取当前节点的下⼀节点
 // 然后把当前节点的 next 设为上⼀个节点
 // 然后把 current 设为下⼀个节点，pre 设为当前节点
 while(current) {
 next = current.next
 current.next = pre
 pre = current
 current = next
 }
 return pre
};
后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。
递归实现
递归实现相当简单，代码如下
对于递归的实现来说，只需要理解每个节点都会被访问三次就明⽩为什么这样实现了。
⾮递归实现
⾮递归实现使⽤了栈的结构，通过栈的先进后出模拟递归实现。
以下是先序遍历代码实现
function TreeNode(val) {
 this.val = val;
 this.left = this.right = null;
}
var traversal = function(root) {
 if (root) {
 // 先序
 console.log(root);
 traversal(root.left);
 // 中序
 // console.log(root);
 traversal(root.right);
 // 后序
 // console.log(root);
 }
};
function pre(root) {
 if (root) {
 let stack = [];
 // 先将根节点 push
 stack.push(root);
以下是中序遍历代码实现
 // 判断栈中是否为空
 while (stack.length > 0) {
 // 弹出栈顶元素
 root = stack.pop();
 console.log(root);
 // 因为先序遍历是先左后右，栈是先进后出结构
 // 所以先 push 右边再 push 左边
 if (root.right) {
 stack.push(root.right);
 }
 if (root.left) {
 stack.push(root.left);
 }
 }
 }
}
function mid(root) {
 if (root) {
 let stack = [];
 // 中序遍历是先左再根最后右
 // 所以⾸先应该先把最左边节点遍历到底依次 push 进栈
 // 当左边没有节点时，就打印栈顶元素，然后寻找右节点
 // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的⽗节点
 // 左边打印不出东⻄就把⽗节点拿出来打印，然后再看右节点
 while (stack.length > 0 || root) {
 if (root) {
 stack.push(root);
 root = root.left;
 } else {
 root = stack.pop();
 console.log(root);
 root = root.right;
以下是后序遍历代码实现，该代码使⽤了两个栈来实现遍历，相⽐⼀个栈的遍历来说要容易
理解很多
 }
 }
 }
}
function pos(root) {
 if (root) {
 let stack1 = [];
 let stack2 = [];
 // 后序遍历是先左再右最后根
 // 所以对于⼀个栈来说，应该先 push 根节点
 // 然后 push 右节点，最后 push 左节点
 stack1.push(root);
 while (stack1.length > 0) {
 root = stack1.pop();
 stack2.push(root);
 if (root.left) {
 stack1.push(root.left);
 }
 if (root.right) {
 stack1.push(root.right);
 }
 }
 while (stack2.length > 0) {
 console.log(s2.pop());
 }
 }
}
中序遍历的前驱后继节点
实现这个算法的前提是节点有⼀个 parent 的指针指向⽗节点，根节点指向 null 。
如图所示，该树的中序遍历结果是 4, 2, 5, 1, 6, 3, 7
前驱节点
对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论
1. 如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左
节点 2 ，那么节点 2 的最右节点就是 5
2. 如果左节点为空，且⽬标节点是⽗节点的右节点，那么前驱节点为⽗节点。对于节点 5
来说，没有左节点，且是节点 2 的右节点，所以节点 2 是前驱节点
3. 如果左节点为空，且⽬标节点是⽗节点的左节点，向上寻找到第⼀个是⽗节点的右节点的
节点。对于节点 6 来说，没有左节点，且是节点 3 的左节点，所以向上寻找到节点 1
，发现节点 3 是节点 1 的右节点，所以节点 1 是节点 6 的前驱节点
以下是算法实现
function predecessor(node) {
 if (!node) return
 // 结论 1
 if (node.left) {
 return getRight(node.left)
后继节点
对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论
1. 如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么
节点 3 的最左节点就是 6
2. 如果没有右节点，就向上遍历直到找到⼀个节点是⽗节点的左节点。对于节点 5 来说，
没有右节点，就向上寻找到节点 2 ，该节点是⽗节点 1 的左节点，所以节点 1 是后
继节点
以下是算法实现
 } else {
 let parent = node.parent
 // 结论 2 3 的判断
 while(parent && parent.right === node) {
 node = parent
 parent = node.parent
 }
 return parent
 }
}
function getRight(node) {
 if (!node) return
 node = node.right
 while(node) node = node.right
 return node
}
function successor(node) {
 if (!node) return
 // 结论 1
 if (node.right) {
 return getLeft(node.right)
 } else {
树的深度
树的最⼤深度：该题⽬来⾃ Leetcode，题⽬需要求出⼀颗⼆叉树的最⼤深度
以下是算法实现
对于该递归函数可以这样理解：⼀旦没有找到节点就会返回 0，每弹出⼀次递归函数就会加
⼀，树有三层就会得到3。
 // 结论 2
 let parent = node.parent
 // 判断 parent 为空
 while(parent && parent.left === node) {
 node = parent
 parent = node.parent
 }
 return parent
 }
}
function getLeft(node) {
 if (!node) return
 node = node.left
 while(node) node = node.left
 return node
}
var maxDepth = function(root) {
 if (!root) return 0
 return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
};
动态规划
动态规划背后的基本思想⾮常简单。就是将⼀个问题拆分为⼦问题，⼀般来说这些⼦问题都
是⾮常相似的，那么我们可以通过只解决⼀次每个⼦问题来达到减少计算量的⽬的。
⼀旦得出每个⼦问题的解，就存储该结果以便下次使⽤。
斐波那契数列
斐波那契数列就是从 0 和 1 开始，后⾯的数都是前两个数之和
0，1，1，2，3，5，8，13，21，34，55，89....
那么显然易⻅，我们可以通过递归的⽅式来完成求解斐波那契数列
以上代码已经可以完美的解决问题。但是以上解法却存在很严重的性能问题，当 n 越⼤的时
候，需要的时间是指数增⻓的，这时候就可以通过动态规划来解决这个问题。
动态规划的本质其实就是两点
1. ⾃底向上分解⼦问题
2. 通过变量存储已经计算过的解
根据上⾯两点，我们的斐波那契数列的动态规划思路也就出来了
1. 斐波那契数列从 0 和 1 开始，那么这就是这个⼦问题的最底层
2. 通过数组来存储每⼀位所对应的斐波那契数列的值
function fib(n) {
 if (n < 2 && n >= 0) return n
 return fib(n - 1) + fib(n - 2)
}
fib(10)
物品 ID / 重量 价值
1 3
2 7
3 12
0 - 1背包问题
该问题可以描述为：给定⼀组物品，每种物品都有⾃⼰的重量和价格，在限定的总重量内，
我们如何选择，才能使得物品的总价格最⾼。每个问题只能放⼊⾄多⼀次。
假设我们有以下物品
对于⼀个总容量为 5 的背包来说，我们可以放⼊重量 2 和 3 的物品来达到背包内的物品总价
值最⾼。
对于这个问题来说，⼦问题就两个，分别是放物品和不放物品，可以通过以下表格来理解⼦
问题
function fib(n) {
 let array = new Array(n + 1).fill(null)
 array[0] = 0
 array[1] = 1
 for (let i = 2; i <= n; i++) {
 array[i] = array[i - 1] + array[i - 2]
 }
 return array[n]
}
fib(10)
物品 ID / 剩余容量 0 1 2 3 4 5
1 0 3 3 3 3 3
2 0 3 7 10 10 10
3 0 3 7 12 15 19
直接来分析能放三种物品的情况，也就是最后⼀⾏
当容量少于 3 时，只取上⼀⾏对应的数据，因为当前容量不能容纳物品 3
当容量 为 3 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
不放物品 3 的情况下，总价值为 10
放⼊物品 3 的情况下，总价值为 12，所以应该放⼊物品 3
当容量 为 4 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
不放物品 3 的情况下，总价值为 10
放⼊物品 3 的情况下，和放⼊物品 1 的价值相加，得出总价值为 15，所以应该放⼊
物品 3
当容量 为 5 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
不放物品 3 的情况下，总价值为 10
放⼊物品 3 的情况下，和放⼊物品 2 的价值相加，得出总价值为 19，所以应该放⼊
物品 3
以下代码对照上表更容易理解
/**
 * @param {*} w 物品重量
 * @param {*} v 物品价值
 * @param {*} C 总容量
 * @returns
 */
function knapsack(w, v, C) {
 let length = w.length
 if (length === 0) return 0
 // 对照表格，⽣成的⼆维数组，第⼀维代表物品，第⼆维代表背包剩余容量
最⻓递增⼦序列
最⻓递增⼦序列意思是在⼀组数字中，找出最⻓⼀串递增的数字，⽐如
0, 3, 4, 17, 2, 8, 6, 10
对于以上这串数字来说，最⻓递增⼦序列就是 0, 3, 4, 8, 10，可以通过以下表格更清晰的理解
 // 第⼆维中的元素代表背包物品总价值
 let array = new Array(length).fill(new Array(C + 1).fill(null))
 // 完成底部⼦问题的解
 for (let i = 0; i <= C; i++) {
 // 对照表格第⼀⾏， array[0] 代表物品 1
 // i 代表剩余总容量
 // 当剩余总容量⼤于物品 1 的重量时，记录下背包物品总价值，否则价值为 0
 array[0][i] = i >= w[0] ? v[0] : 0
 }
 // ⾃底向上开始解决⼦问题，从物品 2 开始
 for (let i = 1; i < length; i++) {
 for (let j = 0; j <= C; j++) {
 // 这⾥求解⼦问题，分别为不放当前物品和放当前物品
 // 先求不放当前物品的背包总价值，这⾥的值也就是对应表格中上⼀⾏对应的值
 array[i][j] = array[i - 1][j]
 // 判断当前剩余容量是否可以放⼊当前物品
 if (j >= w[i]) {
 // 可以放⼊的话，就⽐⼤⼩
 // 放⼊当前物品和不放⼊当前物品，哪个背包总价值⼤
 array[i][j] = Math.max(array[i][j], v[i] + array[i - 1][j -
w[i]])
 }
 }
 }
 return array[length - 1][C]
}
数字 0 3 4 17 2 8 6 10
⻓度 1 2 3 4 2 4 4 5
通过以上表格可以很清晰的发现⼀个规律，找出刚好⽐当前数字⼩的数，并且在⼩的数组成
的⻓度基础上加⼀。
这个问题的动态思路解法很简单，直接上代码
字符串相关
在字符串相关算法中，Trie 树可以解决解决很多问题，同时具备良好的空间和时间复杂度，⽐
如以下问题
词频统计
function lis(n) {
 if (n.length === 0) return 0
 // 创建⼀个和参数相同⼤⼩的数组，并填充值为 1
 let array = new Array(n.length).fill(1)
 // 从索引 1 开始遍历，因为数组已经所有都填充为 1 了
 for (let i = 1; i < n.length; i++) {
 // 从索引 0 遍历到 i
 // 判断索引 i 上的值是否⼤于之前的值
 for (let j = 0; j < i; j++) {
 if (n[i] > n[j]) {
 array[i] = Math.max(array[i], 1 + array[j])
 }
 }
 }
 let res = 1
 for (let i = 0; i < array.length; i++) {
 res = Math.max(res, array[i])
 }
 return res
}
前缀匹配
如果你对于 Trie 树还不怎么了解，可以前往 这⾥ 阅读
Git 章节
本⽂不会介绍 Git 的基本操作，会对⼀些⾼级操作进⾏说明。
Rebase 合并
该命令可以让和 merge 命令得到的结果基本是⼀致的。
通常使⽤ merge 操作将分⽀上的代码合并到 master 中，分⽀样⼦如下所示
使⽤ rebase 后，会将 develop 上的 commit 按顺序移到 master 的第三个 commit 后
⾯，分⽀样⼦如下所示
Rebase 对⽐ merge，优势在于合并后的结果很清晰，只有⼀条线，劣势在于如果⼀旦出现冲
突，解决冲突很麻烦，可能要解决多个冲突，但是 merge 出现冲突只需要解决⼀次。
使⽤ rebase 应该在需要被 rebase 的分⽀上操作，并且该分⽀是本地分⽀。如果 develop
分⽀需要 rebase 到 master 上去，那么应该如下操作
stash
stash ⽤于临时保存⼯作⽬录的改动。开发中可能会遇到代码写⼀半需要切分⽀打包的问
题，如果这时候你不想 commit 的话，就可以使⽤该命令。
使⽤该命令可以暂存你的⼯作⽬录，后⾯想恢复⼯作⽬录，只需要使⽤
这样你之前临时保存的代码⼜回来了
reflog
reflog 可以看到 HEAD 的移动记录，假如之前误删了⼀个分⽀，可以通过 git reflog 看
到移动 HEAD 的哈希值
从图中可以看出，HEAD 的最后⼀次移动⾏为是 merge 后，接下来分⽀ new 就被删除了，
那么我们可以通过以下命令找回 new 分⽀
## branch develop
git rebase master
git checkout master
## ⽤于将 `master` 上的 HEAD 移动到最新的 commit
git merge develop
git stash
git stash pop
git checkout 37d9aca
git checkout -b new
PS： reflog 记录是时效的，只会保存⼀段时间内的记录。
Reset
如果你想删除刚写的 commit，就可以通过以下命令实现
但是 reset 的本质并不是删除了 commit，⽽是重新设置了 HEAD 和它指向的 branch。
职业章节
你是否时常会焦虑时间过的很快，没时间学习，本⽂将会分享⼀些个⼈的⻅解。
花时间补基础，读⽂档
在⼯作中我们时常会花很多时间去 debug，但是你是否发现很多问题最终只是你基础不扎实
或者⽂档没有仔细看。
基础是你技术的基⽯，⼀定要花时间打好基础，⽽不是追各种新的技术。⼀旦你的基础扎
实，学习各种新的技术也肯定不在话下，因为新的技术，究其根本都是相通的。
⽂档同样也是⼀⻔技术的基础。⼀个优秀的库，开发⼈员肯定已经把如何使⽤这个库都写在
⽂档中了，仔细阅读⽂档⼀定会是少写 bug 的最省事路⼦。
学会搜索
如果你还在使⽤百度搜索编程问题，请尽快抛弃这个垃圾搜索引擎。同样⼀个关键字，使⽤
百度和⾕歌，⾕歌基本完胜的。即使你使⽤中⽂在⾕歌中搜索，得到的结果也往往是⾕歌占
优，所以如果你想迅速的通过搜索引擎来解决问题，那⼀定是⾕歌。
git reset --hard HEAD^
学点英语
说到英语，⼀定是⼤家所最不想听的。其实我⼀直认为程序员学习英语是简单的，因为我们
⼯作中是⼀直接触着英语，并且看懂技术⽂章，⽂档所需要的单词量是极少的。我时常在群
⾥看到⼤家发出⼀个问题的截图问什么原因，其实在截图中英语已经很明⽩的说明了问题的
所在，如果你的英语过关，完全不需要浪费时间来提问和搜索。所以我认为学点英语也是节
省时间中很重要的⼀点。
那么如何去学习呢，chrome 装个翻译插件，直接拿英⽂⽂档或⽂章读，不会的就直接划词翻
译，然后记录下这个单词并背诵。每天花半⼩时看点英⽂⽂档和⽂章，坚持两个⽉，你的英
语⽔平不说别的，看⽂档和⽂章绝对不会有难题了。这⼀定是⼀个很划算的个⼈时间投资，
花点时间学习英语，能为你将来的技术之路铺平很多坎。
画个图，想⼀想再做
你是否遇到过这种问题，需求⼀下来，看⼀眼，然后⻢上就按照设计稿开始做了，可能中间
出个问题导致你需要返⼯。
如果你存在这样的问题，我很推荐在看到设计稿和需求的时候花点时间想⼀想，画⼀画。考
虑⼀下设计稿中是否可以找到可以拆分出来的复⽤组件，是否存在之前写过的组件。该如何
组织这个界⾯，数据的流转是怎么样的。然后画⼀下这个⻚⾯的需求，最后再动⼿做。
利⽤好下班时间学习
说到下班时间，那可能就有⼈说了公司很迟下班，这其实是国内很普遍的情况。但是我认为
正常的加班是可以的，但是强制的加班就是在损耗你的身体和前途。
可以这么说，⼤部分的 996 公司，加班的这些时间并不会增加你的技术，⽆⾮就是在写⼀些
重复的业务逻辑。也许你可以拿到更多的钱，但是代价是身体还有前途。程序员是靠技术吃
饭的，如果你⻓久呆在⼀个⻓时间加班的公司，不能增⻓你的技术还要吞噬你的下班学习时
间，那么你⼀定会废掉的。如果你遇到了这种情况，只能推荐尽快跳槽到⾮ 996 的公司。
那么如果你有⾜够的下班时间，⼀定要花上 1， 2 ⼩时去学习，上班⼤家基本都⼀样，技术
的精进就是看下班以后的那⼏个⼩时了。如果你能利⽤好下班时间来学习，坚持下去，时间
⼀定会给你很好的答复。
列好 ToDo
我喜欢规划好⼀段时间内要做的事情，并且要把事情拆分为⼩点。给 ToDo 列好优先级，紧急
的优先级最⾼。相同优先级的我喜欢先做简单的，因为这样⼀旦完成就能划掉⼀个，提⾼成
就感。
反思和整理
每周末都会花上点时间整理下本周记录的笔记和看到的不错⽂章。然后考虑下本周完成的⼯
作和下周准备要完成的⼯作。
              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://coderdml.github.io/post/tostring-fang-fa-he-valueof-fang-fa-yi-ji-symboltoprimitive-fang-fa-de-xue-xi/">
              <h3 class="post-title">
                toString方法和valueOf方法以及Symbol.toPrimitive方法的学习
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://coderdml.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
