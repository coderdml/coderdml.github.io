<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://coderdml.github.io</id>
    <title>多巴胺正在摧毁你的自律</title>
    <updated>2023-04-16T01:03:35.866Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://coderdml.github.io"/>
    <link rel="self" href="https://coderdml.github.io/atom.xml"/>
    <subtitle>沃尔夫冈正在撕裂永恒领域</subtitle>
    <logo>https://coderdml.github.io/images/avatar.png</logo>
    <icon>https://coderdml.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, 多巴胺正在摧毁你的自律</rights>
    <entry>
        <title type="html"><![CDATA[面试实录]]></title>
        <id>https://coderdml.github.io/post/mian-shi-shi-lu/</id>
        <link href="https://coderdml.github.io/post/mian-shi-shi-lu/">
        </link>
        <updated>2023-04-14T11:13:38.000Z</updated>
        <content type="html"><![CDATA[<p>本次面试笔记，需要面试可向我预约哔哩哔哩，需发布视频在哔哩哔哩。如果想要&lt;从准备简历、八股文准备、项目经历准备、面试、面经、面经解答、主观问题答复、谈薪再到入职的一条龙服务&gt;且不发布哔哩哔哩，可查看 https://q.shanyue.tech/train/interview.html 页面或向我咨询。</p>
<ul>
<li>盒子模型</li>
<li>flex
<ul>
<li>左固定，右适应</li>
<li><code>flex-basis: 300px</code> ❎</li>
</ul>
</li>
<li>事件循环
<ul>
<li>宏任务/微任务</li>
</ul>
</li>
<li>闭包
<ul>
<li>场景</li>
<li>IIFE</li>
<li>防抖节流</li>
</ul>
</li>
<li>Promise 顺序
<ul>
<li>https://q.shanyue.tech/roadmap/javascript.html</li>
</ul>
</li>
<li>ts
<ul>
<li>类型推断</li>
</ul>
</li>
<li>vue/react
<ul>
<li>可复用基础组件
<ul>
<li>按钮</li>
<li>列表</li>
</ul>
</li>
</ul>
</li>
<li>axios 封装
<ul>
<li>请求头
<ul>
<li>content-type</li>
<li>www-form-url-encoded/application/json</li>
</ul>
</li>
</ul>
</li>
<li>http
<ul>
<li>301/302</li>
<li>307/308 ❎</li>
<li>预检请求 options ❎</li>
<li>跨域
<ul>
<li>cors ❎</li>
</ul>
</li>
<li>强缓存和协商缓存 ❎</li>
</ul>
</li>
<li>使用 Hook 对部分组件性能优化
<ul>
<li>useCallback</li>
<li>React.memo</li>
<li>useDebounce</li>
<li>useWorker</li>
</ul>
</li>
<li>使用 RTK 模块化状态管理
<ul>
<li>rtk</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题整理---js]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-zheng-li-js/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-zheng-li-js/">
        </link>
        <updated>2023-04-10T04:59:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>延迟加载JS有哪些方式？</strong><br>
<strong>JS微任务和宏任务</strong><br>
<strong>JS判断变量是不是数组，你能写出哪些方法？</strong><br>
<strong>JS数组去重</strong><br>
<strong>找出多维数组最大值</strong><br>
** 给字符串新增方法实现功能给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前缀的字符串，例如：console.log( 'world'.addPrefix('hello') ) 控制台会输出helloworld**<br>
解答：</p>
<pre><code>String.prototype.addPrefix = function(str){
	return str  + this;
}
console.log( 'world'.addPrefix('hello') )
</code></pre>
<p><strong>找出字符串出现最多次数的字符以及次数</strong></p>
<pre><code>var str = 'aaabbbbbccddddddddddx';
var obj = {};
for(var i=0;i&lt;str.length;i++){
	var char = str.charAt(i);
	if( obj[char] ){
		obj[char]++;
	}else{
		obj[char] = 1;
	}
}
console.log( obj );
//统计出来最大值
var max = 0;
for( var key in obj ){
	if( max &lt; obj[key] ){
		max = obj[key];
	}
}
//拿最大值去对比
for( var key in obj ){
	if( obj[key] == max ){
		console.log('最多的字符是'+key);
		console.log('出现的次数是'+max);
	}
}
</code></pre>
<p><strong>indexOf</strong><br>
https://blog.csdn.net/qq_44603011/article/details/122622083?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168048282316800188560166%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168048282316800188560166&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduend~default-1-122622083-null-null.142<sup>v80</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=js%20.indexOf&amp;spm=1018.2226.3001.4187</p>
<p>https://blog.csdn.net/weixin_40013817/article/details/103182967?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=instanceof&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduweb~default-0-103182967.142<sup>v74</sup>pc_new_rank,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;spm=1018.2226.3001.4187</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题整理---css]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-zheng-li-css/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-zheng-li-css/">
        </link>
        <updated>2023-04-10T03:07:39.000Z</updated>
        <content type="html"><![CDATA[<p>** 介绍一下CSS的盒子模型 **<br>
https://blog.csdn.net/weixin_44992737/article/details/125217906?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109608916800225589165%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168109608916800225589165&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduend~default-2-125217906-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B&amp;spm=1018.2226.3001.4187<br>
** height和line-height的区别 **<br>
https://blog.csdn.net/apple_51491580/article/details/113737855?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109751716800217214916%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168109751716800217214916&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduend~default-2-113737855-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=line-height%E5%92%8Cheigh%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187</p>
<p>**flex布局 **</p>
<p><strong>CSS选择符有哪些？哪些属性可以继承？</strong><br>
<strong>CSS优先级算法如何计算？</strong><br>
<strong>用CSS画一个三角形</strong><br>
<strong>一个盒子不给宽度和高度如何水平垂直居中？</strong><br>
<strong>display有哪些值？说明他们的作用。</strong><br>
<strong>对BFC规范(块级格式化上下文：block formatting context)的理解？</strong><br>
<strong>清除浮动有哪些方式？</strong><br>
<strong>在网页中的应该使用奇数还是偶数的字体？为什么呢？</strong><br>
<strong>position有哪些值？分别是根据什么定位的？</strong><br>
<strong>写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。</strong><br>
<strong>什么是CSS reset？</strong><br>
<strong>css sprite是什么,有什么优缺点</strong><br>
<strong>display: none;与visibility: hidden;的区别</strong><br>
<strong>opacity 和 rgba区别</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题整理--html部分]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-zheng-li-html-bu-fen/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-zheng-li-html-bu-fen/">
        </link>
        <updated>2023-04-10T02:53:29.000Z</updated>
        <content type="html"><![CDATA[<p>** 1.行内元素 块级元素 空元素有哪些 **<br>
https://blog.csdn.net/qq_51066068/article/details/124308736?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109516216800186594269%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168109516216800186594269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>first_rank_ecpm_v1~rank_v31_ecpm-1-124308736-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=%E9%9D%A2%E8%AF%95%20%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%20%E7%A9%BA%28void%29%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F&amp;spm=1018.2226.3001.4187<br>
** CSS引入的方式有哪些？使用Link和@import有什么区别？ **<br>
https://blog.csdn.net/qq_51066068/article/details/124424654?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109533116800217236960%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168109533116800217236960&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>first_rank_ecpm_v1~rank_v31_ecpm-2-124424654-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8link%E5%92%8C%40import%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F&amp;spm=1018.2226.3001.4187<br>
** title与h1的区别、b与strong的区别、i与em的区别？ **<br>
https://blog.csdn.net/qq_45937484/article/details/124620153?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109538416782425116121%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168109538416782425116121&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduend~default-1-124620153-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F&amp;spm=1018.2226.3001.4187<br>
** title与h1的区别、b与strong的区别、i与em的区别？ **<br>
https://blog.csdn.net/qq_45937484/article/details/124620153?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109538416782425116121%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168109538416782425116121&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduend~default-1-124620153-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F&amp;spm=1018.2226.3001.4187<br>
<strong>gif jpg png webp</strong><br>
https://blog.csdn.net/CKT0816/article/details/104804540?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=png%E3%80%81jpg%E3%80%81gif%20%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduweb~default-0-104804540.nonecase&amp;spm=1018.2226.3001.4187</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题整理]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-zheng-li/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-zheng-li/">
        </link>
        <updated>2023-04-10T02:53:29.000Z</updated>
        <content type="html"><![CDATA[<p>** 1.行内元素 块级元素 空元素有哪些 **<br>
https://blog.csdn.net/qq_51066068/article/details/124308736?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109516216800186594269%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168109516216800186594269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>first_rank_ecpm_v1~rank_v31_ecpm-1-124308736-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=%E9%9D%A2%E8%AF%95%20%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%20%E7%A9%BA%28void%29%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F&amp;spm=1018.2226.3001.4187<br>
** CSS引入的方式有哪些？使用Link和@import有什么区别？ **<br>
https://blog.csdn.net/qq_51066068/article/details/124424654?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109533116800217236960%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168109533116800217236960&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>first_rank_ecpm_v1~rank_v31_ecpm-2-124424654-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8link%E5%92%8C%40import%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F&amp;spm=1018.2226.3001.4187<br>
** title与h1的区别、b与strong的区别、i与em的区别？ **<br>
https://blog.csdn.net/qq_45937484/article/details/124620153?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109538416782425116121%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168109538416782425116121&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduend~default-1-124620153-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F&amp;spm=1018.2226.3001.4187<br>
** title与h1的区别、b与strong的区别、i与em的区别？ **<br>
https://blog.csdn.net/qq_45937484/article/details/124620153?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168109538416782425116121%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168109538416782425116121&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>sobaiduend~default-1-124620153-null-null.142<sup>v82</sup>insert_down38,201<sup>v4</sup>add_ask,239<sup>v2</sup>insert_chatgpt&amp;utm_term=title%E4%B8%8Eh1%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%E4%B8%8Eem%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F&amp;spm=1018.2226.3001.4187</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[axios网络请求]]></title>
        <id>https://coderdml.github.io/post/axios-wang-luo-qing-qiu/</id>
        <link href="https://coderdml.github.io/post/axios-wang-luo-qing-qiu/">
        </link>
        <updated>2023-04-07T22:24:26.000Z</updated>
        <content type="html"><![CDATA[<p>axios的安装</p>
<p>axios请求参数</p>
<p>axios的all方法</p>
<p>axios.all中的axios.spread的使用</p>
<p>axios的全局配置</p>
<p>常见配置属性<br>
<img src="https://coderdml.github.io/post-images/1680906891177.png" alt="" loading="lazy"></p>
<p>axios的实例和模块封装</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题2]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-2/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-2/">
        </link>
        <updated>2023-04-05T03:41:56.000Z</updated>
        <content type="html"><![CDATA[<p>一、CSS<br>
1.说一下CSS的盒模型。<br>
在HTML页面中的所有元素都可以看成是一个盒子<br>
盒子的组成：内容content、内边距padding、边框border、外边距margin<br>
盒模型的类型：<br>
标准盒模型<br>
margin + border + padding + content<br>
IE盒模型<br>
margin + content(border + padding)<br>
控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）;<br>
2.CSS选择器的优先级？<br>
CSS的特性：继承性、层叠性、优先级<br>
优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式<br>
标签、类/伪类/属性、全局选择器、行内样式、id、!important<br>
!important &gt; 行内样式 &gt; id &gt; 类/伪类/属性 &gt; 标签 &gt; 全局选择器<br>
3.隐藏元素的方法有哪些？<br>
display:none;<br>
元素在页面上消失，不占据空间<br>
opacity:0;<br>
设置了元素的透明度为0，元素不可见，占据空间位置<br>
visibility:hidden;<br>
让元素消失，占据空间位置，一种不可见的状态<br>
position:absolute;<br>
clip-path<br>
4.px和rem的区别是什么？<br>
px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度<br>
rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;<br>
1rem = 10px; （16px*62.5%=10px）<br>
5.重绘重排有什么区别？<br>
重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小<br>
重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制<br>
浏览器的渲染机制<br>
对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排<br>
对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘<br>
6.让一个元素水平垂直居中的方式有哪些？<br>
1.定位+margin<br>
2.定位+transform<br>
3.flex布局<br>
4.grid布局<br>
5.table布局<br>
7.CSS的哪些属性哪些可以继承？哪些不可以继承？<br>
CSS的三大特性：继承、层叠、优先级<br>
子元素可以继承父类元素的样式<br>
1.字体的一些属性：font<br>
2.文本的一些属性：line-height<br>
3.元素的可见性：visibility:hidden<br>
4.表格布局的属性：border-spacing<br>
5.列表的属性：list-style<br>
6.页面样式属性：page<br>
7.声音的样式属性<br>
8.有没有用过预处理器？<br>
预处理语言增加了变量、函数、混入等强大的功能<br>
SASS  LESS</p>
<p>二、JavaSscipt<br>
1.JS由哪三部分组成？<br>
ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串），<br>
文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档<br>
浏览器对象模型（BOM）：对浏览器窗口进行访问和操作<br>
2.JS有哪些内置对象？<br>
String Boolean Number Array Object Function Math Date RegExp...<br>
Math<br>
abs() sqrt() max() min()<br>
Data<br>
new Data() getYear()<br>
Array<br>
String<br>
concat() length  slice() split()<br>
3.操作数组的方法有哪些？<br>
push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter()<br>
ervery() some() reduce() isArray() findIndex()<br>
哪些方法会改变原数组？<br>
push() pop() unshift() shift() sort() reverse() splice()<br>
4.JS对数据类的检测方式有哪些？<br>
typeof()<br>
instanceof()<br>
constructor<br>
Object.prototype.toString.call()<br>
5.说一下闭包，闭包有什么特点？<br>
什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包<br>
特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存再内存中，不会被垃圾回收机制回收<br>
缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏<br>
使用场景：防抖，节流，函数嵌套函数避免全局污染的时候<br>
6.前端的内存泄漏怎么理解？<br>
JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。<br>
垃圾回收机制<br>
因素：一些为生命直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。<br>
7.事件委托是什么？<br>
又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上<br>
如果子元素组织了事件冒泡，那么委托也就不成立<br>
组织事件冒泡：event.stopPropagation()<br>
addEventListener('click',函数名，true/false) 默认是false（事件冒泡），true（事件捕获）<br>
好处：提高性能，减少事件的绑定，也就减少了内存的占用。<br>
8.基本数据类型和引用数据类型的区别？<br>
基本数据类型：String Number Boolean undefined null<br>
基本数据类型保存在栈内存当中，保存的就是一个具体的值<br>
引用数据类型（复杂数据类型）：Object Function Array<br>
保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址<br>
假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变<br>
9.说一下原型链。<br>
原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象<br>
使用prototype可以把方法挂在原型上，内存值保存一份<br>
__proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）<br>
10.new操作符具体做了什么？<br>
1.先创建一个空对象<br>
2.把空对象和构造函数通过原型链进行链接<br>
3.把构造函数的this绑定到新的空对象身上<br>
4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型<br>
11.JS是如何实现继承的？<br>
1.原型链继承<br>
2.借用构造函数继承<br>
3.组合式继承<br>
4.ES6的class类继承<br>
12.JS的设计原理是什么？<br>
JS引擎 运行上下文 调用栈 事件循环 回调<br>
13.JS中关于this指向的问题<br>
1. 全局对象中的this指向<br>
指向的是window<br>
2. 全局作用域或者普通函数中的this<br>
指向全局window<br>
3. this永远指向最后调用它的那个对象<br>
在不是箭头函数的情况下<br>
4. new 关键词改变了this的指向<br>
5. apply,call,bind<br>
可以改变this指向，不是箭头函数<br>
6. 箭头函数中的this<br>
它的指向在定义的时候就已经确定了<br>
箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window<br>
7. 匿名函数中的this<br>
永远指向了window,匿名函数的执行环境具有全局性，因此this指向window<br>
14.script标签里的async和defer有什么区别？<br>
当没有async和defer这两个属性的时候，<br>
浏览器会立刻加载并执行指定的脚本<br>
有async<br>
加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）<br>
有defer<br>
加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要等<br>
所有元素解析完成之后才会执行<br>
15.setTimeout最小执行时间是多少？<br>
HTML5规定的内容：<br>
setTimeout最小执行时间是4ms<br>
setInterval最小执行时间是10ms<br>
16.ES6和ES5有什么区别？<br>
JS的组成：ECMAScript BOM  DOM<br>
ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009<br>
ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准<br>
17.ES6的新特性有哪些？<br>
1.新增块级作用域（let,const）<br>
不存在变量提升<br>
存在暂时性死区的问题<br>
块级作用域的内容<br>
不能在同一个作用域内重复声明<br>
2.新增了定义类的语法糖（class）<br>
3.新增了一种基本数据类型（symbol）<br>
4.新增了解构赋值<br>
从数组或者对象中取值，然后给变量赋值<br>
5.新增了函数参数的默认值<br>
6.给数组新增了API<br>
7.对象和数组新增了扩展运算符<br>
8.Promise<br>
解决回调地狱的问题。<br>
自身有all,reject,resolve,race方法<br>
原型上有then,catch<br>
把异步操作队列化<br>
三种状态：pending初始状态,fulfilled操作成功,rejected操作失败<br>
状态：pending -&gt; fulfilled;pending -&gt; rejected 一旦发生，状态就会凝固，不会再变<br>
async  await<br>
同步代码做异步的操作，两者必须搭配使用<br>
async表明函数内有异步操作，调用函数会返回promise<br>
await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用<br>
await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行</p>
<pre><code>    9.新增了模块化（import,export）
    10.新增了set和map数据结构
        set就是不重复
        map的key的类型不受限制
    11.新增了generator
    12.新增了箭头函数
        不能作为构造函数使用，不能用new
        箭头函数就没有原型
        箭头函数没有arguments
        箭头函数不能用call,apply,bind去改变this的执行
        this指向外层第一个函数的this
18.call,aply,bind三者有什么区别？
    都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同
    call方法传的是一个参数列表
    apply传递的是一个数组
    bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()
    call方法的性能要比apply好一些，所以call用的更多一点
19.用递归的时候有没有遇到什么问题？
    如果一个函数内可以调用函数本身，那么这个就是递归函数
    函数内部调用自己
    特别注意：写递归必须要有退出条件return
20.如何实现一个深拷贝？
    深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响
    主要针对的是引用数据类型
    1.扩展运算符
    2.JSON.parse(JSON.stringify())
    3.利用递归函数实现
21.说一下事件循环。
    JS是一个单线程的脚本语言
    主线程 执行栈 任务队列  宏任务 微任务
    主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务
    全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！
22.ajax是什么？怎么实现的？
    创建交互式网页应用的网页开发技术
        在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容
    通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面
    1.创建XmlHttpRequest对象 xmh
    2.通过xmh对象里的open()方法和服务器建立连接
    3.构建请求所需的数据，并通过xmh对象的send()发送给服务器
    4.通过xmh对象的onreadystate chansge事件监听服务器和你的通信状态
    5.接收并处理服务器响应的数据结果
    6.把处理的数据更新到HTML页面上
23.get和post有什么区别？
    1.get一般是获取数据，post一般是提交数据
    2.get参数会放在url上，所以安全性比较差，post是放在body中
    3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据
    4.get请求时会被缓存,post请求不会被缓存
    5.get请求会被保存在浏览器历史记录中,post不会
    6.get请求只能进行url编码，post请求支持很多种
24.promise的内部原理是什么？它的优缺点是什么？
    Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果
    Promise主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，
    就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差
    有三种状态：pending初始状态  fulfilled成功状态  rejected失败状态
    状态改变只会有两种情况，
        pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变
    首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消
    如果不设置回调，promise内部抛出的测u哦呜就无法反馈到外面
    若当前处于pending状态时，无法得知目前在哪个阶段。
    原理：
        构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一个是reject
        promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数
25.promise和async await的区别是什么？
    1.都是处理异步请求的方式
    2.promise是ES6，async await 是ES7的语法
    3.async await是基于promise实现的，他和promise都是非阻塞性的
    优缺点：
    1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常
    2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作
    promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作
26.浏览器的存储方式有哪些？
    1.cookies
        H5标准前的本地存储方式
        兼容性好，请求头自带cookie
        存储量小，资源浪费，使用麻烦（封装）
    2.localstorage
        H5加入的以键值对为标准的方式
        操作方便，永久存储，兼容性较好
        保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫
    3.sessionstorage
        当前页面关闭后就会立刻清理，会话级别的存储方式
    4.indexedDB
        H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景
27.token存在sessionstorage还是loaclstorage？
    token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串
    1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台
    2.存cookie中，会自动发送，缺点就是不能跨域
    如果存在localstorage中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊
    如果存在cookie中会有CSRF攻击
28.token的登录流程。
    1.客户端用账号密码请求登录
    2.服务端收到请求后，需要去验证账号密码
    3.验证成功之后，服务端会签发一个token，把这个token发送给客户端
    4.客户端收到token后保存起来，可以放在cookie也可以是localstorage
    5.客户端每次向服务端发送请求资源的时候，都需要携带这个token
    6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据
29.页面渲染的过程是怎样的？
    DNS解析
    建立TCP连接
    发送HTTP请求
    服务器处理请求
    渲染页面
        浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树
        再把CSS解析成CSSOM
        把DOM和CSSOM合并为渲染树
        布局
        把渲染树的每个节点渲染到屏幕上（绘制）
    断开TCP连接
30.DOM树和渲染树有什么区别？
    DOM树是和HTML标签一一对应的，包括head和隐藏元素
    渲染树是不包含head和隐藏元素
31.精灵图和base64的区别是什么？
    精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度
    base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串
    base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。
32.svg格式了解多少？
    基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真
    1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作
        &lt;svg&gt;&lt;/svg&gt;
    2.SVG可作为文件被引入
        &lt;img src=&quot;pic.svg&quot; /&gt;
    3.SVG可以转为base64引入页面
33.了解过JWT吗？
    JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输
    信息传输、授权
    JWT的认证流程
    1.前端把账号密码发送给后端的接口
    2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。
    3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内
    4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）
    5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果
    简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。
34.npm的底层环境是什么？
    node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境
    npm的组成：网站、注册表、命令行工具
35.HTTP协议规定的协议头和请求头有什么？
    1.请求头信息：
        Accept:浏览器告诉服务器所支持的数据类型
        Host:浏览器告诉服务器我想访问服务器的哪台主机
        Referer:浏览器告诉服务器我是从哪里来的（防盗链）
        User-Agent:浏览器类型、版本信息
        Date:浏览器告诉服务器我是什么时候访问的
        Connection:连接方式
        Cookie
        X-Request-With:请求方式
    2.响应头信息：
        Location:这个就是告诉浏览器你要去找谁
        Server:告诉浏览器服务器的类型
        Content-Type:告诉浏览器返回的数据类型
        Refresh:控制了的定时刷新
36.说一下浏览器的缓存策略。
    强缓存（本地缓存）、协商缓存（弱缓存）
    强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能
    协缓：需要像后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容
    强缓存的触发：
        HTTP1.0:时间戳响应标头
        HTTP1.1:Cache-Control响应标头
    协商缓存触发：
        HTTP1.0:请求头：if-modified-since 响应头：last-modified
        HTTP1.1:请求头：if-none-match 响应头：Etag
37.说一下什么是“同源策略”？
    http:// www.  aaa.com:8080/index/vue.js
    协议    子域名 主域名  端口号     资源
    同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击
    主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域
    三个允许跨域加载资源的标签：img  link  script
    跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！
    JSONP
    CORS
    websocket
    反向代理
38.防抖和节流是什么？
    都是应对页面中频繁触发事件的优化方案
    防抖:避免事件重复触发
    使用场景:1.频繁和服务端交互 2.输入框的自动保存事件
    节流:把频繁触发的事件减少,每隔一段时间执行
    使用场景:scroll事件
39.解释一下什么是json？
    JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输
    JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中
    JS提供了JSON.parse() JSON.stringify()
    什么时候使用json：定义接口；序列化；生成token；配置文件package.json
40.当数据没有请求过来的时候，该怎么做？
    可以在渲染数据的地方给一些默认的值
    if判断语句
41.有没有做过无感登录？
    1.在相应其中拦截，判断token返回过期后，调用刷新token的接口
    2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口
    3.写定时器，定时刷新token接口
    流程：
        1.登录成功后保存token 和 refresh_token
        2.在响应拦截器中对401状态码引入刷新token的api方法调用
        3.替换保存本地新的token
        4.把错误对象里的token替换
        5.再次发送未完成的请求
        6.如果refresh_token过期了，判断是否过期，过期了就清楚所有token重新登录
42.大文件上传是怎么做的？
    分片上传：
        1.把需要上传的文件按照一定的规则，分割成相同大小的数据块
        2.初始化一个分片上传任务，返回本次分片上传的唯一标识
        3.按照一定的规则把各个数据块上传
        4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件
    断点续传：
        服务端返回，从哪里开始  浏览器自己处理
</code></pre>
<p>三、HTML5CSS3<br>
1.语义化的理解。<br>
在写HTML页面结构时所用的标签有意义<br>
头部用head  主体用main  底部用foot...<br>
怎么判断页面是否语义化了？<br>
把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常<br>
为什么要选择语义化？<br>
1.让HTML结构更加清晰明了<br>
2.方便团队协作，利于开发<br>
3.有利于爬虫和SEO<br>
4.能够让浏览器更好的去解析代码<br>
5.给用户带来良好的体验<br>
2.H5C3有哪些新特性？<br>
H5的新特性：<br>
1.语义化的标签<br>
2.新增音频视频<br>
3.画布canvas<br>
4.数据存储localstorage sessionstorage<br>
5.增加了表单控件 email url search...<br>
6.拖拽释放API<br>
CSS3的新特性：<br>
1.新增选择器：属性选择器、伪类选择器、伪元素选择器<br>
2.增加了媒体查询<br>
3.文字阴影<br>
4.边框<br>
5.盒子模型box-sizing<br>
6.渐变<br>
7.过度<br>
8.自定义动画<br>
9.背景的属性<br>
10.2D和3D<br>
3.rem是如何做适配的？<br>
rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配<br>
rem是根据根元素font-size计算值的倍数<br>
比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem = 16px*1.2 = 19.2px.<br>
4.解决了哪些移动端的兼容问题？<br>
1.当设置样式overflow:scroll/auto时，IOS上的华东会卡顿<br>
-webkit-overflow-scrolling:touch;<br>
2.在安卓环境下placeholder文字设置行高时会偏上<br>
input有placeholder属性的时候不要设置行高<br>
3.移动端字体小于12px时异常显示<br>
应该先把在整体放大一倍，然后再用transform进行缩小<br>
4.ios下input按钮设置了disabled属性为true显示异常<br>
input[typy=button]{<br>
opcity:1<br>
}<br>
5.安卓手机下取消语音输入按钮<br>
input::-webkit-input-speech-button{<br>
display:none<br>
}<br>
6.IOS下取消input输入框在输入引文首字母默认大写<br>
<input autocapitalize='off' autocorrect='off'/><br>
7.禁用IOS和安卓用户选中文字<br>
添加全局CSS样式：-webkit-user-select:none<br>
8.禁止IOS弹出各种窗口<br>
-webkit-touch-callout:none<br>
9.禁止IOS识别长串数字为电话<br>
添加meta属性 <meta conten='telephone=no' name='format-detection'></p>
<p>四、Vue<br>
1.v-if和v-show的区别？<br>
都可以控制元素的显示和隐藏<br>
1.v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除<br>
2.v-if有一个局部编译/卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换<br>
3.v-if才是真正的条件渲染；v-show从false变成true的时候不会触发组件的声明周期，v-if会触发声明周期<br>
4.v-if的切换效率比较低  v-show的效率比较高<br>
2.如何理解MVVM的？<br>
是Model-View-ViewModel的缩写。前端开发的架构模式<br>
M：模型，对应的就是data的数据<br>
V：视图，用户界面，DOM<br>
VM：视图模型：Vue的实例对象，连接View和Model的桥梁<br>
核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定<br>
ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理<br>
3.v-for中的key值的作用是什么？<br>
key属性是DOM元素的唯一标识<br>
作用：<br>
1.提高虚拟DOM的更新<br>
2.若不设置key，可能会触发一些bug<br>
3.为了触发过度效果<br>
4.说一下你对vue生命周期的理解。<br>
组件从创建到销毁的过程就是它的生命周期<br>
创建<br>
beforeCreat<br>
在这个阶段属性和方法都不能使用<br>
created<br>
这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图<br>
挂载<br>
beforeMount<br>
完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated<br>
Mounted<br>
把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点<br>
更新<br>
beforeUpdate<br>
组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据<br>
updated<br>
render重新做了渲染，这时数据和页面都是新的，避免在此更新数据<br>
销毁<br>
beforeDestroy<br>
实例销毁前，在这里实例还可以用，可以清楚定时器等等<br>
destroyed<br>
组件已经被销毁了，全部都销毁<br>
使用了keep-alive时多出两个周期：<br>
activited<br>
组件激活时<br>
deactivited<br>
组件被销毁时<br>
5.在created和mounted去请求数据，有什么区别？<br>
created：在渲染前调用，通常先初始化属性，然后做渲染<br>
mounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作<br>
在这里请求数据可能会出现闪屏的问题，created里不会<br>
一般用created比较多<br>
请求的数据对DOM有影响，那么使用created<br>
如果请求的数据对DOM无关，可以放在mounted<br>
6.vue中的修饰符有哪些？<br>
1.事件修饰符<br>
.stop       组织冒泡<br>
.prevent    组织默认行为<br>
.capture    内部元素触发的事件先在次处理<br>
.self       只有在event.target是当前元素时触发<br>
.once       事件只会触发一次<br>
.passive    立即触发默认行为<br>
.native     把当前元素作为原生标签看待<br>
2.按键修饰符<br>
.keyup      键盘抬起<br>
.keydown    键盘按下<br>
3.系统修饰符<br>
.ctrl<br>
.alt<br>
.meta<br>
4.鼠标修饰符<br>
.left       鼠标左键<br>
.right      鼠标右键<br>
.middle     鼠标中键<br>
5.表单修饰符<br>
.lazy       等输入完之后再显示<br>
.trim       删除内容前后的空格<br>
.number     输入是数字或转为数字<br>
7.elementui是怎么做表单验证的？<br>
1.在表单中加rules属性，然后再data里写校验规则<br>
2.内部添加规则<br>
3.自定义函数校验<br>
8.vue如何进行组件通信？<br>
1.父传子<br>
props<br>
父组件使用自定义属性，然后子组件使用props<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>f</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">册</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">ref
                引用信息会注册在父组件的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">册</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span></span></span></span>refs对象上<br>
2.子传父<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">绑</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">自</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">触</mi><mi mathvariant="normal">发</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">给</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">监</mi><mi mathvariant="normal">听</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mn>3.</mn><mi mathvariant="normal">兄</mi><mi mathvariant="normal">弟</mi><mi mathvariant="normal">传</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>v</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">用</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">和</mi><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">输</mi><mn>4.</mn><mi>v</mi><mi>u</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mn>9.</mn><mi>k</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo>−</mo><mi>a</mi><mi>l</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">什</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">？</mi><mi mathvariant="normal">怎</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">？</mi><mi>V</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">裹</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">候</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">缓</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">活</mi><mi mathvariant="normal">跃</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">销</mi><mi mathvariant="normal">毁</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">态</mi><mi mathvariant="normal">保</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">防</mi><mi mathvariant="normal">止</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">渲</mi><mi mathvariant="normal">染</mi><mi>D</mi><mi>O</mi><mi>M</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">减</mi><mi mathvariant="normal">少</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">载</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">耗</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">提</mi><mi mathvariant="normal">高</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">验</mi><mn>10.</mn><mi>a</mi><mi>x</mi><mi>i</mi><mi>o</mi><mi>s</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">怎</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">做</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">？</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">载</mi><mi mathvariant="normal">创</mi><mi mathvariant="normal">建</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">着</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">请</mi><mi mathvariant="normal">求</mi><mi mathvariant="normal">响</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">拦</mi><mi mathvariant="normal">截</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">抛</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">口</mi><mn>11.</mn><mi>v</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">由</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">怎</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">？</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">参</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">emit
                子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数
        3.兄弟传
            new一个新的vue实例，用on和emit来对数据进行传输
        4.vuex传值
    9.keep-alive是什么？怎么使用？
        Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们
        作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验
    10.axios是怎么做封装的？
        下载 创建实例 接着封装请求响应拦截器  抛出 最后封装接口
    11.vue路由时怎么传参的？
        params传参
            this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">绑</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">触</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">监</span><span class="mord cjk_fallback">听</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord">3</span><span class="mord">.</span><span class="mord cjk_fallback">兄</span><span class="mord cjk_fallback">弟</span><span class="mord cjk_fallback">传</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">输</span><span class="mord">4</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mord">9</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">什</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">？</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">？</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">裹</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">候</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">缓</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">活</span><span class="mord cjk_fallback">跃</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">销</span><span class="mord cjk_fallback">毁</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">切</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">防</span><span class="mord cjk_fallback">止</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">渲</span><span class="mord cjk_fallback">染</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">减</span><span class="mord cjk_fallback">少</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">耗</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">体</span><span class="mord cjk_fallback">验</span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">做</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">？</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">创</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">着</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">请</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">拦</span><span class="mord cjk_fallback">截</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">抛</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">口</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">？</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>router.push({name:'index',params:{id:item.id}})<br>
this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">由</mi><mi mathvariant="normal">属</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">参</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">route.params.id
        路由属性传参
            this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>router.push({name:'/index/<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 11: {item.id}&#039;}̲)
            路…'>{item.id}&#039;})
            路由配置 { path:&#039;/index:id&#039; }
        query传参（可以解决页面刷新参数丢失的问题）
            this.</span>router.push({<br>
name:'index',<br>
query:{id:item.id}<br>
})<br>
12.vue路由的hash模式和history模式有什么区别？<br>
1.hash的路由地址上有#号，history模式没有<br>
2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404<br>
3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API<br>
4.hash不会重新加载页面，单页面应用必备<br>
5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求<br>
6.history需要后台配置<br>
13.路由拦截是怎么实现的？<br>
路由拦截 axios拦截<br>
需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截<br>
{<br>
name:'index',<br>
path:'/index',<br>
component:Index,<br>
meta:{<br>
requirtAuth:true<br>
}<br>
}<br>
router.beforeEach((to,from,next) =&gt; {<br>
if(to.meta.requirtAuth){<br>
if( store.satte.token ){<br>
next()<br>
}else{</p>
<pre><code>            }
        }
    })
14.说一下vue的动态路由。
    要在路由配置里设置meat属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转
    根据用户登录的账号，返回用户角色
    前端再根据角色，跟路由表的meta.role进行匹配
    把匹配搭配的路由形成可访问的路由
15.如何解决刷新后二次加载路由？
    1.window.location.reload()
    2.matcher
        const router = createRouter()
        export function resetRouter(){
            const newRouter = creatRouter()
            router.matcher = newRouter.matcher
        }
16.vuex刷新数据会丢失吗？怎么解决？
    vuex肯定会重新获取数据，页面也会丢失数据
    1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）
    2.页面刷新的时候，再次请求数据，达到可以动态更新的方法
        监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据
17.computed和watch的区别？
    1.computed是计算属性，watch是监听，监听的是data中数据的变化
    2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存
    3.computed不支持异步，watch是可以异步操作
    4.computed是第一次加载就监听，watch是不监听
    5.computed函数中必须有return  watch不用
18.vuex在什么场景会去使用？属性有哪些？
    state       存储变量
    getters     state的计算属性
    mutations   提交更新数据的方法
    actions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作
    modules     模块化vuex
    使用场景：
        用户的个人信息、购物车模块、订单模块
19.vue的双向数据绑定原理是什么？
    通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，
    在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图时同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。
    第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter
    第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图
    第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：
            1.在自身实例化的时候忘订阅器内添加自己
            2.自身要有一个update()方法
            3.等待属性变动时，调用自身的update方法，触发compile这种的回调
    第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果
20.了解diff算法和虚拟DOM吗？
    虚拟DOM，描述元素和元素之间的关系，创建一个JS对象
    如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改
    diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM
    步骤：
        1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面
        2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异
        3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。
21.vue和jquery的区别是什么？
    1.原理不同
        vue就是数据绑定；jq是先获取dom再处理
    2.着重点不同
        vue是数据驱动，jq是着重于页面
    3.操作不同
    4.未来发展不同
22.vuex的响应式处理。
    vuex是vue的状态管理工具
    vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图
    Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。
    vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中
23.vue中遍历全局的方法有哪些？
    1.普通遍历，对象.forEach()
        arr.forEach(function(item,index,arr){
            console.log(item,index)
        })
    2.对元素统一操作  对象.map()
        var newarr = arr.map(function(item){
            return item+1
        })
    3.查找符合条件的元素 对象.filter()
        arr.filter(function(item){
            if(item &gt; 2){
                return false
            }else{
                return true
            }
        })
    4.查询符合条件的元素，返回索引 对象.findindex()
        arr.finindex(function(item){
            if(item&gt;1){
                return true
            }else{
                return false
            }
        })
    对象.evening()  遇到不符合的对象会停止
    对象.some()  找到符合条件的元素就停止
24.如何搭建脚手架？
    下载：node  cnpm  webpack vue-cli
    创建项目：
        1.找到对应的文件，然后利用node指令创建（cmd）
        2.vue init webpack xxxx
        3.回车项目描述
        4.作者回车
        5.选择vue build
        6.回车
        7.输入n
        8.不按照yarn
        9.输入npm run dev
25.如何封装一个组件？
    1.使用Vue.extend()创建一个组件
    2.使用Vue.components()方法注册组件
    3.如果子组件需要数据，可以在props中接收定义
    4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法
    原则：
        把功能拆开
        尽量让组件原子化，一个组件做一件事情
        容器组件管数据，展示组件管视图
26.封装一个可复用的组件，需要满足什么条件？
    1.低耦合，组件之间的依赖越小越好
    2.最好从父级传入信息，不要在公共组件中请求数据
    3.传入的数据要进行校验
    4.处理事件的方法写在父组件中
27.vue的过滤器怎么使用？
    vue的特性，用来对文本进行格式化处理
    使用它的两个地方，一个是插值表达式，一个是v-bind
    分类：
        1.全局过滤器
            Vue.filter('add',function(v){
                return v &lt; 10 ? '0' + v : v
            })
            &lt;div&gt;{{33 | add}}&lt;/div&gt;
        2.本地过滤器
            和methods同级
            filter:{
                add:function(v){
                    return v &lt; 10 ? '0' + v : v
                }
            }
28.vue中如何做强制刷新？
    1.localtion.reload()
    2.this.$router.go(0)
    3.provide和inject
29.vue3和vue2有哪些区别？
    1.双向数据绑定的原理不同
    2.是否支持碎片
    3.API不同
    4.定义数据变量方法不同
    5.生命周期的不同
    6.传值不同
    7.指令和插槽不同
    8.main.js不同
30.vue的性能优化怎么做？
    1.编码优化
        不要把所有数据都放在data中
        v-for时给每个元素绑定事件用事件代理
        keep-alive缓存组件
        尽可能拆分组件，提高复用性、维护性
        key值要保证唯一
        合理使用路由懒加载，异步组件
        数据持久化存储的使用尽量用防抖、节流优化
    2.加载优化
        按需加载
        内容懒加载
        图片懒加载
    3.用户体验
        骨架屏
    4.SEO优化
        预渲染
        服务端渲染ssr
    5.打包优化
        CDN形式加载第三方模块
        多线程打包
        抽离公共文件
    6.缓存和压缩
        客户端缓存、服务端缓存
        服务端Gzip压缩
31.首屏优化该如何去做？
    1.使用路由懒加载
    2.非首屏组件使用异步组件
    3.首屏不中要的组件延迟加载
    4.静态资源放在CDN上
    5.减少首屏上JS、CSS等资源文件的大小
    6.使用服务端渲染
    7.简历减少DOM的数量和层级
    8.使用精灵图请求
    9.做一些loading
    10.开启Gzip压缩
    11.图片懒加载
32.vue3的性能为什么比vue2好？
    1.diff算法的优化
    2.静态提升
    3.事件侦听缓存
33.vue3为什么使用proxy？
    1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性
    2.proxy对代理对象的监听更加丰富
    3.proxy代理对象会生成新的对象，不会修改被代理对象本身
    4.proxy补兼容ie浏览器
34.说一下你对组件的理解。
    可以重复使用的vue实例，独一无二的组件名称
    可以抽离单独的公共模块
    提高代码的复用率
35.你是如何规划项目文件的？
    public
        图标、index.html、img
    src
        api
        assets
        components
            按分类再次划分子目录
        plugins
        router
        static
        styles
        utils
        views
    App.vue
    main.js
    package.json
    vue.config.js
36.是否使用过nuxt.js？
    是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置
    SSR：服务端渲染
        好处：
            SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索
            优化了首屏加载时间
    SEO：优化搜索引擎
    SPA的应用不利于搜索引擎SEO的操作
37.SEO如何优化？
    1.SSR
    2.预渲染 prerender-spa-plugin
</code></pre>
<p>五、Echarts<br>
1.echarts有用过吗？常用的组件有哪些？<br>
title标题组件 show  text  link<br>
toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature<br>
tooltip tigger 触发类型<br>
markPoint标注点<br>
markLine图标的标线</p>
<p>六、Uni-APP<br>
1.uni-app有没有做过分包？<br>
优化小程序的下载和启动速度<br>
小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示</p>
<p>七、Weabpack<br>
1.webpack打包和不打包的区别？<br>
1.运行效率<br>
2.对基础的支持不够<br>
2.webpack是怎么打包的，babel是做什么的？<br>
webpack会把js css image看作一个模块，用import/require引入<br>
找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起<br>
把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件<br>
如果一个被多个文件引用，打包时只会生成一个文件<br>
如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包<br>
对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中</p>
<p>八、Git<br>
1.git如何合并、拉取代码？<br>
拉取代码 git pull '仓库地址'<br>
查看状态 git sattus<br>
提交到本地缓存区  git add .<br>
提交本地仓库 git commit -m '修改描述'<br>
提交到远程仓库 git push '仓库地址' master<br>
创建分支 git branch -b xxx<br>
合并分支 git merge '合并分支的名字'<br>
2.git如何解决冲突问题？<br>
1.两个分支中修改了同一个文件<br>
2.两个分支中修改了同一个文件的名字<br>
1.解决：当前分支上，直接修改代码  add  commit<br>
2.解决：在本地当前分支上，修改冲突代码 add commit push</p>
<p>九、HR<br>
1.你的离职原因是什么？<br>
疫情 社保 薪资问题 个人发展 技术提升 家庭因素<br>
2.工作到现在，项目中遇到最难的问题是什么？怎么解决的？<br>
1.不要回答，没有问题<br>
2.不要说一些常见的简单的问题，比如：数据请求不过来、渲染页面时出现了问题、跳转路由不会...<br>
首先应该时自行去查找资料寻求解决办法，然后再去请教同时或者组长<br>
3.你的优势在哪里？<br>
1.尽量不要暴露自己的缺点<br>
2.不要过度美化自己<br>
4.如何协同工作？<br>
1.开发前会开个会议，最后形成一个开发文档<br>
2.利用工具保证项目的正常进度，规范化</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题1]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-1/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-1/">
        </link>
        <updated>2023-04-05T03:41:41.000Z</updated>
        <content type="html"><![CDATA[<p>第一章 面试题基础篇</p>
<p>​		1.1 HTML面试题</p>
<p>​				面试题：行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？</p>
<pre><code>行内元素：span、img、input...
块级元素：div、footer、header、section、p、h1...h6...
空元素：br、hr...


元素之间的转换问题：
display: inline;  			把某元素转换成了行内元素      ===&gt;不独占一行的，并且不能设置宽高
display: inline-block; 	把某元素转换成了行内块元素		 ===&gt;不独占一行的，可以设置宽高
display: block;					把某元素转换成了块元素			   ===&gt;独占一行，并且可以设置宽高
</code></pre>
<p>​				面试题：页面导入样式时，使用link和@import有什么区别？</p>
<pre><code>区别一：link先有，后有@import（兼容性link比@import兼容）；
区别二：加载顺序差别，浏览器先加载的标签link，后加载@import
</code></pre>
<p>​				面试题：title与h1的区别、b与strong的区别、i与em的区别？</p>
<pre><code>title与h1的区别：

定义：
	title：概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题是什么
	h1：文章主题内容，告诉蜘蛛我们的网站内容最主要是什么
区别：
	title他是显示在网页标题上、h1是显示在网页内容上
	title比h1添加的重要 (title &gt; h1 ) ==》对于seo的了解
场景：
	网站的logo都是用h1标签包裹的	
</code></pre>
<pre><code>b与strong的区别：

定义：
	b：实体标签，用来给文字加粗的。
	strong：逻辑标签，用来加强字符语气的。
区别：
	b标签只有加粗的样式，没有实际含义。
	strong表示标签内字符比较重要，用以强调的。
题外话：为了符合css3的规范，b尽量少用该用strong就行了。
</code></pre>
<pre><code>i与em的区别：

定义：
	i:实体标签，用来做文字倾斜的。
	em：是逻辑标签，用来强调文字内容的
区别：
	i只是一个倾斜标签，没有实际含义。
	em表示标签内字符重要，用以强调的。
场景：
	i更多的用在字体图标，em术语上（医药，生物）。
</code></pre>
<p>​				面试题：img标签的title和alt有什么区别？</p>
<pre><code>区别一：
	title ： 鼠标移入到图片显示的值
	alt   ： 图片无法加载时显示的值
区别二：
	在seo的层面上，蜘蛛抓取不到图片的内容，所以前端在写img标签的时候为了增加seo效果要加入alt属性来描述这张图是什么内容或者关键词。
</code></pre>
<p>​				面试题：png、jpg、gif 这些图片格式解释一下，分别什么时候用？</p>
<pre><code>png:无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标。
jpg:采用压缩算法，有一点失真，比png体积要小，适合做中大图片。
gif:一般是做动图的。
webp：同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好。
</code></pre>
<p>​		1.2 CSS面试题</p>
<p>​				面试题：介绍一下CSS的盒子模型</p>
<pre><code>CSS的盒子模型有哪些：标准盒子模型、IE盒子模型
CSS的盒子模型区别：
	标准盒子模型：margin、border、padding、content
	IE盒子模型 ：margin、content（ border +  padding  + content ）
通过CSS如何转换盒子模型：
	box-sizing: content-box;	/*标准盒子模型*/
	box-sizing: border-box;	  /*IE盒子模型*/
</code></pre>
<p>​				面试题：line-height和heigh区别【大厂】</p>
<pre><code>line-height是每一行文字的高，如果文字换行则整个盒子高度会增大（行数*行高）。
height是一个死值，就是这个盒子的高度。
</code></pre>
<p>​				面试题：CSS选择符有哪些？哪些属性可以继承？</p>
<pre><code>CSS选择符：
    通配（*）
    id选择器（#）
    类选择器（.）
    标签选择器（div、p、h1...）
    相邻选择器(+)
    后代选择器(ul li)
    子元素选择器（ &gt; ）
    属性选择器(a[href])
    
CSS属性哪些可以继承：
		文字系列：font-size、color、line-height、text-align...
***不可继承属性：border、padding、margin...
</code></pre>
<p>​				面试题：CSS优先级算法如何计算？</p>
<pre><code>优先级比较：!important &gt; 内联样式 &gt; id &gt; class &gt; 标签 &gt; 通配
</code></pre>
<pre><code>CSS权重计算：
第一：内联样式（style）  权重值:1000
第二：id选择器  				 权重值:100
第三：类选择器 				  权重值:10
第四：标签&amp;伪元素选择器   权重值:1
第五：通配、&gt;、+         权重值:0
</code></pre>
<p>​				面试题：用CSS画一个三角形</p>
<pre><code>用边框画（border）,例如：
{
		width: 0;
		height: 0;

		border-left:100px solid transparent;
		border-right:100px solid transparent;
		border-top:100px solid transparent;
		border-bottom:100px solid #ccc;
}
</code></pre>
<p>​				面试题：一个盒子不给宽度和高度如何水平垂直居中？</p>
<h5 id="方式一">方式一：</h5>
<pre><code>&lt;div class='container'&gt;
	&lt;div class='main'&gt;main&lt;/div&gt;
&lt;/div&gt;

.container{
		display: flex;
		justify-content: center;
		align-items: center;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		background: red;
}
</code></pre>
<h5 id="方式二">方式二：</h5>
<pre><code>&lt;div class='container'&gt;
	&lt;div class='main'&gt;main&lt;/div&gt;
&lt;/div&gt;

.container{
		position: relative;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		position: absolute;
		left:50%;
		top:50%;
		background: red;
		transform: translate(-50%,-50%);
}
</code></pre>
<p>​				面试题：display有哪些值？说明他们的作用。</p>
<pre><code>none     			隐藏元素
block    			把某某元素转换成块元素
inline   			把某某元素转换成内联元素
inline-block 	把某某元素转换成行内块元素
</code></pre>
<p>​				面试题：对BFC规范(块级格式化上下文：block formatting context)的理解？</p>
<pre><code>BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

1. 了解BFC ： 块级格式化上下文。
2. BFC的原则：如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外面的元素。
3. 如何触发BFC：
		float的值非none
		overflow的值非visible
		display的值为：inline-block、table-cell...
		position的值为:absoute、fixed
</code></pre>
<p>​				面试题：清除浮动有哪些方式？</p>
<pre><code>1. 触发BFC
2. 多创建一个盒子，添加样式：clear: both;
3. after方式
	ul:after{
			content: '';
			display: block;
			clear: both;
	}
</code></pre>
<p>​				面试题：在网页中的应该使用奇数还是偶数的字体？为什么呢？</p>
<pre><code>偶数 : 让文字在浏览器上表现更好看。

另外说明：ui给前端一般设计图都是偶数的，这样不管是布局也好，转换px也好，方便一点。
</code></pre>
<p>​				面试题：position有哪些值？分别是根据什么定位的？</p>
<pre><code>static [默认]  没有定位
fixed  固定定位，相对于浏览器窗口进行定位。
relative  相对于自身定位，不脱离文档流。
absolute	相对于第一个有relative的父元素，脱离文档流。


relative和absolute区别
1. relative不脱离文档流 、absolute脱离文档流
2. relative相对于自身 、 absolute相对于第一个有relative的父元素
3. relative如果有left、right、top、bottom ==》left、top
	 absolute如果有left、right、top、bottom ==》left、right、top、bottom
</code></pre>
<p>​				面试题：写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。</p>
<pre><code>双飞翼
</code></pre>
<p>​				面试题：什么是CSS reset？</p>
<pre><code>reset.css   		是一个css文件，用来重置css样式的。
normalize.css 	为了增强跨浏览器渲染的一致性，一个CSS 重置样式库。
</code></pre>
<p>​				面试题：css sprite是什么,有什么优缺点</p>
<pre><code>1. 是什么
	把多个小图标合并成一张大图片。
2. 优缺点
	优点：减少了http请求的次数，提升了性能。
	缺点：维护比较差（例如图片位置进行修改或者内容宽高修改）
</code></pre>
<p>​				面试题：display: none;与visibility: hidden;的区别</p>
<pre><code>1. 占用位置的区别
display: none; 				是不占用位置的
visibility: hidden;   虽然隐藏了，但是占用位置

2. 重绘和回流的问题

visibility: hidden; 、 display: none;  产生重绘
display: none;     还会产生一次回流

产生回流一定会造成重绘，但是重绘不一定会造成回流。

产生回流的情况：改变元素的位置(left、top...)、显示隐藏元素....
产生重绘的情况：样式改变、换皮肤
</code></pre>
<p>​				面试题：opacity 和 rgba区别</p>
<pre><code>共同性：实现透明效果

1. opacity 取值范围0到1之间，0表示完全透明，1表示不透明
2. rgba   R表示红色，G表示绿色，B表示蓝色，取值可以在正整数或者百分数。A表示透明度取值0到1之间

区别：继承的区别
opacity会继承父元素的opacity属性，而RGBA设置的元素的后代元素不会继承不透明属性。
</code></pre>
<p>​		1.3 JavaScript基础面试题</p>
<p>​				面试题：延迟加载JS有哪些方式？</p>
<pre><code>延迟加载：async、defer
		例如：&lt;script defer type=&quot;text/javascript&quot; src='script.js'&gt;&lt;/script&gt;
		
defer : 等html全部解析完成，才会执行js代码，顺次执行js脚本。
async : async是和html解析同步的（一起的），不是顺次执行js脚本（谁先加载完谁先执行）。
</code></pre>
<p>​				面试题：JS数据类型有哪些？</p>
<pre><code>基本类型：string、number、boolean、undefined、null、symbol、bigint
引用类型：object

NaN是一个数值类型，但是不是一个具体的数字。
</code></pre>
<p>​				面试题：JS数据类型考题</p>
<h5 id="考题一">考题一：</h5>
<pre><code>console.log( true + 1 );     			//2
console.log( 'name'+true );  			//nametrue
console.log( undefined + 1 ); 		//NaN
console.log( typeof undefined ); //undefined
</code></pre>
<h5 id="考题二">考题二：</h5>
<pre><code>console.log( typeof(NaN) );       //number
console.log( typeof(null) );      //object
</code></pre>
<p>​				面试题：null和undefined的区别</p>
<pre><code>1. 作者在设计js的都是先设计的null（为什么设计了null：最初设计js的时候借鉴了java的语言）
2. null会被隐式转换成0，很不容易发现错误。
3. 先有null后有undefined，出来undefined是为了填补之前的坑。

具体区别：JavaScript的最初版本是这样区分的：null是一个表示&quot;无&quot;的对象（空对象指针），转为数值时为0；undefined是一个表示&quot;无&quot;的原始值，转为数值时为NaN。
</code></pre>
<p>​				面试题：<mark>和</mark>=有什么不同？</p>
<pre><code>==  :  比较的是值
		
		string == number || boolean || number ....都会隐式转换
		通过valueOf转换（valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。）

=== ： 除了比较值，还比较类型
</code></pre>
<p>​				面试题：JS微任务和宏任务</p>
<pre><code>1. js是单线程的语言。
2. js代码执行流程：同步执行完==》事件循环
	同步的任务都执行完了，才会执行事件循环的内容
	进入事件循环：请求、定时器、事件....
3. 事件循环中包含：【微任务、宏任务】
微任务：promise.then
宏任务：setTimeout..

要执行宏任务的前提是清空了所有的微任务

流程：同步==》事件循环【微任务和宏任务】==》微任务==》宏任务=》微任务...

</code></pre>
<p>​				面试题：JS作用域考题</p>
<pre><code>1. 除了函数外，js是没有块级作用域。
2. 作用域链：内部可以访问外部的变量，但是外部不能访问内部的变量。
	 注意：如果内部有，优先查找到内部，如果内部没有就查找外部的。
3. 注意声明变量是用var还是没有写（window.）
4. 注意：js有变量提升的机制【变量悬挂声明】
5. 优先级：声明变量 &gt; 声明普通函数 &gt; 参数 &gt; 变量提升
</code></pre>
<p>面试的时候怎么看：</p>
<pre><code>1. 本层作用域有没有此变量【注意变量提升】
2. 注意：js除了函数外没有块级作用域
3. 普通声明函数是不看写函数的时候顺序
</code></pre>
<h5 id="考题一-2">考题一：</h5>
<pre><code>function c(){
	var b = 1;
	function a(){
		console.log( b );
		var b = 2;
		console.log( b );
	}
	a();
	console.log( b );
}
c();
</code></pre>
<h5 id="考题二-2">考题二：</h5>
<pre><code>var name = 'a';
(function(){
	if( typeof name == 'undefined' ){
		var name = 'b';
		console.log('111'+name);
	}else{
		console.log('222'+name);
	}
})()
</code></pre>
<h5 id="考题三">考题三：</h5>
<pre><code>function fun( a ){
	var a = 10;
	function a(){}
	console.log( a );
}
fun( 100 );
</code></pre>
<p>​				面试题：JS对象考题</p>
<p>JS对象注意点：</p>
<pre><code>1. 对象是通过new操作符构建出来的，所以对象之间不想等(除了引用外)；
2. 对象注意：引用类型(共同一个地址)；
3. 对象的key都是字符串类型；
4. 对象如何找属性|方法；
	查找规则：先在对象本身找 ===&gt; 构造函数中找 ===&gt; 对象原型中找 ===&gt; 构造函数原型中找 ===&gt; 对象上一层原型查找
</code></pre>
<h5 id="考题一-3">考题一：</h5>
<pre><code> [1,2,3] === [1,2,3]   //false
</code></pre>
<h5 id="考题二-3">考题二：</h5>
<pre><code>var obj1 = {
	a:'hellow'
}
var obj2 = obj1;
obj2.a = 'world';
console.log(obj1); 	//{a:world}
(function(){
	console.log(a); 	//undefined
	var a = 1;
})();
</code></pre>
<h5 id="考题三-2">考题三：</h5>
<pre><code>var a = {}
var b = {
	key:'a'
}
var c = {
	key:'c'
}

a[b] = '123';
a[c] = '456';

console.log( a[b] ); // 456
</code></pre>
<p>​				面试题：JS作用域+this指向+原型的考题</p>
<h5 id="考题一-4">考题一：</h5>
<pre><code>function Foo(){
	getName = function(){console.log(1)} //注意是全局的window.
	return this;
}

Foo.getName = function(){console.log(2)}
Foo.prototype.getName = function(){console.log(3)}
var getName = function(){console.log(4)}
function getName(){
	console.log(5)
}

Foo.getName();    //2
getName(); 		  //4
Foo().getName();  //1
getName();		  //1
new Foo().getName();//3
</code></pre>
<h5 id="考题二-4">考题二：</h5>
<pre><code>var o = {
	a:10,
	b:{
		a:2,
		fn:function(){
			console.log( this.a ); // 2
			console.log( this );   //代表b对象
		}
	}
}
o.b.fn();
</code></pre>
<h5 id="考题三-3">考题三：</h5>
<pre><code>window.name = 'ByteDance';
function A(){
	this.name = 123;
}
A.prototype.getA = function(){
	console.log( this );
	return this.name + 1;
}
let a = new A();
let funcA = a.getA;
funcA();  //this代表window
</code></pre>
<h5 id="考题四">考题四：</h5>
<pre><code>var length = 10;
function fn(){
	return this.length + 1;
}
var obj = {
	length:5,
	test1:function(){
		return fn();
	}
}
obj.test2 = fn;
console.log( obj.test1() ); 							//1
console.log( fn()===obj.test2() ); 				//false
console.log( obj.test1() == obj.test2() ); //false
</code></pre>
<p>​				面试题：JS判断变量是不是数组，你能写出哪些方法？</p>
<h5 id="方式一isarray">方式一：isArray</h5>
<pre><code>var arr = [1,2,3];
console.log( Array.isArray( arr ) );
</code></pre>
<h5 id="方式二instanceof-可写可不写">方式二：instanceof  【可写,可不写】</h5>
<pre><code>var arr = [1,2,3];
console.log( arr instanceof Array );
</code></pre>
<h5 id="方式三原型prototype">方式三：原型prototype</h5>
<pre><code>var arr = [1,2,3];
console.log( Object.prototype.toString.call(arr).indexOf('Array') &gt; -1 );
</code></pre>
<h4 id="方式四isprototypeof">方式四：isPrototypeOf()</h4>
<pre><code>var arr = [1,2,3];
console.log(  Array.prototype.isPrototypeOf(arr) )
</code></pre>
<h4 id="方式五constructor">方式五：constructor</h4>
<pre><code>var arr = [1,2,3];
console.log(  arr.constructor.toString().indexOf('Array') &gt; -1 )
</code></pre>
<p>​				面试题：slice是干嘛的、splice是否会改变原数组</p>
<pre><code>1. slice是来截取的
	参数可以写slice(3)、slice(1,3)、slice(-3)
	返回的是一个新的数组
2. splice 功能有：插入、删除、替换
	返回：删除的元素
	该方法会改变原数组
</code></pre>
<p>​				面试题：JS数组去重</p>
<h5 id="方式一new-set">方式一：new set</h5>
<pre><code>var arr1 = [1,2,3,2,4,1];
function unique(arr){
	return [...new Set(arr)]
}
console.log(  unique(arr1) );
</code></pre>
<h5 id="方式二indexof">方式二：indexOf</h5>
<pre><code>var arr2 = [1,2,3,2,4,1];
function unique( arr ){
	var brr = [];
	for( var i=0;i&lt;arr.length;i++){
		if(  brr.indexOf(arr[i]) == -1 ){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr2) );
</code></pre>
<h5 id="方式三sort">方式三：sort</h5>
<pre><code>var arr3 = [1,2,3,2,4,1];
function unique( arr ){
	arr = arr.sort();
	var brr = [];
	for(var i=0;i&lt;arr.length;i++){
		if( arr[i] !== arr[i-1]){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr3) );
</code></pre>
<p>​				面试题：找出多维数组最大值</p>
<pre><code>function fnArr(arr){
	var newArr = [];
	arr.forEach((item,index)=&gt;{
		newArr.push( Math.max(...item)  )
	})
	return newArr;
}
console.log(fnArr([
	[4,5,1,3],
	[13,27,18,26],
	[32,35,37,39],
	[1000,1001,857,1]
]));
</code></pre>
<p>​				面试题：给字符串新增方法实现功能</p>
<p>给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前缀的字符串，例如：</p>
<p>console.log( 'world'.addPrefix('hello') )  控制台会输出helloworld</p>
<pre><code>解答：
String.prototype.addPrefix = function(str){
	return str  + this;
}
console.log( 'world'.addPrefix('hello') )
</code></pre>
<p>​				面试题：找出字符串出现最多次数的字符以及次数</p>
<pre><code>var str = 'aaabbbbbccddddddddddx';
var obj = {};
for(var i=0;i&lt;str.length;i++){
	var char = str.charAt(i);
	if( obj[char] ){
		obj[char]++;
	}else{
		obj[char] = 1;
	}
}
console.log( obj );
//统计出来最大值
var max = 0;
for( var key in obj ){
	if( max &lt; obj[key] ){
		max = obj[key];
	}
}
//拿最大值去对比
for( var key in obj ){
	if( obj[key] == max ){
		console.log('最多的字符是'+key);
		console.log('出现的次数是'+max);
	}
}
</code></pre>
<p>​				面试题：new操作符具体做了什么</p>
<pre><code>1. 创建了一个空的对象
2. 将空对象的原型，指向于构造函数的原型
3. 将空对象作为构造函数的上下文（改变this指向）
4. 对构造函数有返回值的处理判断
</code></pre>
<pre><code>function Fun( age,name ){
	this.age = age;
	this.name = name;
}
function create( fn , ...args ){
	//1. 创建了一个空的对象
	var obj = {}; //var obj = Object.create({})
	//2. 将空对象的原型，指向于构造函数的原型
	Object.setPrototypeOf(obj,fn.prototype);
	//3. 将空对象作为构造函数的上下文（改变this指向）
	var result = fn.apply(obj,args);
	//4. 对构造函数有返回值的处理判断
	return result instanceof Object ? result : obj;
}
console.log( create(Fun,18,'张三')   )
</code></pre>
<p>​				面试题：闭包</p>
<pre><code>1. 闭包是什么
	闭包是一个函数加上到创建函数的作用域的连接，闭包“关闭”了函数的自由变量。
2. 闭包可以解决什么问题【闭包的优点】
	2.1 内部函数可以访问到外部函数的局部变量
	2.2 闭包可以解决的问题
			var lis = document.getElementsByTagName('li');
      for(var i=0;i&lt;lis.length;i++){
        (function(i){
          lis[i].onclick = function(){
            alert(i);
          }
        })(i)
      }
3. 闭包的缺点
	3.1 变量会驻留在内存中，造成内存损耗问题。
				解决：把闭包的函数设置为null
  3.2 内存泄漏【ie】 ==&gt; 可说可不说，如果说一定要提到ie
</code></pre>
<p>​				面试题：原型链</p>
<pre><code>1. 原型可以解决什么问题
	对象共享属性和共享方法
2. 谁有原型
函数拥有：prototype
对象拥有：__proto__
3. 对象查找属性或者方法的顺序
	先在对象本身查找 --&gt; 构造函数中查找 --&gt; 对象的原型 --&gt; 构造函数的原型中 --&gt; 当前原型的原型中查找
4. 原型链
	4.1 是什么？：就是把原型串联起来
	4.2 原型链的最顶端是null
</code></pre>
<p>​				面试题： JS继承有哪些方式</p>
<h5 id="方式一es6">方式一：ES6</h5>
<pre><code>class Parent{
	constructor(){
		this.age = 18;
	}
}

class Child extends Parent{
	constructor(){
		super();
		this.name = '张三';
	}
}
let o1 = new Child();
console.log( o1,o1.name,o1.age );
</code></pre>
<h5 id="方式二原型链继承">方式二：原型链继承</h5>
<pre><code>function Parent(){
	this.age = 20;
}
function Child(){
	this.name = '张三'
}
Child.prototype = new Parent();
let o2 = new Child();
console.log( o2,o2.name,o2.age );
</code></pre>
<h5 id="方式三借用构造函数继承">方式三：借用构造函数继承</h5>
<pre><code>function Parent(){
	this.age = 22;
}
function Child(){
	this.name = '张三'
	Parent.call(this);
}
let o3 = new Child();
console.log( o3,o3.name,o3.age );
</code></pre>
<h5 id="方式四组合式继承">方式四：组合式继承</h5>
<pre><code>function Parent(){
	this.age = 100;
}
function Child(){
	Parent.call(this);
	this.name = '张三'
}
Child.prototype = new Parent();
let o4 = new Child();
console.log( o4,o4.name,o4.age );
</code></pre>
<p>​				面试题：说一下call、apply、bind区别</p>
<h5 id="共同点功能一致">共同点：功能一致</h5>
<pre><code>可以改变this指向

语法： 函数.call()、函数.apply()、函数.bind()
</code></pre>
<h5 id="区别">区别：</h5>
<pre><code>1. call、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。
2. 参数不同：apply第二个参数是数组。call和bind有多个参数需要挨个写。
</code></pre>
<h5 id="场景">场景：</h5>
<pre><code>1. 用apply的情况
var arr1 = [1,2,4,5,7,3,321];
console.log( Math.max.apply(null,arr1) )

2. 用bind的情况
var btn = document.getElementById('btn');
var h1s = document.getElementById('h1s');
btn.onclick = function(){
	console.log( this.id );
}.bind(h1s)
</code></pre>
<p>​				面试题：sort背后原理是什么？</p>
<pre><code>V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。

之前的版本是：插入排序和快排，现在是冒泡

原理实现链接：https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js

***710行代码开始***
</code></pre>
<p>​				面试题：深拷贝和浅拷贝</p>
<pre><code>共同点：复制

1. 浅拷贝：只复制引用，而未复制真正的值。
var arr1 = ['a','b','c','d'];
var arr2 = arr1;

var obj1 = {a:1,b:2}
var obj2 = Object.assign(obj1);

2. 深拷贝：是复制真正的值 （不同引用）
var obj3 = {
	a:1,
	b:2
}
var obj4 = JSON.parse(JSON.stringify( obj3 ));

//递归的形式
function copyObj( obj ){
	if(  Array.isArray(obj)  ){
		var newObj = [];
	}else{
		var newObj = {};
	}
	for( var key in obj ){
		if( typeof obj[key] == 'object' ){
			newObj[key] = copyObj(obj[key]);
		}else{
			newObj[key] = obj[key];
		}
	}
	return newObj;
}
console.log(  copyObj(obj5)  );
</code></pre>
<p>​				面试题：localStorage、sessionStorage、cookie的区别</p>
<pre><code>公共点：在客户端存放数据
区别：
1. 数据存放有效期
		sessionStorage : 仅在当前浏览器窗口关闭之前有效。【关闭浏览器就没了】
		localStorage   : 始终有效，窗口或者浏览器关闭也一直保存，所以叫持久化存储。
		cookie				 : 只在设置的cookie过期时间之前有效，即使窗口或者浏览器关闭也有效。
2. localStorage、sessionStorage不可以设置过期时间
	 cookie 有过期时间，可以设置过期（把时间调整到之前的时间，就过期了）
3. 存储大小的限制
	cookie存储量不能超过4k
	localStorage、sessionStorage不能超过5M
	
	****根据不同的浏览器存储的大小是不同的。
</code></pre>
<p>​		1.4 H5/C3面试题</p>
<p>​				面试题：什么是语义化标签</p>
<pre><code>1. 易读性和维护性更好。
2. seo成分会更好，蜘蛛抓取更好。
3. IE8不兼容HTML5标签的。解决：可以通过html5shiv.js去处理。
</code></pre>
<p>​				面试题：::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p>
<pre><code>1. 区别
	:是伪类、::伪元素  ===》是为了做区分

2.是什么？作用
	元素before之前 、 元素after之后
	作用：清除浮动、样式布局上也有作用
</code></pre>
<p>​				面试题：如何关闭IOS键盘首字母自动大写</p>
<pre><code>&lt;input type=&quot;text&quot; autocapitalize='off'&gt;
</code></pre>
<p>​				面试题：怎么让Chrome支持小于12px 的文字？</p>
<pre><code>Chrome默认字体大小是：16px
**每个浏览器默认字体大小可能都不一样

&lt;style type=&quot;text/css&quot;&gt;
div{
	font-size:10px;
}
div span{
	display: inline-block;
	-webkit-transform:scale(1.6);
}
&lt;/style&gt;
</code></pre>
<p>​				面试题：rem和em区别</p>
<pre><code>相对于font-size

em针对于父元素的font-size
rem针对于根(html)元素的font-size
</code></pre>
<p>​				面试题：ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉</p>
<pre><code>&lt;style&gt;
	a,button,input,textarea{
		-webkit-tap-highlight-color: rgba(0,0,0,0);
	}
&lt;/style&gt;
</code></pre>
<p>​				面试题：webkit表单输入框placeholder的颜色值能改变吗？</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
	input::-webkit-input-placeholder{
		color:red;
	}
&lt;/style&gt;
</code></pre>
<p>​				面试题：禁止ios长按时触发系统的菜单，禁止ios&amp;android长按时下载图片</p>
<pre><code>禁止ios 长按时触发系统的菜单，禁止ios&amp;android长按时下载图片
html,body{
	touch-callout: none;
	-webkit-touch-callout: none;
	
	user-select:none;
	-webkit-user-select:none;
}
</code></pre>
<p>​				面试题：禁止ios和android用户选中文字</p>
<pre><code>html,body{
	user-select:none;
	-webkit-user-select:none;
}
</code></pre>
<p>​				面试题：自适应</p>
<pre><code>淘宝无限适配【移动端】：淘宝无限适配 + 布局单位使用rem
</code></pre>
<p>​				面试题：响应式</p>
<pre><code>1. 是什么？
	一个URL可以响应多端
2. 语法结构
	@media only screen and (max-width: 1000px){
		ul li:last-child{
			display: none;
		}
	}

	only : 可以排除不支持媒体查询的浏览器
	screen ： 设备类型
	max-width | max-height
	min-width | min-height 
3. 响应式图片【性能优化】
	&lt;picture&gt;
		&lt;source srcset=&quot;1.jpg&quot; media='(min-width:1000px)'&gt;
		&lt;source srcset=&quot;2.jpg&quot; media='(min-width:700px)'&gt;
		&lt;img srcset=&quot;3.jpg&quot;&gt;
	&lt;/picture&gt;
</code></pre>
<p>布局方案</p>
<pre><code>一、什么情况下采用响应式布局
	
	数据不是特别多，用户量不是特别大，纯展示类的项目适合响应式布局
	
	例如：公司的官网、专题页面
	
	特别追求性能的项目，不太适合响应式，因为如果添加了很多的响应式就会造成加载速度变慢。

二、pc + 移动端应该做什么样的布局方案
	注意：访问量还可以或者比较大，类似于淘宝网。
	
	pc是一套，会加入一点点响应式。
	移动端是一套，会使用自适应的布局方式。

三、pc的设计图

	ui：1980
	笔记本电脑：1280
	ui图的宽度和电脑的宽度不对应该怎么办？
		1. 把ui图进行等比缩放，缩放成和电脑一样的尺寸
		2. 换1980的电脑
		
四、移动端的设计图

	宽度：750
	因为750设计图/2就是375，正好是iphone6的尺寸，我们要把iphone6的尺寸做为基准点。
</code></pre>
<p>第二章 面试题进阶篇</p>
<p>​		2.1 ES6面试题</p>
<p>​				面试题：var、let、const区别</p>
<pre><code>var、let、const 共同点都是可以声明变量的

区别一：
	var 具有变量提升的机制
	let和const没有变量提升的机制
区别二：
	var 可以多次声明同一个变量
	let和const不可以多次声明同一个变量
区别三：
	var、let声明变量的
	const声明常量
	
	var和let声明的变量可以再次赋值，但是const不可以再次赋值了。
区别四：
	var声明的变量没有自身作用域
	let和const声明的变量有自身的作用域
</code></pre>
<p>​				面试题：作用域考题</p>
<p>考题一：let和const没有变量提升性</p>
<pre><code>console.log( str );//undefined
var str = '你好';

console.log( num );//报错
let num = 10;
</code></pre>
<p>考题二：</p>
<pre><code>function demo(){
	var n = 2;
	if( true ){
		var n = 1;
	}
	console.log( n );//1
}
demo();


function demo(){
	let n = 2;
	if( true ){
		let n = 1;
	}
	console.log( n );//2
}
demo();
</code></pre>
<p>考题三：可以修改</p>
<pre><code>const obj = {
	a:1
}
obj.a = 11111;
console.log( obj )

const arr = ['a','b','c'];
arr[0]= 'aaaaa';
console.log( arr );
</code></pre>
<p>​				面试题：将下列对象进行合并</p>
<p>方式一：Object.assign</p>
<pre><code>const a = {a:1,b:4};
const b = {b:2,c:3};

let obj1 = Object.assign(a,b);
console.log( obj1 );
</code></pre>
<p>方式二：...</p>
<pre><code>let obj2 = {...a,...b};
console.log( obj2 );
</code></pre>
<p>方式三：自己封装方法</p>
<pre><code>function extend( target,  source ){
	for(var key in source){
		target[key] = source[key];
	}
	return target;
}
console.log( extend(a,b) );
</code></pre>
<p>​				面试题：箭头函数和普通函数有什么区别？</p>
<pre><code>1. this指向的问题
	箭头函数中的this只在箭头函数定义时就决定的，而且不可修改的（call、apply、bind）
	****箭头函数的this指向定义时候、外层第一个普通函数的this
2. 箭头函数不能new（不能当作构造函数）
3. 箭头函数prototype
4. 箭头函数arguments
</code></pre>
<p>​				面试题：Promise有几种状态</p>
<pre><code>有三种状态：
pending（进行中）
fulfilled（已成功）
rejected（已失败）
</code></pre>
<p>​				面试题：find和filter的区别</p>
<pre><code>区别一：返回的内容不同
	filter 返回是新数组
	find   返回具体的内容
区别二：
	find ：匹配到第一个即返回
	filter ： 返回整体（没一个匹配到的都返回）
</code></pre>
<p>​				面试题：some和every的区别</p>
<pre><code>some  ==》 如果有一项匹配则返回true
every ==》 全部匹配才会返回true
</code></pre>
<p>​		2.2 webpack面试题</p>
<p>​				面试题：webpack插件</p>
<p>​		2.3 Git面试题</p>
<p>​				面试题：git常用命令</p>
<p>​				面试题：解决冲突</p>
<p>​				面试题：GitFlow</p>
<p>第三章 面试题框架篇</p>
<p>​		3.1 Vue面试题</p>
<p>​				面试题：Vue2.x 生命周期</p>
<pre><code>1. 有哪些生命周期
系统自带：
  beforeCreate
  created
  beforeMount
  mounted
  beforeUpdate
  updated
  beforeDestroy
  destroyed
2. 一旦进入到页面或者组件，会执行哪些生命周期，顺序。
 beforeCreate
 created
 beforeMount
 mounted
3. 在哪个阶段有$el，在哪个阶段有$data
	beforeCreate 啥也没有
	created  有data没有el
	beforeMount 有data没有el
	mounted 都有
4. 如果加入了keep-alive会多俩个生命周期
	activated、deactivated
5. 如果加入了keep-alive，第一次进入组件会执行哪些生命？
 beforeCreate
 created
 beforeMount
 mounted
 activated
6. 如果加入了keep-alive，第二次或者第N次进入组件会执行哪些生命周期？
只执行一个生命周期：activated
</code></pre>
<p>​				面试题：谈谈你对keep-alive的了解</p>
<pre><code>1. 是什么
vue系统自带的一个组件，功能：是来缓存组件的。===》提升性能
2. 使用场景
就是来缓存组件，提升项目的性能。具体实现比如：首页进入到详情页，如果用户在首页每次点击都是相同的，那么详情页就没必要请求N次了，直接缓存起来就可以了，当然如果点击的不是同一个，那么就直接请求。
</code></pre>
<p>​				面试题：v-if和v-show区别</p>
<pre><code>1. 展示形式不同
v-if是 创建一个dom节点
v-show 是display:none 、 block

2. 使用场景不同
初次加载v-if要比v-show好，页面不会做加载盒子
频繁切换v-show要比v-if好，创建和删除的开销太大了，显示和隐藏开销较小
</code></pre>
<p>​				面试题：v-if和v-for优先级</p>
<pre><code>v-for的优先级要比v-if高
***是在源码中体现的：function genElement
</code></pre>
<p>​				面试题：ref是什么？</p>
<pre><code>来获取dom的
</code></pre>
<p>​				面试题：nextTick是什么?</p>
<pre><code>获取更新后的dom内容
</code></pre>
<p>​				面试题：scoped原理</p>
<pre><code>1. 作用：让样式在本组件中生效，不影响其他组件。
2. 原理：给节点新增自定义属性，然后css根据属性选择器添加样式。
</code></pre>
<p>​				面试题：Vue中如何做样式穿透</p>
<pre><code>stylus样式穿透使用：&gt;&gt;&gt;
sass和less使用：/deep/
通用使用：  :v-deep
</code></pre>
<p>​				面试题：Vue组件传值</p>
<pre><code>父组件--&gt;子组件：

	1. 父组件：
		&lt;user-detail :myName=&quot;name&quot; /&gt;
    
    export default {
        components: {
            UserDetail
        }
        ......
    }
  2. 在子组件中使用props（可以是数组也可以是对象）接收即可。可以传多个属性。
  	export default {
      props: ['myName']
 		}

子组件--&gt;父组件：

		1. 子组件
      &lt;button @click=&quot;changeParentName&quot;&gt;改变父组件的name&lt;/button&gt;
      export default {
          methods: {
              //子组件的事件
              changeParentName: function() {
                  this.$emit('handleChange', 'Jack')
              }
          }
      }
    2. 父组件
      &lt;child @handleChange=&quot;changeName&quot;&gt;&lt;/child&gt;

      methods: {
          changeName(name) {  
              this.name = name
          }
      }

兄弟组件之间：bus.js
</code></pre>
<p>​				面试题：computed、methods、watch有什么区别？</p>
<pre><code>1. computed vs methods区别
	computed是有缓存的
	methods没有缓存
2. computed vs watch区别
	watch是监听，数据或者路由发生了改变才可以响应（执行）
	computed计算某一个属性的改变，如果某一个值改变了，计算属性会监听到进行返回
	watch是当前监听到数据改变了，才会执行内部代码
</code></pre>
<p>​				面 试题：props和data优先级谁高？</p>
<pre><code>props ===&gt;  methods ===&gt; data ===&gt; computed ===&gt;watch
</code></pre>
<p>​				面试题：Vuex有哪些属性？</p>
<pre><code>state、getters、mutations、actions、modules

state 类似于组件中data，存放数据
getters 类型于组件中computed
mutations 类似于组件中methods
actions 提交mutations的
modules 把以上4个属性再细分，让仓库更好管理
</code></pre>
<p>​				面试题：Vuex是单向数据流还是双向数据流？</p>
<pre><code>Vuex是单向数据流
</code></pre>
<p>​				面试题：Vuex中的mutaitons和actions区别</p>
<pre><code>mutaitons   :  都是同步事物
actions     :  可以包含任意异步操作

***在调试中就看出来
</code></pre>
<p>​				面试题：Vuex如何做持久化存储</p>
<pre><code>Vuex本身不是持久化存储

1. 使用localStorage自己写
2. 使用vuex-persist插件
</code></pre>
<p>​				面试题：Vue设置代理</p>
<h6 id="vueconfigjs">vue.config.js</h6>
<pre><code>module.exports = {
  publicPath:'./',
  devServer: {
    proxy: 'http://localhost:3000'
  }
}
</code></pre>
<p>​				面试题：Vue项目打包上线</p>
<pre><code>1. 自测==&gt;修改路由模式
2. 代理不生效，使用ENV
3. 修改路径
</code></pre>
<p>​				面试题：Vue路由模式</p>
<pre><code>路由模式有俩种：history、hash
区别：
	1. 表现形态不同
			history:http://localhost:8080/about
			hash:http://localhost:8080/#/about
	2. 跳转请求
			history : http://localhost:8080/id   ===&gt;发送请求
			hash 	  : 不会发送请求
	3. 打包后前端自测要使用hash，如果使用history会出现空白页
</code></pre>
<p>​				面试题：介绍一下SPA以及SPA有什么缺点</p>
<pre><code>SPA是什么？单页面应用
缺点：
	1. SEO优化不好
	2. 性能不是特别好
</code></pre>
<p>​				面试题：Vue路径传值</p>
<pre><code>1. 显式
	http://localhost:8080/about?a=1
	1.1 传：this.$router.push({
  			path:'/about',
  			query:{
  				a:1
  			}
  		})
  1.2 接：this.$route.query.a
  
2. 隐式
	http://localhost:8080/about
	2.1 传：this.$router.push({
  			name:'About',
  			params:{
  				a:1
  			}
  		})
  2.2 接：this.$route.params.a
</code></pre>
<p>​				面试题：路由导航守卫有哪些</p>
<pre><code>全局、路由独享、组件内

1. 全局
	beforeEach、beforeResolve、afterEach
2. 路由独享
	beforeEnter
3. 组件内
	beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
	
使用场景：判断是否登录，如果登录就next否则就跳转到登录页面
</code></pre>
<p>​				面试题：Vue动态路由</p>
<pre><code>场景：详情页(文章、商品)
router.js配置：
	{
    path: &quot;/list&quot;,
    name: &quot;List&quot;,
    children:[
      {
        path:&quot;/list/:id&quot;,
        name:'Details',
        component: () =&gt;
          import(&quot;../views/Details.vue&quot;),
      }
    ],
    component: () =&gt;
      import(&quot;../views/List.vue&quot;),
  },
</code></pre>
<p>​				面试题：双向绑定原理</p>
<pre><code>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。
通过Object.defineProperty()来实现数据劫持的。

1.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

2.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

3.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
</code></pre>
<p>​				面试题：什么是虚拟DOM</p>
<pre><code>其实就是数据，把dom变成数据结构。
</code></pre>
<p>​				面试题：diff算法</p>
<pre><code>利用diff算法可以更多提升dom之间对比的性能（采用虚拟dom数据进行对比）。
</code></pre>
<p>​				面试题：讲一下MVVM</p>
<pre><code>M就是data的model层
V就是view视图层
VM就是理解为v-model原理实现，通过view更新model
</code></pre>
<p>​		3.2 微信小程序面试题</p>
<p>​				面试题：如何自定义头部？</p>
<pre><code>app.json进行配置

&quot;window&quot;:{
    &quot;navigationStyle&quot;:&quot;custom&quot;,
}
</code></pre>
<p>​				面试题：不校验URL</p>
<pre><code>工具==》详情==》本地设置==》不校验合法域名  ： 项目上线前URL一定要请求到（不勾选也可以请求到数据）
</code></pre>
<p>​		3.3 uni-app面试题</p>
<p>​				面试题：生命周期</p>
<pre><code>应用生命周期、页面生命周期、组件生命周期
</code></pre>
<p>​				面试题：条件编译</p>
<pre><code>在工具中，打if出现的条件编译

例如：
&lt;!-- #ifdef H5 --&gt;
  	&lt;h1&gt;这是h5端&lt;/h1&gt;
&lt;!-- #endif --&gt;
</code></pre>
<p>第四章 面试题性能优化篇</p>
<p>​		4.1 加载优化</p>
<pre><code>1. http请求
	 能不能减少（能不能合并）
2. 图片的雪碧图
3. script标签位置
4. link标签（css引入）
</code></pre>
<p>​		4.2 图片优化</p>
<pre><code>1. 图片懒加载
2. 响应式图片
3. webp代替其他格式
4. 小图标可以改用字体图标
</code></pre>
<p>​		4.3 渲染优化</p>
<pre><code>1. 减少重绘和回流
2. 改变位置使用transform
3. 动画尽量用requestAnimationFrame，不要用定时器
</code></pre>
<p>​		4.4 首屏优化</p>
<pre><code>1. 长列表
2. 项目的html文件、css文件、图片、js文件压缩打包
</code></pre>
<p>​		4.5 vue优化</p>
<pre><code>1. keep-alive 缓存组件
2. 路由懒加载
3. 内容使用
	v-if和v-show
	computed、watch、methods
4. Object.freeze ：冻结对象
	纯展示类的接口数据，冻结就可以了
5. 使用ui组件按需引入
</code></pre>
<p>第五章 面试题兼容篇</p>
<p>​		5.1 页面样式兼容</p>
<pre><code>1. 在ios键盘中首字母大写的问题?
		&lt;input type=&quot;text&quot; autocapitalize='off'&gt;
2. ios日期转换NAN问题
		具体就是，new Date('2020-11-12 00:00:00')在ios中会为NAN
		解决方案：用new Date('2020/11/12 00:00:00')的日期格式，或者写个正则转换
3. 在移动端使用click事件有300ms延迟的问题
	 	禁止双击缩放===》meta:user-scalabel=no
4. 	移动端touch事件有穿透（点透）的问题，怎么解决？
	 	4.1 阻止默认行为 : e.preventDefault();
	 	4.2 fastclick.js
5. 安卓部分版本input的placeholder偏上
		input{
	  		 line-height:normal;
		}
</code></pre>
<p>第六章 面试题网络请求篇</p>
<p>​		6.1 跨域面试题</p>
<pre><code>前端：jsonp、vue的项目可以设置代理（打包后无效。解决：.ENV文件）
后端：CORS
</code></pre>
<p>​		6.2 http和https的区别？</p>
<pre><code>1. 端口不同

	http ：80端口
	https ：443端口
	
2. https比http更加安全
	
	***https就是证书
</code></pre>
<p>第七章 WEB安全篇</p>
<p>​		7.1 XSS攻击</p>
<pre><code>用户输入的文本框，需要替换某些特殊字符（ &lt;&gt; ... ）
</code></pre>
<p>​		7.2 SQL注入</p>
<pre><code>用户输入的文本框中不可以有特殊符号（ 引号、空格 ）
</code></pre>
<p>​		7.3 接口安全</p>
<p>第八章 其他类面试题</p>
<p>​		8.1 token</p>
<p>​		8.2 SEO</p>
<h1 id="新增面试题vue2vue3面试题">新增面试题vue2/vue3面试题</h1>
<ol>
<li>
<p>vue2双向绑定和vue3双向绑定区别</p>
</li>
<li>
<p>说一说vue2和vue3区别</p>
</li>
<li>
<p>在beforeMount中如何获取dom</p>
</li>
<li>
<p>nextTick原理</p>
</li>
<li>
<p>Vite使用过吗？说一说Vite与webpack区别</p>
</li>
<li>
<p>pinia使用过吗？说一说vuex与pinia区别</p>
</li>
<li>
<p>vue如何解决seo的问题</p>
</li>
<li>
<p>vue如何分包</p>
</li>
<li>
<p>Vue3自己封装过组件吗？如何设计一个modal组件</p>
</li>
<li>
<p>vue3提升性能有哪些点</p>
</li>
<li>
<p>Vue 3.0 性能提升主要是通过哪几方面体现的？</p>
</li>
<li>
<p>Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？</p>
</li>
<li>
<p>Proxy 相对于 Object.defineProperty 有哪些优点？</p>
</li>
<li>
<p>Vue 3.0 在编译方面有哪些优化？</p>
</li>
</ol>
<h1 id="新增微信小程序面试题">新增微信小程序面试题</h1>
<ol>
<li>体积过大如何分包</li>
<li>小程序js和javascript区别</li>
</ol>
<h1 id="新增typescript面试题">新增TypeScript面试题</h1>
<ol>
<li>ts和js有什么不同？</li>
<li>是否可以将多个.ts文件合并成一个.js文件？如果是，那么如何做？</li>
<li>内部模块和外部模块有什么区别？</li>
<li>JavaScript不支持函数重载，但TypeScript是否支持函数重载？</li>
<li>TypeScript是否支持所有面向对象的原则？</li>
<li>如何检查TypeScript中的null和undefined ？</li>
<li>TS的“接口”和“type”语句有什么区别？</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router全局路由守卫]]></title>
        <id>https://coderdml.github.io/post/vue-router-quan-ju-lu-you-shou-wei/</id>
        <link href="https://coderdml.github.io/post/vue-router-quan-ju-lu-you-shou-wei/">
        </link>
        <updated>2023-03-22T07:34:55.000Z</updated>
        <content type="html"><![CDATA[<p>全局路由监听修改页面标题<br>
在index.js中</p>
<pre><code>router.beforeEach((to,from,next)=&gt;{
    document.title = to.match[0].meta.title
    next()
})

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型和原型链]]></title>
        <id>https://coderdml.github.io/post/yuan-xing-he-yuan-xing-lian/</id>
        <link href="https://coderdml.github.io/post/yuan-xing-he-yuan-xing-lian/">
        </link>
        <updated>2023-03-17T12:14:13.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.cnblogs.com/loveyaxin/p/11151586.html</p>
]]></content>
    </entry>
</feed>