<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://coderdml.github.io</id>
    <title>Study for money</title>
    <updated>2022-02-08T09:36:53.980Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://coderdml.github.io"/>
    <link rel="self" href="https://coderdml.github.io/atom.xml"/>
    <subtitle>Work for pussy</subtitle>
    <logo>https://coderdml.github.io/images/avatar.png</logo>
    <icon>https://coderdml.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Study for money</rights>
    <entry>
        <title type="html"><![CDATA[诡异面试题]]></title>
        <id>https://coderdml.github.io/post/gui-yi-mian-shi-ti/</id>
        <link href="https://coderdml.github.io/post/gui-yi-mian-shi-ti/">
        </link>
        <updated>2022-02-08T09:36:02.000Z</updated>
        <content type="html"><![CDATA[<p>函数提升</p>
<p>变量提升</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[06.力扣剑指OFFER——JZ22 链表中倒数最后k个结点]]></title>
        <id>https://coderdml.github.io/post/06li-kou-jian-zhi-offer-jz22-lian-biao-zhong-dao-shu-zui-hou-k-ge-jie-dian/</id>
        <link href="https://coderdml.github.io/post/06li-kou-jian-zhi-offer-jz22-lian-biao-zhong-dao-shu-zui-hou-k-ge-jie-dian/">
        </link>
        <updated>2022-02-08T08:55:09.000Z</updated>
        <content type="html"><![CDATA[<p>描述<br>
输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。<br>
如果该链表长度小于k，请返回一个长度为 0 的链表。</p>
<p>要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)<br>
进阶：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)</p>
<p>思路一：进栈出栈<br>
时间复杂度O(N)：N表示链表的数量，遍历链表<br>
空间复杂度O(N)：存储链表元素的栈空间</p>
<p>思路二：快慢指针<br>
双指针，先让快指针移动K步，然后两个指针同步移动，当快指针指向null时，返回慢指针<br>
时间复杂度O(N)：N为链表长度，遍历整个链表<br>
空间复杂度O(1)：使用额外常数大小空间</p>
<pre><code>function FindKthToTail( pHead ,  k ) {
    // write code here
    if (pHead === null || k === 0) return null;
        
    let fast = pHead
    let slow = pHead
    for(let i = 0;i &lt; k;i++){
        if(fast === null) return null;
        fast = fast.next
    }
    while(fast){
        slow = slow.next
        fast = fast.next
    }
    return slow;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[05.力扣剑指OFFER——JZ23 链表中环的入口结点]]></title>
        <id>https://coderdml.github.io/post/05/</id>
        <link href="https://coderdml.github.io/post/05/">
        </link>
        <updated>2022-02-08T08:49:48.000Z</updated>
        <content type="html"><![CDATA[<p>描述<br>
给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p>
<p>数据范围： n\le10000n≤10000，1&lt;=结点值&lt;=100001&lt;=结点值&lt;=10000<br>
要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)</p>
<pre><code>function EntryNodeOfLoop(pHead)
{
    // write code here
//     设置快慢指针，都从链表头出发，快指针每次走两步，慢指针一次走一步
//   假如有环，一定相遇于环中某点(结论1)
//   接着让两个指针分别从相遇点和链表头出发，两者都改为每次走一步，最终相遇于环入口(结论2)。
    if(pHead === null || pHead.next === null){
        return null;
    }
    let p1 = pHead
    let p2 = pHead
    while(p2 &amp;&amp; p2.next){  //p2是快指针，保证p2
        p1 = p1.next
        p2 = p2.next.next
        if(p1 === p2){  //第一次相遇后改变指针位置
            p1 = pHead
            while(p1 !== p2){
            p2 = p2.next
            p1 = p1.next
            }
            return p1
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面经草稿]]></title>
        <id>https://coderdml.github.io/post/mian-jing-cao-gao/</id>
        <link href="https://coderdml.github.io/post/mian-jing-cao-gao/">
        </link>
        <updated>2022-02-08T08:25:49.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[作用域和闭包]]></title>
        <id>https://coderdml.github.io/post/zuo-yong-yu-he-bi-bao/</id>
        <link href="https://coderdml.github.io/post/zuo-yong-yu-he-bi-bao/">
        </link>
        <updated>2022-02-07T10:40:24.000Z</updated>
        <content type="html"><![CDATA[<p>掘金链接<br>
https://juejin.cn/post/6844904165672484871</p>
<pre><code>当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找...一直找到全局作用域。我们把这种作用域的嵌套机制，称为 作用域链。

需要注意，函数参数也在函数作用域中。

词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大厂面试题]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-ji-lei/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-ji-lei/">
        </link>
        <updated>2022-02-07T09:42:52.000Z</updated>
        <content type="html"><![CDATA[<p><strong>01.字节面试题</strong><br>
123['toString'].length + 123 = ?<br>
考点1：原型链的继承<br>
123是Number的实例，继承了Number的toString方法<br>
考点2：函数的length<br>
函数的length就是形参的个数，toString方法的形参个数是一个</p>
<p>答案：124</p>
<p><strong>02.字节面试题</strong><br>
(a<mark>1&amp;&amp;a</mark>2&amp;&amp;a==3)为true？</p>
<p>思路一：利用对象的隐式转换调用toString</p>
<p>思路二：利用数组的隐式转换调用join</p>
<p>思路三：利用defineProperty</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[04.力扣剑指OFFER——JZ52 两个链表的第一个公共结点]]></title>
        <id>https://coderdml.github.io/post/04/</id>
        <link href="https://coderdml.github.io/post/04/">
        </link>
        <updated>2022-02-07T09:34:57.000Z</updated>
        <content type="html"><![CDATA[<p>描述<br>
输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p>数据范围： n \le 1000n≤1000<br>
要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)</p>
<p><strong>解题思路：</strong></p>
<p>使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。</p>
<p>让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。</p>
<p>因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。</p>
<p>（N1最后肯定能到达链表2的终点，N2肯定能到达链表1的终点）。</p>
<p>所以，如何得到公共节点：</p>
<pre><code>有公共节点的时候，N1和N2必会相遇，因为长度一样嘛，速度也一定，必会走到相同的地方的，所以当两者相等的时候，则会第一个公共的节点
无公共节点的时候，此时N1和N2则都会走到终点，那么他们此时都是null，所以也算是相等了。
</code></pre>
<p>下面看个动态图，可以更形象的表示这个过程~<br>
<img src="https://coderdml.github.io/post-images/1644226544855.gif" alt="" loading="lazy"></p>
<pre><code>function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    let p1 = pHead1
    let p2 = pHead2
    while(p1 != p2){
        if(p1)
            p1 = p1.next
        else
            p1 = pHead2
        if(p2)
            p2 = p2.next
        else
            p2 = pHead1
}
    return p1
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[03.力扣剑指OFFER——JZ25 合并两个排序的链表]]></title>
        <id>https://coderdml.github.io/post/03/</id>
        <link href="https://coderdml.github.io/post/03/">
        </link>
        <updated>2022-02-07T08:51:17.000Z</updated>
        <content type="html"><![CDATA[<p>描述<br>
输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。<br>
数据范围： 0 \le n \le 10000≤n≤1000，-1000 \le 节点值 \le 1000−1000≤节点值≤1000<br>
要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)</p>
<pre><code>构造一个链表函数，new一个虚拟头部，比较两个链表头节点的值并且向后移动节点，当有链表被遍历结束之后指针指向剩余的链表
</code></pre>
<pre><code>function Merge(pHead1, pHead2)
{
    // write code here
    function ListNode(x){
    this.val = x;
    this.next = null;
        }
    let dummy = new ListNode(-1)
    let cur = dummy
    while(pHead1 &amp;&amp; pHead2){
        if(pHead1.val &lt;= pHead2.val){
            cur.next = pHead1
            pHead1 = pHead1.next
            
        }
        else{
            cur.next = pHead2
            pHead2 = pHead2.next
            
        }
        cur = cur.next
    }
    if(!pHead1){
        cur.next = pHead2
    }
    if(!pHead2){
        cur.next = pHead1
    }
     return dummy.next
}
</code></pre>
<pre><code>function Merge(pHead1, pHead2)
{
    // write code here
    let head = {
        val: null,
        next: null,
    };
    
    let cur = head;
    while (pHead1 &amp;&amp; pHead2){
        if (pHead1.val &lt;= pHead2.val){
            cur.next = pHead1;
            cur = cur.next;
            pHead1 = pHead1.next;
        } else {
            cur.next = pHead2;
            cur = cur.next;
            pHead2 = pHead2.next;
        } 
    }
    
    if (pHead1) cur.next = pHead1;
    else cur.next = pHead2;
    
    return head.next;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[02.力扣剑指OFFER——JZ24 反转链表 ]]></title>
        <id>https://coderdml.github.io/post/02li-kou-jian-zhi-offer-jz24-fan-zhuan-lian-biao/</id>
        <link href="https://coderdml.github.io/post/02li-kou-jian-zhi-offer-jz24-fan-zhuan-lian-biao/">
        </link>
        <updated>2022-01-19T22:24:47.000Z</updated>
        <content type="html"><![CDATA[<p>要求：空间复杂度 O(1) ，时间复杂度 O(n) 。</p>
<pre><code>链表特点：只有前序节点指向后序节点的指针
</code></pre>
<p>反转链表需要使后序节点指向前序节点，pre指针指向当前节点的前一个节点，cur指针指向当前节点<br>
为防止链表断开还需要一个tmp指针保存当前节点的后序节点</p>
<p>tmp保存后序节点-&gt;改变指针指向-&gt;向后移动<br>
<img src="https://coderdml.github.io/post-images/1644216902830.png" alt="" loading="lazy"></p>
<pre><code>function ReverseList(pHead)
{
    // write code here
    let pre = null , cur = pHead
    while(cur){
        let tmp = cur.next  //用tmp保存后序节点防止链表断开
        cur.next = pre //改变当前节点的指向
        pre = cur //向后移动pre指针
        cur = tmp //向后移动cur指针
    }
    return pre
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[01.力扣剑指OFFER——JZ6 从尾到头打印链表]]></title>
        <id>https://coderdml.github.io/post/01li-kou-jian-zhi-offer-jz6-cong-wei-dao-tou-da-yin-lian-biao/</id>
        <link href="https://coderdml.github.io/post/01li-kou-jian-zhi-offer-jz6-cong-wei-dao-tou-da-yin-lian-biao/">
        </link>
        <updated>2022-01-19T22:09:14.000Z</updated>
        <content type="html"><![CDATA[<p>利用栈的先进后出特性</p>
<pre><code> /*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function printListFromTailToHead(head)
{
    let res = [];
    while(head){
        res.unshift(head.val);
        head = head.next
    }
    return res
}
module.exports = {
    printListFromTailToHead : printListFromTailToHead
};
</code></pre>
<p>或者使用push方法在尾部添加后，返回时使用reverse方法逆转数组</p>
<p>unshift()方法<br>
实例<br>
将新项添加到数组起始位置:</p>
<pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];
fruits.unshift(&quot;Lemon&quot;,&quot;Pineapple&quot;);
</code></pre>
<p>fruits 将输出：</p>
<pre><code>Lemon,Pineapple,Banana,Orange,Apple,Mango
</code></pre>
<p>unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>注意： 该方法将改变数组的数目。</p>
<p>提示: 将新项添加到数组末尾，请使用 push() 方法。</p>
<pre><code>shift方法和pop方法
删除并返回数组的第一个元素。
注：如果数组是空的，那么该方法不进行任何操作，返回 undefined。
该方法直接修改原数组。
提示：要删除并返回数组的最后一个元素，请使用 pop() 方法。
</code></pre>
]]></content>
    </entry>
</feed>