<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://coderdml.github.io</id>
    <title>Work for money</title>
    <updated>2023-04-05T03:44:08.599Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://coderdml.github.io"/>
    <link rel="self" href="https://coderdml.github.io/atom.xml"/>
    <subtitle>study for more money</subtitle>
    <logo>https://coderdml.github.io/images/avatar.png</logo>
    <icon>https://coderdml.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Work for money</rights>
    <entry>
        <title type="html"><![CDATA[面试题2]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-2/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-2/">
        </link>
        <updated>2023-04-05T03:41:56.000Z</updated>
        <content type="html"><![CDATA[<p>一、CSS<br>
1.说一下CSS的盒模型。<br>
在HTML页面中的所有元素都可以看成是一个盒子<br>
盒子的组成：内容content、内边距padding、边框border、外边距margin<br>
盒模型的类型：<br>
标准盒模型<br>
margin + border + padding + content<br>
IE盒模型<br>
margin + content(border + padding)<br>
控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）;<br>
2.CSS选择器的优先级？<br>
CSS的特性：继承性、层叠性、优先级<br>
优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式<br>
标签、类/伪类/属性、全局选择器、行内样式、id、!important<br>
!important &gt; 行内样式 &gt; id &gt; 类/伪类/属性 &gt; 标签 &gt; 全局选择器<br>
3.隐藏元素的方法有哪些？<br>
display:none;<br>
元素在页面上消失，不占据空间<br>
opacity:0;<br>
设置了元素的透明度为0，元素不可见，占据空间位置<br>
visibility:hidden;<br>
让元素消失，占据空间位置，一种不可见的状态<br>
position:absolute;<br>
clip-path<br>
4.px和rem的区别是什么？<br>
px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度<br>
rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;<br>
1rem = 10px; （16px*62.5%=10px）<br>
5.重绘重排有什么区别？<br>
重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小<br>
重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制<br>
浏览器的渲染机制<br>
对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排<br>
对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘<br>
6.让一个元素水平垂直居中的方式有哪些？<br>
1.定位+margin<br>
2.定位+transform<br>
3.flex布局<br>
4.grid布局<br>
5.table布局<br>
7.CSS的哪些属性哪些可以继承？哪些不可以继承？<br>
CSS的三大特性：继承、层叠、优先级<br>
子元素可以继承父类元素的样式<br>
1.字体的一些属性：font<br>
2.文本的一些属性：line-height<br>
3.元素的可见性：visibility:hidden<br>
4.表格布局的属性：border-spacing<br>
5.列表的属性：list-style<br>
6.页面样式属性：page<br>
7.声音的样式属性<br>
8.有没有用过预处理器？<br>
预处理语言增加了变量、函数、混入等强大的功能<br>
SASS  LESS</p>
<p>二、JavaSscipt<br>
1.JS由哪三部分组成？<br>
ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串），<br>
文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档<br>
浏览器对象模型（BOM）：对浏览器窗口进行访问和操作<br>
2.JS有哪些内置对象？<br>
String Boolean Number Array Object Function Math Date RegExp...<br>
Math<br>
abs() sqrt() max() min()<br>
Data<br>
new Data() getYear()<br>
Array<br>
String<br>
concat() length  slice() split()<br>
3.操作数组的方法有哪些？<br>
push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter()<br>
ervery() some() reduce() isArray() findIndex()<br>
哪些方法会改变原数组？<br>
push() pop() unshift() shift() sort() reverse() splice()<br>
4.JS对数据类的检测方式有哪些？<br>
typeof()<br>
instanceof()<br>
constructor<br>
Object.prototype.toString.call()<br>
5.说一下闭包，闭包有什么特点？<br>
什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包<br>
特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存再内存中，不会被垃圾回收机制回收<br>
缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏<br>
使用场景：防抖，节流，函数嵌套函数避免全局污染的时候<br>
6.前端的内存泄漏怎么理解？<br>
JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。<br>
垃圾回收机制<br>
因素：一些为生命直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。<br>
7.事件委托是什么？<br>
又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上<br>
如果子元素组织了事件冒泡，那么委托也就不成立<br>
组织事件冒泡：event.stopPropagation()<br>
addEventListener('click',函数名，true/false) 默认是false（事件冒泡），true（事件捕获）<br>
好处：提高性能，减少事件的绑定，也就减少了内存的占用。<br>
8.基本数据类型和引用数据类型的区别？<br>
基本数据类型：String Number Boolean undefined null<br>
基本数据类型保存在栈内存当中，保存的就是一个具体的值<br>
引用数据类型（复杂数据类型）：Object Function Array<br>
保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址<br>
假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变<br>
9.说一下原型链。<br>
原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象<br>
使用prototype可以把方法挂在原型上，内存值保存一份<br>
__proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）<br>
10.new操作符具体做了什么？<br>
1.先创建一个空对象<br>
2.把空对象和构造函数通过原型链进行链接<br>
3.把构造函数的this绑定到新的空对象身上<br>
4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型<br>
11.JS是如何实现继承的？<br>
1.原型链继承<br>
2.借用构造函数继承<br>
3.组合式继承<br>
4.ES6的class类继承<br>
12.JS的设计原理是什么？<br>
JS引擎 运行上下文 调用栈 事件循环 回调<br>
13.JS中关于this指向的问题<br>
1. 全局对象中的this指向<br>
指向的是window<br>
2. 全局作用域或者普通函数中的this<br>
指向全局window<br>
3. this永远指向最后调用它的那个对象<br>
在不是箭头函数的情况下<br>
4. new 关键词改变了this的指向<br>
5. apply,call,bind<br>
可以改变this指向，不是箭头函数<br>
6. 箭头函数中的this<br>
它的指向在定义的时候就已经确定了<br>
箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window<br>
7. 匿名函数中的this<br>
永远指向了window,匿名函数的执行环境具有全局性，因此this指向window<br>
14.script标签里的async和defer有什么区别？<br>
当没有async和defer这两个属性的时候，<br>
浏览器会立刻加载并执行指定的脚本<br>
有async<br>
加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）<br>
有defer<br>
加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要等<br>
所有元素解析完成之后才会执行<br>
15.setTimeout最小执行时间是多少？<br>
HTML5规定的内容：<br>
setTimeout最小执行时间是4ms<br>
setInterval最小执行时间是10ms<br>
16.ES6和ES5有什么区别？<br>
JS的组成：ECMAScript BOM  DOM<br>
ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009<br>
ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准<br>
17.ES6的新特性有哪些？<br>
1.新增块级作用域（let,const）<br>
不存在变量提升<br>
存在暂时性死区的问题<br>
块级作用域的内容<br>
不能在同一个作用域内重复声明<br>
2.新增了定义类的语法糖（class）<br>
3.新增了一种基本数据类型（symbol）<br>
4.新增了解构赋值<br>
从数组或者对象中取值，然后给变量赋值<br>
5.新增了函数参数的默认值<br>
6.给数组新增了API<br>
7.对象和数组新增了扩展运算符<br>
8.Promise<br>
解决回调地狱的问题。<br>
自身有all,reject,resolve,race方法<br>
原型上有then,catch<br>
把异步操作队列化<br>
三种状态：pending初始状态,fulfilled操作成功,rejected操作失败<br>
状态：pending -&gt; fulfilled;pending -&gt; rejected 一旦发生，状态就会凝固，不会再变<br>
async  await<br>
同步代码做异步的操作，两者必须搭配使用<br>
async表明函数内有异步操作，调用函数会返回promise<br>
await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用<br>
await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行</p>
<pre><code>    9.新增了模块化（import,export）
    10.新增了set和map数据结构
        set就是不重复
        map的key的类型不受限制
    11.新增了generator
    12.新增了箭头函数
        不能作为构造函数使用，不能用new
        箭头函数就没有原型
        箭头函数没有arguments
        箭头函数不能用call,apply,bind去改变this的执行
        this指向外层第一个函数的this
18.call,aply,bind三者有什么区别？
    都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同
    call方法传的是一个参数列表
    apply传递的是一个数组
    bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()
    call方法的性能要比apply好一些，所以call用的更多一点
19.用递归的时候有没有遇到什么问题？
    如果一个函数内可以调用函数本身，那么这个就是递归函数
    函数内部调用自己
    特别注意：写递归必须要有退出条件return
20.如何实现一个深拷贝？
    深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响
    主要针对的是引用数据类型
    1.扩展运算符
    2.JSON.parse(JSON.stringify())
    3.利用递归函数实现
21.说一下事件循环。
    JS是一个单线程的脚本语言
    主线程 执行栈 任务队列  宏任务 微任务
    主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务
    全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！
22.ajax是什么？怎么实现的？
    创建交互式网页应用的网页开发技术
        在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容
    通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面
    1.创建XmlHttpRequest对象 xmh
    2.通过xmh对象里的open()方法和服务器建立连接
    3.构建请求所需的数据，并通过xmh对象的send()发送给服务器
    4.通过xmh对象的onreadystate chansge事件监听服务器和你的通信状态
    5.接收并处理服务器响应的数据结果
    6.把处理的数据更新到HTML页面上
23.get和post有什么区别？
    1.get一般是获取数据，post一般是提交数据
    2.get参数会放在url上，所以安全性比较差，post是放在body中
    3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据
    4.get请求时会被缓存,post请求不会被缓存
    5.get请求会被保存在浏览器历史记录中,post不会
    6.get请求只能进行url编码，post请求支持很多种
24.promise的内部原理是什么？它的优缺点是什么？
    Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果
    Promise主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，
    就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差
    有三种状态：pending初始状态  fulfilled成功状态  rejected失败状态
    状态改变只会有两种情况，
        pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变
    首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消
    如果不设置回调，promise内部抛出的测u哦呜就无法反馈到外面
    若当前处于pending状态时，无法得知目前在哪个阶段。
    原理：
        构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一个是reject
        promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数
25.promise和async await的区别是什么？
    1.都是处理异步请求的方式
    2.promise是ES6，async await 是ES7的语法
    3.async await是基于promise实现的，他和promise都是非阻塞性的
    优缺点：
    1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常
    2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作
    promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作
26.浏览器的存储方式有哪些？
    1.cookies
        H5标准前的本地存储方式
        兼容性好，请求头自带cookie
        存储量小，资源浪费，使用麻烦（封装）
    2.localstorage
        H5加入的以键值对为标准的方式
        操作方便，永久存储，兼容性较好
        保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫
    3.sessionstorage
        当前页面关闭后就会立刻清理，会话级别的存储方式
    4.indexedDB
        H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景
27.token存在sessionstorage还是loaclstorage？
    token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串
    1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台
    2.存cookie中，会自动发送，缺点就是不能跨域
    如果存在localstorage中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊
    如果存在cookie中会有CSRF攻击
28.token的登录流程。
    1.客户端用账号密码请求登录
    2.服务端收到请求后，需要去验证账号密码
    3.验证成功之后，服务端会签发一个token，把这个token发送给客户端
    4.客户端收到token后保存起来，可以放在cookie也可以是localstorage
    5.客户端每次向服务端发送请求资源的时候，都需要携带这个token
    6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据
29.页面渲染的过程是怎样的？
    DNS解析
    建立TCP连接
    发送HTTP请求
    服务器处理请求
    渲染页面
        浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树
        再把CSS解析成CSSOM
        把DOM和CSSOM合并为渲染树
        布局
        把渲染树的每个节点渲染到屏幕上（绘制）
    断开TCP连接
30.DOM树和渲染树有什么区别？
    DOM树是和HTML标签一一对应的，包括head和隐藏元素
    渲染树是不包含head和隐藏元素
31.精灵图和base64的区别是什么？
    精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度
    base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串
    base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。
32.svg格式了解多少？
    基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真
    1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作
        &lt;svg&gt;&lt;/svg&gt;
    2.SVG可作为文件被引入
        &lt;img src=&quot;pic.svg&quot; /&gt;
    3.SVG可以转为base64引入页面
33.了解过JWT吗？
    JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输
    信息传输、授权
    JWT的认证流程
    1.前端把账号密码发送给后端的接口
    2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。
    3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内
    4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）
    5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果
    简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。
34.npm的底层环境是什么？
    node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境
    npm的组成：网站、注册表、命令行工具
35.HTTP协议规定的协议头和请求头有什么？
    1.请求头信息：
        Accept:浏览器告诉服务器所支持的数据类型
        Host:浏览器告诉服务器我想访问服务器的哪台主机
        Referer:浏览器告诉服务器我是从哪里来的（防盗链）
        User-Agent:浏览器类型、版本信息
        Date:浏览器告诉服务器我是什么时候访问的
        Connection:连接方式
        Cookie
        X-Request-With:请求方式
    2.响应头信息：
        Location:这个就是告诉浏览器你要去找谁
        Server:告诉浏览器服务器的类型
        Content-Type:告诉浏览器返回的数据类型
        Refresh:控制了的定时刷新
36.说一下浏览器的缓存策略。
    强缓存（本地缓存）、协商缓存（弱缓存）
    强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能
    协缓：需要像后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容
    强缓存的触发：
        HTTP1.0:时间戳响应标头
        HTTP1.1:Cache-Control响应标头
    协商缓存触发：
        HTTP1.0:请求头：if-modified-since 响应头：last-modified
        HTTP1.1:请求头：if-none-match 响应头：Etag
37.说一下什么是“同源策略”？
    http:// www.  aaa.com:8080/index/vue.js
    协议    子域名 主域名  端口号     资源
    同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击
    主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域
    三个允许跨域加载资源的标签：img  link  script
    跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！
    JSONP
    CORS
    websocket
    反向代理
38.防抖和节流是什么？
    都是应对页面中频繁触发事件的优化方案
    防抖:避免事件重复触发
    使用场景:1.频繁和服务端交互 2.输入框的自动保存事件
    节流:把频繁触发的事件减少,每隔一段时间执行
    使用场景:scroll事件
39.解释一下什么是json？
    JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输
    JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中
    JS提供了JSON.parse() JSON.stringify()
    什么时候使用json：定义接口；序列化；生成token；配置文件package.json
40.当数据没有请求过来的时候，该怎么做？
    可以在渲染数据的地方给一些默认的值
    if判断语句
41.有没有做过无感登录？
    1.在相应其中拦截，判断token返回过期后，调用刷新token的接口
    2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口
    3.写定时器，定时刷新token接口
    流程：
        1.登录成功后保存token 和 refresh_token
        2.在响应拦截器中对401状态码引入刷新token的api方法调用
        3.替换保存本地新的token
        4.把错误对象里的token替换
        5.再次发送未完成的请求
        6.如果refresh_token过期了，判断是否过期，过期了就清楚所有token重新登录
42.大文件上传是怎么做的？
    分片上传：
        1.把需要上传的文件按照一定的规则，分割成相同大小的数据块
        2.初始化一个分片上传任务，返回本次分片上传的唯一标识
        3.按照一定的规则把各个数据块上传
        4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件
    断点续传：
        服务端返回，从哪里开始  浏览器自己处理
</code></pre>
<p>三、HTML5CSS3<br>
1.语义化的理解。<br>
在写HTML页面结构时所用的标签有意义<br>
头部用head  主体用main  底部用foot...<br>
怎么判断页面是否语义化了？<br>
把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常<br>
为什么要选择语义化？<br>
1.让HTML结构更加清晰明了<br>
2.方便团队协作，利于开发<br>
3.有利于爬虫和SEO<br>
4.能够让浏览器更好的去解析代码<br>
5.给用户带来良好的体验<br>
2.H5C3有哪些新特性？<br>
H5的新特性：<br>
1.语义化的标签<br>
2.新增音频视频<br>
3.画布canvas<br>
4.数据存储localstorage sessionstorage<br>
5.增加了表单控件 email url search...<br>
6.拖拽释放API<br>
CSS3的新特性：<br>
1.新增选择器：属性选择器、伪类选择器、伪元素选择器<br>
2.增加了媒体查询<br>
3.文字阴影<br>
4.边框<br>
5.盒子模型box-sizing<br>
6.渐变<br>
7.过度<br>
8.自定义动画<br>
9.背景的属性<br>
10.2D和3D<br>
3.rem是如何做适配的？<br>
rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配<br>
rem是根据根元素font-size计算值的倍数<br>
比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem = 16px*1.2 = 19.2px.<br>
4.解决了哪些移动端的兼容问题？<br>
1.当设置样式overflow:scroll/auto时，IOS上的华东会卡顿<br>
-webkit-overflow-scrolling:touch;<br>
2.在安卓环境下placeholder文字设置行高时会偏上<br>
input有placeholder属性的时候不要设置行高<br>
3.移动端字体小于12px时异常显示<br>
应该先把在整体放大一倍，然后再用transform进行缩小<br>
4.ios下input按钮设置了disabled属性为true显示异常<br>
input[typy=button]{<br>
opcity:1<br>
}<br>
5.安卓手机下取消语音输入按钮<br>
input::-webkit-input-speech-button{<br>
display:none<br>
}<br>
6.IOS下取消input输入框在输入引文首字母默认大写<br>
<input autocapitalize='off' autocorrect='off'/><br>
7.禁用IOS和安卓用户选中文字<br>
添加全局CSS样式：-webkit-user-select:none<br>
8.禁止IOS弹出各种窗口<br>
-webkit-touch-callout:none<br>
9.禁止IOS识别长串数字为电话<br>
添加meta属性 <meta conten='telephone=no' name='format-detection'></p>
<p>四、Vue<br>
1.v-if和v-show的区别？<br>
都可以控制元素的显示和隐藏<br>
1.v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除<br>
2.v-if有一个局部编译/卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换<br>
3.v-if才是真正的条件渲染；v-show从false变成true的时候不会触发组件的声明周期，v-if会触发声明周期<br>
4.v-if的切换效率比较低  v-show的效率比较高<br>
2.如何理解MVVM的？<br>
是Model-View-ViewModel的缩写。前端开发的架构模式<br>
M：模型，对应的就是data的数据<br>
V：视图，用户界面，DOM<br>
VM：视图模型：Vue的实例对象，连接View和Model的桥梁<br>
核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定<br>
ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理<br>
3.v-for中的key值的作用是什么？<br>
key属性是DOM元素的唯一标识<br>
作用：<br>
1.提高虚拟DOM的更新<br>
2.若不设置key，可能会触发一些bug<br>
3.为了触发过度效果<br>
4.说一下你对vue生命周期的理解。<br>
组件从创建到销毁的过程就是它的生命周期<br>
创建<br>
beforeCreat<br>
在这个阶段属性和方法都不能使用<br>
created<br>
这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图<br>
挂载<br>
beforeMount<br>
完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated<br>
Mounted<br>
把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点<br>
更新<br>
beforeUpdate<br>
组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据<br>
updated<br>
render重新做了渲染，这时数据和页面都是新的，避免在此更新数据<br>
销毁<br>
beforeDestroy<br>
实例销毁前，在这里实例还可以用，可以清楚定时器等等<br>
destroyed<br>
组件已经被销毁了，全部都销毁<br>
使用了keep-alive时多出两个周期：<br>
activited<br>
组件激活时<br>
deactivited<br>
组件被销毁时<br>
5.在created和mounted去请求数据，有什么区别？<br>
created：在渲染前调用，通常先初始化属性，然后做渲染<br>
mounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作<br>
在这里请求数据可能会出现闪屏的问题，created里不会<br>
一般用created比较多<br>
请求的数据对DOM有影响，那么使用created<br>
如果请求的数据对DOM无关，可以放在mounted<br>
6.vue中的修饰符有哪些？<br>
1.事件修饰符<br>
.stop       组织冒泡<br>
.prevent    组织默认行为<br>
.capture    内部元素触发的事件先在次处理<br>
.self       只有在event.target是当前元素时触发<br>
.once       事件只会触发一次<br>
.passive    立即触发默认行为<br>
.native     把当前元素作为原生标签看待<br>
2.按键修饰符<br>
.keyup      键盘抬起<br>
.keydown    键盘按下<br>
3.系统修饰符<br>
.ctrl<br>
.alt<br>
.meta<br>
4.鼠标修饰符<br>
.left       鼠标左键<br>
.right      鼠标右键<br>
.middle     鼠标中键<br>
5.表单修饰符<br>
.lazy       等输入完之后再显示<br>
.trim       删除内容前后的空格<br>
.number     输入是数字或转为数字<br>
7.elementui是怎么做表单验证的？<br>
1.在表单中加rules属性，然后再data里写校验规则<br>
2.内部添加规则<br>
3.自定义函数校验<br>
8.vue如何进行组件通信？<br>
1.父传子<br>
props<br>
父组件使用自定义属性，然后子组件使用props<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>f</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">册</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">ref
                引用信息会注册在父组件的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">册</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span></span></span></span>refs对象上<br>
2.子传父<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">绑</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">自</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">触</mi><mi mathvariant="normal">发</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">给</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">监</mi><mi mathvariant="normal">听</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mn>3.</mn><mi mathvariant="normal">兄</mi><mi mathvariant="normal">弟</mi><mi mathvariant="normal">传</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>v</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">用</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">和</mi><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">输</mi><mn>4.</mn><mi>v</mi><mi>u</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">值</mi><mn>9.</mn><mi>k</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo>−</mo><mi>a</mi><mi>l</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">什</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">？</mi><mi mathvariant="normal">怎</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">？</mi><mi>V</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">裹</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">候</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">缓</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">活</mi><mi mathvariant="normal">跃</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">销</mi><mi mathvariant="normal">毁</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">切</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">态</mi><mi mathvariant="normal">保</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">防</mi><mi mathvariant="normal">止</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">渲</mi><mi mathvariant="normal">染</mi><mi>D</mi><mi>O</mi><mi>M</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">减</mi><mi mathvariant="normal">少</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">载</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">耗</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">提</mi><mi mathvariant="normal">高</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">验</mi><mn>10.</mn><mi>a</mi><mi>x</mi><mi>i</mi><mi>o</mi><mi>s</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">怎</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">做</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">？</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">载</mi><mi mathvariant="normal">创</mi><mi mathvariant="normal">建</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">着</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">请</mi><mi mathvariant="normal">求</mi><mi mathvariant="normal">响</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">拦</mi><mi mathvariant="normal">截</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">抛</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">口</mi><mn>11.</mn><mi>v</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">由</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">怎</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">？</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">参</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">emit
                子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数
        3.兄弟传
            new一个新的vue实例，用on和emit来对数据进行传输
        4.vuex传值
    9.keep-alive是什么？怎么使用？
        Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们
        作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验
    10.axios是怎么做封装的？
        下载 创建实例 接着封装请求响应拦截器  抛出 最后封装接口
    11.vue路由时怎么传参的？
        params传参
            this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">绑</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">触</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">监</span><span class="mord cjk_fallback">听</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord">3</span><span class="mord">.</span><span class="mord cjk_fallback">兄</span><span class="mord cjk_fallback">弟</span><span class="mord cjk_fallback">传</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">输</span><span class="mord">4</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mord">9</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">什</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">？</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">？</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">裹</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">候</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">缓</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">活</span><span class="mord cjk_fallback">跃</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">销</span><span class="mord cjk_fallback">毁</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">切</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">防</span><span class="mord cjk_fallback">止</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">渲</span><span class="mord cjk_fallback">染</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">减</span><span class="mord cjk_fallback">少</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">耗</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">体</span><span class="mord cjk_fallback">验</span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">做</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">？</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">创</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">着</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">请</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">拦</span><span class="mord cjk_fallback">截</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">抛</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">口</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">？</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>router.push({name:'index',params:{id:item.id}})<br>
this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">由</mi><mi mathvariant="normal">属</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">参</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">route.params.id
        路由属性传参
            this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>router.push({name:'/index/<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 11: {item.id}&#039;}̲)
            路…'>{item.id}&#039;})
            路由配置 { path:&#039;/index:id&#039; }
        query传参（可以解决页面刷新参数丢失的问题）
            this.</span>router.push({<br>
name:'index',<br>
query:{id:item.id}<br>
})<br>
12.vue路由的hash模式和history模式有什么区别？<br>
1.hash的路由地址上有#号，history模式没有<br>
2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404<br>
3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API<br>
4.hash不会重新加载页面，单页面应用必备<br>
5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求<br>
6.history需要后台配置<br>
13.路由拦截是怎么实现的？<br>
路由拦截 axios拦截<br>
需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截<br>
{<br>
name:'index',<br>
path:'/index',<br>
component:Index,<br>
meta:{<br>
requirtAuth:true<br>
}<br>
}<br>
router.beforeEach((to,from,next) =&gt; {<br>
if(to.meta.requirtAuth){<br>
if( store.satte.token ){<br>
next()<br>
}else{</p>
<pre><code>            }
        }
    })
14.说一下vue的动态路由。
    要在路由配置里设置meat属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转
    根据用户登录的账号，返回用户角色
    前端再根据角色，跟路由表的meta.role进行匹配
    把匹配搭配的路由形成可访问的路由
15.如何解决刷新后二次加载路由？
    1.window.location.reload()
    2.matcher
        const router = createRouter()
        export function resetRouter(){
            const newRouter = creatRouter()
            router.matcher = newRouter.matcher
        }
16.vuex刷新数据会丢失吗？怎么解决？
    vuex肯定会重新获取数据，页面也会丢失数据
    1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）
    2.页面刷新的时候，再次请求数据，达到可以动态更新的方法
        监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据
17.computed和watch的区别？
    1.computed是计算属性，watch是监听，监听的是data中数据的变化
    2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存
    3.computed不支持异步，watch是可以异步操作
    4.computed是第一次加载就监听，watch是不监听
    5.computed函数中必须有return  watch不用
18.vuex在什么场景会去使用？属性有哪些？
    state       存储变量
    getters     state的计算属性
    mutations   提交更新数据的方法
    actions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作
    modules     模块化vuex
    使用场景：
        用户的个人信息、购物车模块、订单模块
19.vue的双向数据绑定原理是什么？
    通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，
    在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图时同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。
    第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter
    第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图
    第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：
            1.在自身实例化的时候忘订阅器内添加自己
            2.自身要有一个update()方法
            3.等待属性变动时，调用自身的update方法，触发compile这种的回调
    第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果
20.了解diff算法和虚拟DOM吗？
    虚拟DOM，描述元素和元素之间的关系，创建一个JS对象
    如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改
    diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM
    步骤：
        1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面
        2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异
        3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。
21.vue和jquery的区别是什么？
    1.原理不同
        vue就是数据绑定；jq是先获取dom再处理
    2.着重点不同
        vue是数据驱动，jq是着重于页面
    3.操作不同
    4.未来发展不同
22.vuex的响应式处理。
    vuex是vue的状态管理工具
    vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图
    Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。
    vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中
23.vue中遍历全局的方法有哪些？
    1.普通遍历，对象.forEach()
        arr.forEach(function(item,index,arr){
            console.log(item,index)
        })
    2.对元素统一操作  对象.map()
        var newarr = arr.map(function(item){
            return item+1
        })
    3.查找符合条件的元素 对象.filter()
        arr.filter(function(item){
            if(item &gt; 2){
                return false
            }else{
                return true
            }
        })
    4.查询符合条件的元素，返回索引 对象.findindex()
        arr.finindex(function(item){
            if(item&gt;1){
                return true
            }else{
                return false
            }
        })
    对象.evening()  遇到不符合的对象会停止
    对象.some()  找到符合条件的元素就停止
24.如何搭建脚手架？
    下载：node  cnpm  webpack vue-cli
    创建项目：
        1.找到对应的文件，然后利用node指令创建（cmd）
        2.vue init webpack xxxx
        3.回车项目描述
        4.作者回车
        5.选择vue build
        6.回车
        7.输入n
        8.不按照yarn
        9.输入npm run dev
25.如何封装一个组件？
    1.使用Vue.extend()创建一个组件
    2.使用Vue.components()方法注册组件
    3.如果子组件需要数据，可以在props中接收定义
    4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法
    原则：
        把功能拆开
        尽量让组件原子化，一个组件做一件事情
        容器组件管数据，展示组件管视图
26.封装一个可复用的组件，需要满足什么条件？
    1.低耦合，组件之间的依赖越小越好
    2.最好从父级传入信息，不要在公共组件中请求数据
    3.传入的数据要进行校验
    4.处理事件的方法写在父组件中
27.vue的过滤器怎么使用？
    vue的特性，用来对文本进行格式化处理
    使用它的两个地方，一个是插值表达式，一个是v-bind
    分类：
        1.全局过滤器
            Vue.filter('add',function(v){
                return v &lt; 10 ? '0' + v : v
            })
            &lt;div&gt;{{33 | add}}&lt;/div&gt;
        2.本地过滤器
            和methods同级
            filter:{
                add:function(v){
                    return v &lt; 10 ? '0' + v : v
                }
            }
28.vue中如何做强制刷新？
    1.localtion.reload()
    2.this.$router.go(0)
    3.provide和inject
29.vue3和vue2有哪些区别？
    1.双向数据绑定的原理不同
    2.是否支持碎片
    3.API不同
    4.定义数据变量方法不同
    5.生命周期的不同
    6.传值不同
    7.指令和插槽不同
    8.main.js不同
30.vue的性能优化怎么做？
    1.编码优化
        不要把所有数据都放在data中
        v-for时给每个元素绑定事件用事件代理
        keep-alive缓存组件
        尽可能拆分组件，提高复用性、维护性
        key值要保证唯一
        合理使用路由懒加载，异步组件
        数据持久化存储的使用尽量用防抖、节流优化
    2.加载优化
        按需加载
        内容懒加载
        图片懒加载
    3.用户体验
        骨架屏
    4.SEO优化
        预渲染
        服务端渲染ssr
    5.打包优化
        CDN形式加载第三方模块
        多线程打包
        抽离公共文件
    6.缓存和压缩
        客户端缓存、服务端缓存
        服务端Gzip压缩
31.首屏优化该如何去做？
    1.使用路由懒加载
    2.非首屏组件使用异步组件
    3.首屏不中要的组件延迟加载
    4.静态资源放在CDN上
    5.减少首屏上JS、CSS等资源文件的大小
    6.使用服务端渲染
    7.简历减少DOM的数量和层级
    8.使用精灵图请求
    9.做一些loading
    10.开启Gzip压缩
    11.图片懒加载
32.vue3的性能为什么比vue2好？
    1.diff算法的优化
    2.静态提升
    3.事件侦听缓存
33.vue3为什么使用proxy？
    1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性
    2.proxy对代理对象的监听更加丰富
    3.proxy代理对象会生成新的对象，不会修改被代理对象本身
    4.proxy补兼容ie浏览器
34.说一下你对组件的理解。
    可以重复使用的vue实例，独一无二的组件名称
    可以抽离单独的公共模块
    提高代码的复用率
35.你是如何规划项目文件的？
    public
        图标、index.html、img
    src
        api
        assets
        components
            按分类再次划分子目录
        plugins
        router
        static
        styles
        utils
        views
    App.vue
    main.js
    package.json
    vue.config.js
36.是否使用过nuxt.js？
    是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置
    SSR：服务端渲染
        好处：
            SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索
            优化了首屏加载时间
    SEO：优化搜索引擎
    SPA的应用不利于搜索引擎SEO的操作
37.SEO如何优化？
    1.SSR
    2.预渲染 prerender-spa-plugin
</code></pre>
<p>五、Echarts<br>
1.echarts有用过吗？常用的组件有哪些？<br>
title标题组件 show  text  link<br>
toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature<br>
tooltip tigger 触发类型<br>
markPoint标注点<br>
markLine图标的标线</p>
<p>六、Uni-APP<br>
1.uni-app有没有做过分包？<br>
优化小程序的下载和启动速度<br>
小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示</p>
<p>七、Weabpack<br>
1.webpack打包和不打包的区别？<br>
1.运行效率<br>
2.对基础的支持不够<br>
2.webpack是怎么打包的，babel是做什么的？<br>
webpack会把js css image看作一个模块，用import/require引入<br>
找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起<br>
把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件<br>
如果一个被多个文件引用，打包时只会生成一个文件<br>
如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包<br>
对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中</p>
<p>八、Git<br>
1.git如何合并、拉取代码？<br>
拉取代码 git pull '仓库地址'<br>
查看状态 git sattus<br>
提交到本地缓存区  git add .<br>
提交本地仓库 git commit -m '修改描述'<br>
提交到远程仓库 git push '仓库地址' master<br>
创建分支 git branch -b xxx<br>
合并分支 git merge '合并分支的名字'<br>
2.git如何解决冲突问题？<br>
1.两个分支中修改了同一个文件<br>
2.两个分支中修改了同一个文件的名字<br>
1.解决：当前分支上，直接修改代码  add  commit<br>
2.解决：在本地当前分支上，修改冲突代码 add commit push</p>
<p>九、HR<br>
1.你的离职原因是什么？<br>
疫情 社保 薪资问题 个人发展 技术提升 家庭因素<br>
2.工作到现在，项目中遇到最难的问题是什么？怎么解决的？<br>
1.不要回答，没有问题<br>
2.不要说一些常见的简单的问题，比如：数据请求不过来、渲染页面时出现了问题、跳转路由不会...<br>
首先应该时自行去查找资料寻求解决办法，然后再去请教同时或者组长<br>
3.你的优势在哪里？<br>
1.尽量不要暴露自己的缺点<br>
2.不要过度美化自己<br>
4.如何协同工作？<br>
1.开发前会开个会议，最后形成一个开发文档<br>
2.利用工具保证项目的正常进度，规范化</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题1]]></title>
        <id>https://coderdml.github.io/post/mian-shi-ti-1/</id>
        <link href="https://coderdml.github.io/post/mian-shi-ti-1/">
        </link>
        <updated>2023-04-05T03:41:41.000Z</updated>
        <content type="html"><![CDATA[<p>第一章 面试题基础篇</p>
<p>​		1.1 HTML面试题</p>
<p>​				面试题：行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？</p>
<pre><code>行内元素：span、img、input...
块级元素：div、footer、header、section、p、h1...h6...
空元素：br、hr...


元素之间的转换问题：
display: inline;  			把某元素转换成了行内元素      ===&gt;不独占一行的，并且不能设置宽高
display: inline-block; 	把某元素转换成了行内块元素		 ===&gt;不独占一行的，可以设置宽高
display: block;					把某元素转换成了块元素			   ===&gt;独占一行，并且可以设置宽高
</code></pre>
<p>​				面试题：页面导入样式时，使用link和@import有什么区别？</p>
<pre><code>区别一：link先有，后有@import（兼容性link比@import兼容）；
区别二：加载顺序差别，浏览器先加载的标签link，后加载@import
</code></pre>
<p>​				面试题：title与h1的区别、b与strong的区别、i与em的区别？</p>
<pre><code>title与h1的区别：

定义：
	title：概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题是什么
	h1：文章主题内容，告诉蜘蛛我们的网站内容最主要是什么
区别：
	title他是显示在网页标题上、h1是显示在网页内容上
	title比h1添加的重要 (title &gt; h1 ) ==》对于seo的了解
场景：
	网站的logo都是用h1标签包裹的	
</code></pre>
<pre><code>b与strong的区别：

定义：
	b：实体标签，用来给文字加粗的。
	strong：逻辑标签，用来加强字符语气的。
区别：
	b标签只有加粗的样式，没有实际含义。
	strong表示标签内字符比较重要，用以强调的。
题外话：为了符合css3的规范，b尽量少用该用strong就行了。
</code></pre>
<pre><code>i与em的区别：

定义：
	i:实体标签，用来做文字倾斜的。
	em：是逻辑标签，用来强调文字内容的
区别：
	i只是一个倾斜标签，没有实际含义。
	em表示标签内字符重要，用以强调的。
场景：
	i更多的用在字体图标，em术语上（医药，生物）。
</code></pre>
<p>​				面试题：img标签的title和alt有什么区别？</p>
<pre><code>区别一：
	title ： 鼠标移入到图片显示的值
	alt   ： 图片无法加载时显示的值
区别二：
	在seo的层面上，蜘蛛抓取不到图片的内容，所以前端在写img标签的时候为了增加seo效果要加入alt属性来描述这张图是什么内容或者关键词。
</code></pre>
<p>​				面试题：png、jpg、gif 这些图片格式解释一下，分别什么时候用？</p>
<pre><code>png:无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标。
jpg:采用压缩算法，有一点失真，比png体积要小，适合做中大图片。
gif:一般是做动图的。
webp：同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好。
</code></pre>
<p>​		1.2 CSS面试题</p>
<p>​				面试题：介绍一下CSS的盒子模型</p>
<pre><code>CSS的盒子模型有哪些：标准盒子模型、IE盒子模型
CSS的盒子模型区别：
	标准盒子模型：margin、border、padding、content
	IE盒子模型 ：margin、content（ border +  padding  + content ）
通过CSS如何转换盒子模型：
	box-sizing: content-box;	/*标准盒子模型*/
	box-sizing: border-box;	  /*IE盒子模型*/
</code></pre>
<p>​				面试题：line-height和heigh区别【大厂】</p>
<pre><code>line-height是每一行文字的高，如果文字换行则整个盒子高度会增大（行数*行高）。
height是一个死值，就是这个盒子的高度。
</code></pre>
<p>​				面试题：CSS选择符有哪些？哪些属性可以继承？</p>
<pre><code>CSS选择符：
    通配（*）
    id选择器（#）
    类选择器（.）
    标签选择器（div、p、h1...）
    相邻选择器(+)
    后代选择器(ul li)
    子元素选择器（ &gt; ）
    属性选择器(a[href])
    
CSS属性哪些可以继承：
		文字系列：font-size、color、line-height、text-align...
***不可继承属性：border、padding、margin...
</code></pre>
<p>​				面试题：CSS优先级算法如何计算？</p>
<pre><code>优先级比较：!important &gt; 内联样式 &gt; id &gt; class &gt; 标签 &gt; 通配
</code></pre>
<pre><code>CSS权重计算：
第一：内联样式（style）  权重值:1000
第二：id选择器  				 权重值:100
第三：类选择器 				  权重值:10
第四：标签&amp;伪元素选择器   权重值:1
第五：通配、&gt;、+         权重值:0
</code></pre>
<p>​				面试题：用CSS画一个三角形</p>
<pre><code>用边框画（border）,例如：
{
		width: 0;
		height: 0;

		border-left:100px solid transparent;
		border-right:100px solid transparent;
		border-top:100px solid transparent;
		border-bottom:100px solid #ccc;
}
</code></pre>
<p>​				面试题：一个盒子不给宽度和高度如何水平垂直居中？</p>
<h5 id="方式一">方式一：</h5>
<pre><code>&lt;div class='container'&gt;
	&lt;div class='main'&gt;main&lt;/div&gt;
&lt;/div&gt;

.container{
		display: flex;
		justify-content: center;
		align-items: center;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		background: red;
}
</code></pre>
<h5 id="方式二">方式二：</h5>
<pre><code>&lt;div class='container'&gt;
	&lt;div class='main'&gt;main&lt;/div&gt;
&lt;/div&gt;

.container{
		position: relative;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		position: absolute;
		left:50%;
		top:50%;
		background: red;
		transform: translate(-50%,-50%);
}
</code></pre>
<p>​				面试题：display有哪些值？说明他们的作用。</p>
<pre><code>none     			隐藏元素
block    			把某某元素转换成块元素
inline   			把某某元素转换成内联元素
inline-block 	把某某元素转换成行内块元素
</code></pre>
<p>​				面试题：对BFC规范(块级格式化上下文：block formatting context)的理解？</p>
<pre><code>BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

1. 了解BFC ： 块级格式化上下文。
2. BFC的原则：如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外面的元素。
3. 如何触发BFC：
		float的值非none
		overflow的值非visible
		display的值为：inline-block、table-cell...
		position的值为:absoute、fixed
</code></pre>
<p>​				面试题：清除浮动有哪些方式？</p>
<pre><code>1. 触发BFC
2. 多创建一个盒子，添加样式：clear: both;
3. after方式
	ul:after{
			content: '';
			display: block;
			clear: both;
	}
</code></pre>
<p>​				面试题：在网页中的应该使用奇数还是偶数的字体？为什么呢？</p>
<pre><code>偶数 : 让文字在浏览器上表现更好看。

另外说明：ui给前端一般设计图都是偶数的，这样不管是布局也好，转换px也好，方便一点。
</code></pre>
<p>​				面试题：position有哪些值？分别是根据什么定位的？</p>
<pre><code>static [默认]  没有定位
fixed  固定定位，相对于浏览器窗口进行定位。
relative  相对于自身定位，不脱离文档流。
absolute	相对于第一个有relative的父元素，脱离文档流。


relative和absolute区别
1. relative不脱离文档流 、absolute脱离文档流
2. relative相对于自身 、 absolute相对于第一个有relative的父元素
3. relative如果有left、right、top、bottom ==》left、top
	 absolute如果有left、right、top、bottom ==》left、right、top、bottom
</code></pre>
<p>​				面试题：写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。</p>
<pre><code>双飞翼
</code></pre>
<p>​				面试题：什么是CSS reset？</p>
<pre><code>reset.css   		是一个css文件，用来重置css样式的。
normalize.css 	为了增强跨浏览器渲染的一致性，一个CSS 重置样式库。
</code></pre>
<p>​				面试题：css sprite是什么,有什么优缺点</p>
<pre><code>1. 是什么
	把多个小图标合并成一张大图片。
2. 优缺点
	优点：减少了http请求的次数，提升了性能。
	缺点：维护比较差（例如图片位置进行修改或者内容宽高修改）
</code></pre>
<p>​				面试题：display: none;与visibility: hidden;的区别</p>
<pre><code>1. 占用位置的区别
display: none; 				是不占用位置的
visibility: hidden;   虽然隐藏了，但是占用位置

2. 重绘和回流的问题

visibility: hidden; 、 display: none;  产生重绘
display: none;     还会产生一次回流

产生回流一定会造成重绘，但是重绘不一定会造成回流。

产生回流的情况：改变元素的位置(left、top...)、显示隐藏元素....
产生重绘的情况：样式改变、换皮肤
</code></pre>
<p>​				面试题：opacity 和 rgba区别</p>
<pre><code>共同性：实现透明效果

1. opacity 取值范围0到1之间，0表示完全透明，1表示不透明
2. rgba   R表示红色，G表示绿色，B表示蓝色，取值可以在正整数或者百分数。A表示透明度取值0到1之间

区别：继承的区别
opacity会继承父元素的opacity属性，而RGBA设置的元素的后代元素不会继承不透明属性。
</code></pre>
<p>​		1.3 JavaScript基础面试题</p>
<p>​				面试题：延迟加载JS有哪些方式？</p>
<pre><code>延迟加载：async、defer
		例如：&lt;script defer type=&quot;text/javascript&quot; src='script.js'&gt;&lt;/script&gt;
		
defer : 等html全部解析完成，才会执行js代码，顺次执行js脚本。
async : async是和html解析同步的（一起的），不是顺次执行js脚本（谁先加载完谁先执行）。
</code></pre>
<p>​				面试题：JS数据类型有哪些？</p>
<pre><code>基本类型：string、number、boolean、undefined、null、symbol、bigint
引用类型：object

NaN是一个数值类型，但是不是一个具体的数字。
</code></pre>
<p>​				面试题：JS数据类型考题</p>
<h5 id="考题一">考题一：</h5>
<pre><code>console.log( true + 1 );     			//2
console.log( 'name'+true );  			//nametrue
console.log( undefined + 1 ); 		//NaN
console.log( typeof undefined ); //undefined
</code></pre>
<h5 id="考题二">考题二：</h5>
<pre><code>console.log( typeof(NaN) );       //number
console.log( typeof(null) );      //object
</code></pre>
<p>​				面试题：null和undefined的区别</p>
<pre><code>1. 作者在设计js的都是先设计的null（为什么设计了null：最初设计js的时候借鉴了java的语言）
2. null会被隐式转换成0，很不容易发现错误。
3. 先有null后有undefined，出来undefined是为了填补之前的坑。

具体区别：JavaScript的最初版本是这样区分的：null是一个表示&quot;无&quot;的对象（空对象指针），转为数值时为0；undefined是一个表示&quot;无&quot;的原始值，转为数值时为NaN。
</code></pre>
<p>​				面试题：<mark>和</mark>=有什么不同？</p>
<pre><code>==  :  比较的是值
		
		string == number || boolean || number ....都会隐式转换
		通过valueOf转换（valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。）

=== ： 除了比较值，还比较类型
</code></pre>
<p>​				面试题：JS微任务和宏任务</p>
<pre><code>1. js是单线程的语言。
2. js代码执行流程：同步执行完==》事件循环
	同步的任务都执行完了，才会执行事件循环的内容
	进入事件循环：请求、定时器、事件....
3. 事件循环中包含：【微任务、宏任务】
微任务：promise.then
宏任务：setTimeout..

要执行宏任务的前提是清空了所有的微任务

流程：同步==》事件循环【微任务和宏任务】==》微任务==》宏任务=》微任务...

</code></pre>
<p>​				面试题：JS作用域考题</p>
<pre><code>1. 除了函数外，js是没有块级作用域。
2. 作用域链：内部可以访问外部的变量，但是外部不能访问内部的变量。
	 注意：如果内部有，优先查找到内部，如果内部没有就查找外部的。
3. 注意声明变量是用var还是没有写（window.）
4. 注意：js有变量提升的机制【变量悬挂声明】
5. 优先级：声明变量 &gt; 声明普通函数 &gt; 参数 &gt; 变量提升
</code></pre>
<p>面试的时候怎么看：</p>
<pre><code>1. 本层作用域有没有此变量【注意变量提升】
2. 注意：js除了函数外没有块级作用域
3. 普通声明函数是不看写函数的时候顺序
</code></pre>
<h5 id="考题一-2">考题一：</h5>
<pre><code>function c(){
	var b = 1;
	function a(){
		console.log( b );
		var b = 2;
		console.log( b );
	}
	a();
	console.log( b );
}
c();
</code></pre>
<h5 id="考题二-2">考题二：</h5>
<pre><code>var name = 'a';
(function(){
	if( typeof name == 'undefined' ){
		var name = 'b';
		console.log('111'+name);
	}else{
		console.log('222'+name);
	}
})()
</code></pre>
<h5 id="考题三">考题三：</h5>
<pre><code>function fun( a ){
	var a = 10;
	function a(){}
	console.log( a );
}
fun( 100 );
</code></pre>
<p>​				面试题：JS对象考题</p>
<p>JS对象注意点：</p>
<pre><code>1. 对象是通过new操作符构建出来的，所以对象之间不想等(除了引用外)；
2. 对象注意：引用类型(共同一个地址)；
3. 对象的key都是字符串类型；
4. 对象如何找属性|方法；
	查找规则：先在对象本身找 ===&gt; 构造函数中找 ===&gt; 对象原型中找 ===&gt; 构造函数原型中找 ===&gt; 对象上一层原型查找
</code></pre>
<h5 id="考题一-3">考题一：</h5>
<pre><code> [1,2,3] === [1,2,3]   //false
</code></pre>
<h5 id="考题二-3">考题二：</h5>
<pre><code>var obj1 = {
	a:'hellow'
}
var obj2 = obj1;
obj2.a = 'world';
console.log(obj1); 	//{a:world}
(function(){
	console.log(a); 	//undefined
	var a = 1;
})();
</code></pre>
<h5 id="考题三-2">考题三：</h5>
<pre><code>var a = {}
var b = {
	key:'a'
}
var c = {
	key:'c'
}

a[b] = '123';
a[c] = '456';

console.log( a[b] ); // 456
</code></pre>
<p>​				面试题：JS作用域+this指向+原型的考题</p>
<h5 id="考题一-4">考题一：</h5>
<pre><code>function Foo(){
	getName = function(){console.log(1)} //注意是全局的window.
	return this;
}

Foo.getName = function(){console.log(2)}
Foo.prototype.getName = function(){console.log(3)}
var getName = function(){console.log(4)}
function getName(){
	console.log(5)
}

Foo.getName();    //2
getName(); 		  //4
Foo().getName();  //1
getName();		  //1
new Foo().getName();//3
</code></pre>
<h5 id="考题二-4">考题二：</h5>
<pre><code>var o = {
	a:10,
	b:{
		a:2,
		fn:function(){
			console.log( this.a ); // 2
			console.log( this );   //代表b对象
		}
	}
}
o.b.fn();
</code></pre>
<h5 id="考题三-3">考题三：</h5>
<pre><code>window.name = 'ByteDance';
function A(){
	this.name = 123;
}
A.prototype.getA = function(){
	console.log( this );
	return this.name + 1;
}
let a = new A();
let funcA = a.getA;
funcA();  //this代表window
</code></pre>
<h5 id="考题四">考题四：</h5>
<pre><code>var length = 10;
function fn(){
	return this.length + 1;
}
var obj = {
	length:5,
	test1:function(){
		return fn();
	}
}
obj.test2 = fn;
console.log( obj.test1() ); 							//1
console.log( fn()===obj.test2() ); 				//false
console.log( obj.test1() == obj.test2() ); //false
</code></pre>
<p>​				面试题：JS判断变量是不是数组，你能写出哪些方法？</p>
<h5 id="方式一isarray">方式一：isArray</h5>
<pre><code>var arr = [1,2,3];
console.log( Array.isArray( arr ) );
</code></pre>
<h5 id="方式二instanceof-可写可不写">方式二：instanceof  【可写,可不写】</h5>
<pre><code>var arr = [1,2,3];
console.log( arr instanceof Array );
</code></pre>
<h5 id="方式三原型prototype">方式三：原型prototype</h5>
<pre><code>var arr = [1,2,3];
console.log( Object.prototype.toString.call(arr).indexOf('Array') &gt; -1 );
</code></pre>
<h4 id="方式四isprototypeof">方式四：isPrototypeOf()</h4>
<pre><code>var arr = [1,2,3];
console.log(  Array.prototype.isPrototypeOf(arr) )
</code></pre>
<h4 id="方式五constructor">方式五：constructor</h4>
<pre><code>var arr = [1,2,3];
console.log(  arr.constructor.toString().indexOf('Array') &gt; -1 )
</code></pre>
<p>​				面试题：slice是干嘛的、splice是否会改变原数组</p>
<pre><code>1. slice是来截取的
	参数可以写slice(3)、slice(1,3)、slice(-3)
	返回的是一个新的数组
2. splice 功能有：插入、删除、替换
	返回：删除的元素
	该方法会改变原数组
</code></pre>
<p>​				面试题：JS数组去重</p>
<h5 id="方式一new-set">方式一：new set</h5>
<pre><code>var arr1 = [1,2,3,2,4,1];
function unique(arr){
	return [...new Set(arr)]
}
console.log(  unique(arr1) );
</code></pre>
<h5 id="方式二indexof">方式二：indexOf</h5>
<pre><code>var arr2 = [1,2,3,2,4,1];
function unique( arr ){
	var brr = [];
	for( var i=0;i&lt;arr.length;i++){
		if(  brr.indexOf(arr[i]) == -1 ){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr2) );
</code></pre>
<h5 id="方式三sort">方式三：sort</h5>
<pre><code>var arr3 = [1,2,3,2,4,1];
function unique( arr ){
	arr = arr.sort();
	var brr = [];
	for(var i=0;i&lt;arr.length;i++){
		if( arr[i] !== arr[i-1]){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr3) );
</code></pre>
<p>​				面试题：找出多维数组最大值</p>
<pre><code>function fnArr(arr){
	var newArr = [];
	arr.forEach((item,index)=&gt;{
		newArr.push( Math.max(...item)  )
	})
	return newArr;
}
console.log(fnArr([
	[4,5,1,3],
	[13,27,18,26],
	[32,35,37,39],
	[1000,1001,857,1]
]));
</code></pre>
<p>​				面试题：给字符串新增方法实现功能</p>
<p>给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前缀的字符串，例如：</p>
<p>console.log( 'world'.addPrefix('hello') )  控制台会输出helloworld</p>
<pre><code>解答：
String.prototype.addPrefix = function(str){
	return str  + this;
}
console.log( 'world'.addPrefix('hello') )
</code></pre>
<p>​				面试题：找出字符串出现最多次数的字符以及次数</p>
<pre><code>var str = 'aaabbbbbccddddddddddx';
var obj = {};
for(var i=0;i&lt;str.length;i++){
	var char = str.charAt(i);
	if( obj[char] ){
		obj[char]++;
	}else{
		obj[char] = 1;
	}
}
console.log( obj );
//统计出来最大值
var max = 0;
for( var key in obj ){
	if( max &lt; obj[key] ){
		max = obj[key];
	}
}
//拿最大值去对比
for( var key in obj ){
	if( obj[key] == max ){
		console.log('最多的字符是'+key);
		console.log('出现的次数是'+max);
	}
}
</code></pre>
<p>​				面试题：new操作符具体做了什么</p>
<pre><code>1. 创建了一个空的对象
2. 将空对象的原型，指向于构造函数的原型
3. 将空对象作为构造函数的上下文（改变this指向）
4. 对构造函数有返回值的处理判断
</code></pre>
<pre><code>function Fun( age,name ){
	this.age = age;
	this.name = name;
}
function create( fn , ...args ){
	//1. 创建了一个空的对象
	var obj = {}; //var obj = Object.create({})
	//2. 将空对象的原型，指向于构造函数的原型
	Object.setPrototypeOf(obj,fn.prototype);
	//3. 将空对象作为构造函数的上下文（改变this指向）
	var result = fn.apply(obj,args);
	//4. 对构造函数有返回值的处理判断
	return result instanceof Object ? result : obj;
}
console.log( create(Fun,18,'张三')   )
</code></pre>
<p>​				面试题：闭包</p>
<pre><code>1. 闭包是什么
	闭包是一个函数加上到创建函数的作用域的连接，闭包“关闭”了函数的自由变量。
2. 闭包可以解决什么问题【闭包的优点】
	2.1 内部函数可以访问到外部函数的局部变量
	2.2 闭包可以解决的问题
			var lis = document.getElementsByTagName('li');
      for(var i=0;i&lt;lis.length;i++){
        (function(i){
          lis[i].onclick = function(){
            alert(i);
          }
        })(i)
      }
3. 闭包的缺点
	3.1 变量会驻留在内存中，造成内存损耗问题。
				解决：把闭包的函数设置为null
  3.2 内存泄漏【ie】 ==&gt; 可说可不说，如果说一定要提到ie
</code></pre>
<p>​				面试题：原型链</p>
<pre><code>1. 原型可以解决什么问题
	对象共享属性和共享方法
2. 谁有原型
函数拥有：prototype
对象拥有：__proto__
3. 对象查找属性或者方法的顺序
	先在对象本身查找 --&gt; 构造函数中查找 --&gt; 对象的原型 --&gt; 构造函数的原型中 --&gt; 当前原型的原型中查找
4. 原型链
	4.1 是什么？：就是把原型串联起来
	4.2 原型链的最顶端是null
</code></pre>
<p>​				面试题： JS继承有哪些方式</p>
<h5 id="方式一es6">方式一：ES6</h5>
<pre><code>class Parent{
	constructor(){
		this.age = 18;
	}
}

class Child extends Parent{
	constructor(){
		super();
		this.name = '张三';
	}
}
let o1 = new Child();
console.log( o1,o1.name,o1.age );
</code></pre>
<h5 id="方式二原型链继承">方式二：原型链继承</h5>
<pre><code>function Parent(){
	this.age = 20;
}
function Child(){
	this.name = '张三'
}
Child.prototype = new Parent();
let o2 = new Child();
console.log( o2,o2.name,o2.age );
</code></pre>
<h5 id="方式三借用构造函数继承">方式三：借用构造函数继承</h5>
<pre><code>function Parent(){
	this.age = 22;
}
function Child(){
	this.name = '张三'
	Parent.call(this);
}
let o3 = new Child();
console.log( o3,o3.name,o3.age );
</code></pre>
<h5 id="方式四组合式继承">方式四：组合式继承</h5>
<pre><code>function Parent(){
	this.age = 100;
}
function Child(){
	Parent.call(this);
	this.name = '张三'
}
Child.prototype = new Parent();
let o4 = new Child();
console.log( o4,o4.name,o4.age );
</code></pre>
<p>​				面试题：说一下call、apply、bind区别</p>
<h5 id="共同点功能一致">共同点：功能一致</h5>
<pre><code>可以改变this指向

语法： 函数.call()、函数.apply()、函数.bind()
</code></pre>
<h5 id="区别">区别：</h5>
<pre><code>1. call、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。
2. 参数不同：apply第二个参数是数组。call和bind有多个参数需要挨个写。
</code></pre>
<h5 id="场景">场景：</h5>
<pre><code>1. 用apply的情况
var arr1 = [1,2,4,5,7,3,321];
console.log( Math.max.apply(null,arr1) )

2. 用bind的情况
var btn = document.getElementById('btn');
var h1s = document.getElementById('h1s');
btn.onclick = function(){
	console.log( this.id );
}.bind(h1s)
</code></pre>
<p>​				面试题：sort背后原理是什么？</p>
<pre><code>V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。

之前的版本是：插入排序和快排，现在是冒泡

原理实现链接：https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js

***710行代码开始***
</code></pre>
<p>​				面试题：深拷贝和浅拷贝</p>
<pre><code>共同点：复制

1. 浅拷贝：只复制引用，而未复制真正的值。
var arr1 = ['a','b','c','d'];
var arr2 = arr1;

var obj1 = {a:1,b:2}
var obj2 = Object.assign(obj1);

2. 深拷贝：是复制真正的值 （不同引用）
var obj3 = {
	a:1,
	b:2
}
var obj4 = JSON.parse(JSON.stringify( obj3 ));

//递归的形式
function copyObj( obj ){
	if(  Array.isArray(obj)  ){
		var newObj = [];
	}else{
		var newObj = {};
	}
	for( var key in obj ){
		if( typeof obj[key] == 'object' ){
			newObj[key] = copyObj(obj[key]);
		}else{
			newObj[key] = obj[key];
		}
	}
	return newObj;
}
console.log(  copyObj(obj5)  );
</code></pre>
<p>​				面试题：localStorage、sessionStorage、cookie的区别</p>
<pre><code>公共点：在客户端存放数据
区别：
1. 数据存放有效期
		sessionStorage : 仅在当前浏览器窗口关闭之前有效。【关闭浏览器就没了】
		localStorage   : 始终有效，窗口或者浏览器关闭也一直保存，所以叫持久化存储。
		cookie				 : 只在设置的cookie过期时间之前有效，即使窗口或者浏览器关闭也有效。
2. localStorage、sessionStorage不可以设置过期时间
	 cookie 有过期时间，可以设置过期（把时间调整到之前的时间，就过期了）
3. 存储大小的限制
	cookie存储量不能超过4k
	localStorage、sessionStorage不能超过5M
	
	****根据不同的浏览器存储的大小是不同的。
</code></pre>
<p>​		1.4 H5/C3面试题</p>
<p>​				面试题：什么是语义化标签</p>
<pre><code>1. 易读性和维护性更好。
2. seo成分会更好，蜘蛛抓取更好。
3. IE8不兼容HTML5标签的。解决：可以通过html5shiv.js去处理。
</code></pre>
<p>​				面试题：::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p>
<pre><code>1. 区别
	:是伪类、::伪元素  ===》是为了做区分

2.是什么？作用
	元素before之前 、 元素after之后
	作用：清除浮动、样式布局上也有作用
</code></pre>
<p>​				面试题：如何关闭IOS键盘首字母自动大写</p>
<pre><code>&lt;input type=&quot;text&quot; autocapitalize='off'&gt;
</code></pre>
<p>​				面试题：怎么让Chrome支持小于12px 的文字？</p>
<pre><code>Chrome默认字体大小是：16px
**每个浏览器默认字体大小可能都不一样

&lt;style type=&quot;text/css&quot;&gt;
div{
	font-size:10px;
}
div span{
	display: inline-block;
	-webkit-transform:scale(1.6);
}
&lt;/style&gt;
</code></pre>
<p>​				面试题：rem和em区别</p>
<pre><code>相对于font-size

em针对于父元素的font-size
rem针对于根(html)元素的font-size
</code></pre>
<p>​				面试题：ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉</p>
<pre><code>&lt;style&gt;
	a,button,input,textarea{
		-webkit-tap-highlight-color: rgba(0,0,0,0);
	}
&lt;/style&gt;
</code></pre>
<p>​				面试题：webkit表单输入框placeholder的颜色值能改变吗？</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
	input::-webkit-input-placeholder{
		color:red;
	}
&lt;/style&gt;
</code></pre>
<p>​				面试题：禁止ios长按时触发系统的菜单，禁止ios&amp;android长按时下载图片</p>
<pre><code>禁止ios 长按时触发系统的菜单，禁止ios&amp;android长按时下载图片
html,body{
	touch-callout: none;
	-webkit-touch-callout: none;
	
	user-select:none;
	-webkit-user-select:none;
}
</code></pre>
<p>​				面试题：禁止ios和android用户选中文字</p>
<pre><code>html,body{
	user-select:none;
	-webkit-user-select:none;
}
</code></pre>
<p>​				面试题：自适应</p>
<pre><code>淘宝无限适配【移动端】：淘宝无限适配 + 布局单位使用rem
</code></pre>
<p>​				面试题：响应式</p>
<pre><code>1. 是什么？
	一个URL可以响应多端
2. 语法结构
	@media only screen and (max-width: 1000px){
		ul li:last-child{
			display: none;
		}
	}

	only : 可以排除不支持媒体查询的浏览器
	screen ： 设备类型
	max-width | max-height
	min-width | min-height 
3. 响应式图片【性能优化】
	&lt;picture&gt;
		&lt;source srcset=&quot;1.jpg&quot; media='(min-width:1000px)'&gt;
		&lt;source srcset=&quot;2.jpg&quot; media='(min-width:700px)'&gt;
		&lt;img srcset=&quot;3.jpg&quot;&gt;
	&lt;/picture&gt;
</code></pre>
<p>布局方案</p>
<pre><code>一、什么情况下采用响应式布局
	
	数据不是特别多，用户量不是特别大，纯展示类的项目适合响应式布局
	
	例如：公司的官网、专题页面
	
	特别追求性能的项目，不太适合响应式，因为如果添加了很多的响应式就会造成加载速度变慢。

二、pc + 移动端应该做什么样的布局方案
	注意：访问量还可以或者比较大，类似于淘宝网。
	
	pc是一套，会加入一点点响应式。
	移动端是一套，会使用自适应的布局方式。

三、pc的设计图

	ui：1980
	笔记本电脑：1280
	ui图的宽度和电脑的宽度不对应该怎么办？
		1. 把ui图进行等比缩放，缩放成和电脑一样的尺寸
		2. 换1980的电脑
		
四、移动端的设计图

	宽度：750
	因为750设计图/2就是375，正好是iphone6的尺寸，我们要把iphone6的尺寸做为基准点。
</code></pre>
<p>第二章 面试题进阶篇</p>
<p>​		2.1 ES6面试题</p>
<p>​				面试题：var、let、const区别</p>
<pre><code>var、let、const 共同点都是可以声明变量的

区别一：
	var 具有变量提升的机制
	let和const没有变量提升的机制
区别二：
	var 可以多次声明同一个变量
	let和const不可以多次声明同一个变量
区别三：
	var、let声明变量的
	const声明常量
	
	var和let声明的变量可以再次赋值，但是const不可以再次赋值了。
区别四：
	var声明的变量没有自身作用域
	let和const声明的变量有自身的作用域
</code></pre>
<p>​				面试题：作用域考题</p>
<p>考题一：let和const没有变量提升性</p>
<pre><code>console.log( str );//undefined
var str = '你好';

console.log( num );//报错
let num = 10;
</code></pre>
<p>考题二：</p>
<pre><code>function demo(){
	var n = 2;
	if( true ){
		var n = 1;
	}
	console.log( n );//1
}
demo();


function demo(){
	let n = 2;
	if( true ){
		let n = 1;
	}
	console.log( n );//2
}
demo();
</code></pre>
<p>考题三：可以修改</p>
<pre><code>const obj = {
	a:1
}
obj.a = 11111;
console.log( obj )

const arr = ['a','b','c'];
arr[0]= 'aaaaa';
console.log( arr );
</code></pre>
<p>​				面试题：将下列对象进行合并</p>
<p>方式一：Object.assign</p>
<pre><code>const a = {a:1,b:4};
const b = {b:2,c:3};

let obj1 = Object.assign(a,b);
console.log( obj1 );
</code></pre>
<p>方式二：...</p>
<pre><code>let obj2 = {...a,...b};
console.log( obj2 );
</code></pre>
<p>方式三：自己封装方法</p>
<pre><code>function extend( target,  source ){
	for(var key in source){
		target[key] = source[key];
	}
	return target;
}
console.log( extend(a,b) );
</code></pre>
<p>​				面试题：箭头函数和普通函数有什么区别？</p>
<pre><code>1. this指向的问题
	箭头函数中的this只在箭头函数定义时就决定的，而且不可修改的（call、apply、bind）
	****箭头函数的this指向定义时候、外层第一个普通函数的this
2. 箭头函数不能new（不能当作构造函数）
3. 箭头函数prototype
4. 箭头函数arguments
</code></pre>
<p>​				面试题：Promise有几种状态</p>
<pre><code>有三种状态：
pending（进行中）
fulfilled（已成功）
rejected（已失败）
</code></pre>
<p>​				面试题：find和filter的区别</p>
<pre><code>区别一：返回的内容不同
	filter 返回是新数组
	find   返回具体的内容
区别二：
	find ：匹配到第一个即返回
	filter ： 返回整体（没一个匹配到的都返回）
</code></pre>
<p>​				面试题：some和every的区别</p>
<pre><code>some  ==》 如果有一项匹配则返回true
every ==》 全部匹配才会返回true
</code></pre>
<p>​		2.2 webpack面试题</p>
<p>​				面试题：webpack插件</p>
<p>​		2.3 Git面试题</p>
<p>​				面试题：git常用命令</p>
<p>​				面试题：解决冲突</p>
<p>​				面试题：GitFlow</p>
<p>第三章 面试题框架篇</p>
<p>​		3.1 Vue面试题</p>
<p>​				面试题：Vue2.x 生命周期</p>
<pre><code>1. 有哪些生命周期
系统自带：
  beforeCreate
  created
  beforeMount
  mounted
  beforeUpdate
  updated
  beforeDestroy
  destroyed
2. 一旦进入到页面或者组件，会执行哪些生命周期，顺序。
 beforeCreate
 created
 beforeMount
 mounted
3. 在哪个阶段有$el，在哪个阶段有$data
	beforeCreate 啥也没有
	created  有data没有el
	beforeMount 有data没有el
	mounted 都有
4. 如果加入了keep-alive会多俩个生命周期
	activated、deactivated
5. 如果加入了keep-alive，第一次进入组件会执行哪些生命？
 beforeCreate
 created
 beforeMount
 mounted
 activated
6. 如果加入了keep-alive，第二次或者第N次进入组件会执行哪些生命周期？
只执行一个生命周期：activated
</code></pre>
<p>​				面试题：谈谈你对keep-alive的了解</p>
<pre><code>1. 是什么
vue系统自带的一个组件，功能：是来缓存组件的。===》提升性能
2. 使用场景
就是来缓存组件，提升项目的性能。具体实现比如：首页进入到详情页，如果用户在首页每次点击都是相同的，那么详情页就没必要请求N次了，直接缓存起来就可以了，当然如果点击的不是同一个，那么就直接请求。
</code></pre>
<p>​				面试题：v-if和v-show区别</p>
<pre><code>1. 展示形式不同
v-if是 创建一个dom节点
v-show 是display:none 、 block

2. 使用场景不同
初次加载v-if要比v-show好，页面不会做加载盒子
频繁切换v-show要比v-if好，创建和删除的开销太大了，显示和隐藏开销较小
</code></pre>
<p>​				面试题：v-if和v-for优先级</p>
<pre><code>v-for的优先级要比v-if高
***是在源码中体现的：function genElement
</code></pre>
<p>​				面试题：ref是什么？</p>
<pre><code>来获取dom的
</code></pre>
<p>​				面试题：nextTick是什么?</p>
<pre><code>获取更新后的dom内容
</code></pre>
<p>​				面试题：scoped原理</p>
<pre><code>1. 作用：让样式在本组件中生效，不影响其他组件。
2. 原理：给节点新增自定义属性，然后css根据属性选择器添加样式。
</code></pre>
<p>​				面试题：Vue中如何做样式穿透</p>
<pre><code>stylus样式穿透使用：&gt;&gt;&gt;
sass和less使用：/deep/
通用使用：  :v-deep
</code></pre>
<p>​				面试题：Vue组件传值</p>
<pre><code>父组件--&gt;子组件：

	1. 父组件：
		&lt;user-detail :myName=&quot;name&quot; /&gt;
    
    export default {
        components: {
            UserDetail
        }
        ......
    }
  2. 在子组件中使用props（可以是数组也可以是对象）接收即可。可以传多个属性。
  	export default {
      props: ['myName']
 		}

子组件--&gt;父组件：

		1. 子组件
      &lt;button @click=&quot;changeParentName&quot;&gt;改变父组件的name&lt;/button&gt;
      export default {
          methods: {
              //子组件的事件
              changeParentName: function() {
                  this.$emit('handleChange', 'Jack')
              }
          }
      }
    2. 父组件
      &lt;child @handleChange=&quot;changeName&quot;&gt;&lt;/child&gt;

      methods: {
          changeName(name) {  
              this.name = name
          }
      }

兄弟组件之间：bus.js
</code></pre>
<p>​				面试题：computed、methods、watch有什么区别？</p>
<pre><code>1. computed vs methods区别
	computed是有缓存的
	methods没有缓存
2. computed vs watch区别
	watch是监听，数据或者路由发生了改变才可以响应（执行）
	computed计算某一个属性的改变，如果某一个值改变了，计算属性会监听到进行返回
	watch是当前监听到数据改变了，才会执行内部代码
</code></pre>
<p>​				面 试题：props和data优先级谁高？</p>
<pre><code>props ===&gt;  methods ===&gt; data ===&gt; computed ===&gt;watch
</code></pre>
<p>​				面试题：Vuex有哪些属性？</p>
<pre><code>state、getters、mutations、actions、modules

state 类似于组件中data，存放数据
getters 类型于组件中computed
mutations 类似于组件中methods
actions 提交mutations的
modules 把以上4个属性再细分，让仓库更好管理
</code></pre>
<p>​				面试题：Vuex是单向数据流还是双向数据流？</p>
<pre><code>Vuex是单向数据流
</code></pre>
<p>​				面试题：Vuex中的mutaitons和actions区别</p>
<pre><code>mutaitons   :  都是同步事物
actions     :  可以包含任意异步操作

***在调试中就看出来
</code></pre>
<p>​				面试题：Vuex如何做持久化存储</p>
<pre><code>Vuex本身不是持久化存储

1. 使用localStorage自己写
2. 使用vuex-persist插件
</code></pre>
<p>​				面试题：Vue设置代理</p>
<h6 id="vueconfigjs">vue.config.js</h6>
<pre><code>module.exports = {
  publicPath:'./',
  devServer: {
    proxy: 'http://localhost:3000'
  }
}
</code></pre>
<p>​				面试题：Vue项目打包上线</p>
<pre><code>1. 自测==&gt;修改路由模式
2. 代理不生效，使用ENV
3. 修改路径
</code></pre>
<p>​				面试题：Vue路由模式</p>
<pre><code>路由模式有俩种：history、hash
区别：
	1. 表现形态不同
			history:http://localhost:8080/about
			hash:http://localhost:8080/#/about
	2. 跳转请求
			history : http://localhost:8080/id   ===&gt;发送请求
			hash 	  : 不会发送请求
	3. 打包后前端自测要使用hash，如果使用history会出现空白页
</code></pre>
<p>​				面试题：介绍一下SPA以及SPA有什么缺点</p>
<pre><code>SPA是什么？单页面应用
缺点：
	1. SEO优化不好
	2. 性能不是特别好
</code></pre>
<p>​				面试题：Vue路径传值</p>
<pre><code>1. 显式
	http://localhost:8080/about?a=1
	1.1 传：this.$router.push({
  			path:'/about',
  			query:{
  				a:1
  			}
  		})
  1.2 接：this.$route.query.a
  
2. 隐式
	http://localhost:8080/about
	2.1 传：this.$router.push({
  			name:'About',
  			params:{
  				a:1
  			}
  		})
  2.2 接：this.$route.params.a
</code></pre>
<p>​				面试题：路由导航守卫有哪些</p>
<pre><code>全局、路由独享、组件内

1. 全局
	beforeEach、beforeResolve、afterEach
2. 路由独享
	beforeEnter
3. 组件内
	beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
	
使用场景：判断是否登录，如果登录就next否则就跳转到登录页面
</code></pre>
<p>​				面试题：Vue动态路由</p>
<pre><code>场景：详情页(文章、商品)
router.js配置：
	{
    path: &quot;/list&quot;,
    name: &quot;List&quot;,
    children:[
      {
        path:&quot;/list/:id&quot;,
        name:'Details',
        component: () =&gt;
          import(&quot;../views/Details.vue&quot;),
      }
    ],
    component: () =&gt;
      import(&quot;../views/List.vue&quot;),
  },
</code></pre>
<p>​				面试题：双向绑定原理</p>
<pre><code>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。
通过Object.defineProperty()来实现数据劫持的。

1.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

2.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

3.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
</code></pre>
<p>​				面试题：什么是虚拟DOM</p>
<pre><code>其实就是数据，把dom变成数据结构。
</code></pre>
<p>​				面试题：diff算法</p>
<pre><code>利用diff算法可以更多提升dom之间对比的性能（采用虚拟dom数据进行对比）。
</code></pre>
<p>​				面试题：讲一下MVVM</p>
<pre><code>M就是data的model层
V就是view视图层
VM就是理解为v-model原理实现，通过view更新model
</code></pre>
<p>​		3.2 微信小程序面试题</p>
<p>​				面试题：如何自定义头部？</p>
<pre><code>app.json进行配置

&quot;window&quot;:{
    &quot;navigationStyle&quot;:&quot;custom&quot;,
}
</code></pre>
<p>​				面试题：不校验URL</p>
<pre><code>工具==》详情==》本地设置==》不校验合法域名  ： 项目上线前URL一定要请求到（不勾选也可以请求到数据）
</code></pre>
<p>​		3.3 uni-app面试题</p>
<p>​				面试题：生命周期</p>
<pre><code>应用生命周期、页面生命周期、组件生命周期
</code></pre>
<p>​				面试题：条件编译</p>
<pre><code>在工具中，打if出现的条件编译

例如：
&lt;!-- #ifdef H5 --&gt;
  	&lt;h1&gt;这是h5端&lt;/h1&gt;
&lt;!-- #endif --&gt;
</code></pre>
<p>第四章 面试题性能优化篇</p>
<p>​		4.1 加载优化</p>
<pre><code>1. http请求
	 能不能减少（能不能合并）
2. 图片的雪碧图
3. script标签位置
4. link标签（css引入）
</code></pre>
<p>​		4.2 图片优化</p>
<pre><code>1. 图片懒加载
2. 响应式图片
3. webp代替其他格式
4. 小图标可以改用字体图标
</code></pre>
<p>​		4.3 渲染优化</p>
<pre><code>1. 减少重绘和回流
2. 改变位置使用transform
3. 动画尽量用requestAnimationFrame，不要用定时器
</code></pre>
<p>​		4.4 首屏优化</p>
<pre><code>1. 长列表
2. 项目的html文件、css文件、图片、js文件压缩打包
</code></pre>
<p>​		4.5 vue优化</p>
<pre><code>1. keep-alive 缓存组件
2. 路由懒加载
3. 内容使用
	v-if和v-show
	computed、watch、methods
4. Object.freeze ：冻结对象
	纯展示类的接口数据，冻结就可以了
5. 使用ui组件按需引入
</code></pre>
<p>第五章 面试题兼容篇</p>
<p>​		5.1 页面样式兼容</p>
<pre><code>1. 在ios键盘中首字母大写的问题?
		&lt;input type=&quot;text&quot; autocapitalize='off'&gt;
2. ios日期转换NAN问题
		具体就是，new Date('2020-11-12 00:00:00')在ios中会为NAN
		解决方案：用new Date('2020/11/12 00:00:00')的日期格式，或者写个正则转换
3. 在移动端使用click事件有300ms延迟的问题
	 	禁止双击缩放===》meta:user-scalabel=no
4. 	移动端touch事件有穿透（点透）的问题，怎么解决？
	 	4.1 阻止默认行为 : e.preventDefault();
	 	4.2 fastclick.js
5. 安卓部分版本input的placeholder偏上
		input{
	  		 line-height:normal;
		}
</code></pre>
<p>第六章 面试题网络请求篇</p>
<p>​		6.1 跨域面试题</p>
<pre><code>前端：jsonp、vue的项目可以设置代理（打包后无效。解决：.ENV文件）
后端：CORS
</code></pre>
<p>​		6.2 http和https的区别？</p>
<pre><code>1. 端口不同

	http ：80端口
	https ：443端口
	
2. https比http更加安全
	
	***https就是证书
</code></pre>
<p>第七章 WEB安全篇</p>
<p>​		7.1 XSS攻击</p>
<pre><code>用户输入的文本框，需要替换某些特殊字符（ &lt;&gt; ... ）
</code></pre>
<p>​		7.2 SQL注入</p>
<pre><code>用户输入的文本框中不可以有特殊符号（ 引号、空格 ）
</code></pre>
<p>​		7.3 接口安全</p>
<p>第八章 其他类面试题</p>
<p>​		8.1 token</p>
<p>​		8.2 SEO</p>
<h1 id="新增面试题vue2vue3面试题">新增面试题vue2/vue3面试题</h1>
<ol>
<li>
<p>vue2双向绑定和vue3双向绑定区别</p>
</li>
<li>
<p>说一说vue2和vue3区别</p>
</li>
<li>
<p>在beforeMount中如何获取dom</p>
</li>
<li>
<p>nextTick原理</p>
</li>
<li>
<p>Vite使用过吗？说一说Vite与webpack区别</p>
</li>
<li>
<p>pinia使用过吗？说一说vuex与pinia区别</p>
</li>
<li>
<p>vue如何解决seo的问题</p>
</li>
<li>
<p>vue如何分包</p>
</li>
<li>
<p>Vue3自己封装过组件吗？如何设计一个modal组件</p>
</li>
<li>
<p>vue3提升性能有哪些点</p>
</li>
<li>
<p>Vue 3.0 性能提升主要是通过哪几方面体现的？</p>
</li>
<li>
<p>Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？</p>
</li>
<li>
<p>Proxy 相对于 Object.defineProperty 有哪些优点？</p>
</li>
<li>
<p>Vue 3.0 在编译方面有哪些优化？</p>
</li>
</ol>
<h1 id="新增微信小程序面试题">新增微信小程序面试题</h1>
<ol>
<li>体积过大如何分包</li>
<li>小程序js和javascript区别</li>
</ol>
<h1 id="新增typescript面试题">新增TypeScript面试题</h1>
<ol>
<li>ts和js有什么不同？</li>
<li>是否可以将多个.ts文件合并成一个.js文件？如果是，那么如何做？</li>
<li>内部模块和外部模块有什么区别？</li>
<li>JavaScript不支持函数重载，但TypeScript是否支持函数重载？</li>
<li>TypeScript是否支持所有面向对象的原则？</li>
<li>如何检查TypeScript中的null和undefined ？</li>
<li>TS的“接口”和“type”语句有什么区别？</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router全局路由守卫]]></title>
        <id>https://coderdml.github.io/post/vue-router-quan-ju-lu-you-shou-wei/</id>
        <link href="https://coderdml.github.io/post/vue-router-quan-ju-lu-you-shou-wei/">
        </link>
        <updated>2023-03-22T07:34:55.000Z</updated>
        <content type="html"><![CDATA[<p>全局路由监听修改页面标题<br>
在index.js中</p>
<pre><code>router.beforeEach((to,from,next)=&gt;{
    document.title = to.match[0].meta.title
    next()
})

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型和原型链]]></title>
        <id>https://coderdml.github.io/post/yuan-xing-he-yuan-xing-lian/</id>
        <link href="https://coderdml.github.io/post/yuan-xing-he-yuan-xing-lian/">
        </link>
        <updated>2023-03-17T12:14:13.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.cnblogs.com/loveyaxin/p/11151586.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试题十万字资料]]></title>
        <id>https://coderdml.github.io/post/qian-duan-mian-shi-ti-shi-wan-zi-zi-liao/</id>
        <link href="https://coderdml.github.io/post/qian-duan-mian-shi-ti-shi-wan-zi-zi-liao/">
        </link>
        <updated>2023-03-17T09:03:01.000Z</updated>
        <content type="html"><![CDATA[<p>JS 章节<br>
内置类型<br>
JS 中分为七种内置类型，七种内置类型⼜分为两⼤类型：基本类型和对象（Object）。<br>
基本类型有六种： null ， undefined ， boolean ， number ， string ， symbol 。<br>
其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使<br>
⽤中会遇到某些 Bug。 NaN 也属于 number 类型，并且 NaN 不等于⾃身。<br>
对于基本类型来说，如果使⽤字⾯量的⽅式，那么这个变量只是个字⾯量，只有在必要的时<br>
候才会转换为对应的类型<br>
对象（Object）是引⽤类型，在使⽤过程中会遇到浅拷⻉和深拷⻉的问题。<br>
Typeof<br>
typeof 对于基本类型，除了 null 都可以显示正确的类型<br>
let a = 111 // 这只是字⾯量，不是 number 类型<br>
a.toString() // 使⽤时候才会转换为对象类型<br>
let a = { name: 'FE' }<br>
let b = a<br>
b.name = 'EF'<br>
console.log(a.name) // EF<br>
typeof 对于对象，除了函数都会显示 object<br>
对于 null 来说，虽然它是基本类型，但是会显示 object ，这是⼀个存在很久了的 Bug<br>
PS：为什么会出现这种情况呢？因为在 JS 的最初版本中，使⽤的是 32 位系统，为了性能考<br>
虑使⽤低位存储了变量的类型信息， 000 开头代表是对象，然⽽ null 表示为全零，所以将<br>
它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却<br>
是⼀直流传下来。<br>
如果我们想获得⼀个变量的正确类型，可以通过 Object.prototype.toString.call(xx) 。<br>
这样我们就可以获得类似 [object Type] 的字符串。<br>
typeof 1 // 'number'<br>
typeof '1' // 'string'<br>
typeof undefined // 'undefined'<br>
typeof true // 'boolean'<br>
typeof Symbol() // 'symbol'<br>
typeof b // b 没有声明，但是还会显示 undefined<br>
typeof [] // 'object'<br>
typeof {} // 'object'<br>
typeof console.log // 'function'<br>
typeof null // 'object'<br>
类型转换<br>
转Boolean<br>
在条件判断时，除了 undefined ， null ， false ， NaN ， '' ， 0 ， -0 ，其他所有<br>
值都转为 true ，包括所有对象。<br>
对象转基本类型<br>
对象在转换基本类型时，⾸先会调⽤ valueOf 然后调⽤ toString 。并且这两个⽅法你是<br>
可以重写的。<br>
当然你也可以重写 Symbol.toPrimitive ，该⽅法在转基本类型时调⽤优先级最⾼。<br>
let a<br>
// 我们也可以这样判断 undefined<br>
a === undefined<br>
// 但是 undefined 不是保留字，能够在低版本浏览器被赋值<br>
let undefined = 1<br>
// 这样判断就会出错<br>
// 所以可以⽤下⾯的⽅式来判断，并且代码量更少<br>
// 因为 void 后⾯随便跟上⼀个组成表达式<br>
// 返回就是 undefined<br>
a === void 0<br>
let a = {<br>
valueOf() {<br>
return 0<br>
}<br>
}<br>
四则运算符<br>
只有当加法运算时，其中⼀⽅是字符串类型，就会把另⼀个也转为字符串类型。其他运算只<br>
要其中⼀⽅是数字，那么另⼀⽅就转为数字。并且加法运算会触发三种类型转换：将值转换<br>
为原始值，转换为数字，转换为字符串。<br>
对于加号需要注意这个表达式 'a' + + 'b'<br>
let a = {<br>
valueOf() {<br>
return 0;<br>
},<br>
toString() {<br>
return '1';<br>
},<br>
<a href="">Symbol.toPrimitive</a> {<br>
return 2;<br>
}<br>
}<br>
1 + a // =&gt; 3<br>
'1' + a // =&gt; '12'<br>
1 + '1' // '11'<br>
2 * '2' // 4<br>
[1, 2] + [2, 1] // '1,22,1'<br>
// [1, 2].toString() -&gt; '1,2'<br>
// [2, 1].toString() -&gt; '2,1'<br>
// '1,2' + '2,1' = '1,22,1'<br>
'a' + + 'b' // -&gt; &quot;aNaN&quot;<br>
// 因为 + 'b' -&gt; NaN<br>
// 你也许在⼀些代码中看到过 + '1' -&gt; 1<br>
==== 操作符<br>
上图中的 toPrimitive 就是对象转基本类型。<br>
这⾥来解析⼀道题⽬ [] == ![] // -&gt; true ，下⾯是这个表达式为何为 true 的步骤<br>
⽐较运算符</p>
<ol>
<li>如果是对象，就通过 toPrimitive 转换对象</li>
<li>如果是字符串，就通过 unicode 字符索引来⽐较<br>
原型<br>
// [] 转成 true，然后取反变成 false<br>
[] == false<br>
// 根据第 8 条得出<br>
[] == ToNumber(false)<br>
[] == 0<br>
// 根据第 10 条得出<br>
ToPrimitive([]) == 0<br>
// [].toString() -&gt; ''<br>
'' == 0<br>
// 根据第 6 条得出<br>
0 == 0 // -&gt; true<br>
每个函数都有 prototype 属性，除了 Function.prototype.bind() ，该属性指向原型。<br>
每个对象都有 <strong>proto</strong> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向<br>
了 [[prototype]] ，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使⽤<br>
<em>proto</em> 来访问。<br>
对象可以通过 <strong>proto</strong> 来寻找不属于该对象的属性， <strong>proto</strong> 将对象连接起来组成了<br>
原型链。<br>
如果你想更进⼀步的了解原型，可以仔细阅读 深度解析原型中的各个难点。<br>
new</li>
<li>新⽣成了⼀个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象<br>
在调⽤ new 的过程中会发⽣以上四件事情，我们也可以试着来⾃⼰实现⼀个 new<br>
对于实例对象来说，都是通过 new 产⽣的，⽆论是 function Foo() 还是 let a = { b :<br>
1 } 。<br>
对于创建⼀个对象来说，更推荐使⽤字⾯量的⽅式创建对象（⽆论性能上还是可读性）。因<br>
为你使⽤ new Object() 的⽅式创建对象需要通过作⽤域链⼀层层找到 Object ，但是你使<br>
⽤字⾯量的⽅式就没这个问题。<br>
function create() {<br>
// 创建⼀个空的对象<br>
let obj = new Object()<br>
// 获得构造函数<br>
let Con = [].shift.call(arguments)<br>
// 链接到原型<br>
obj.<strong>proto</strong> = Con.prototype<br>
// 绑定 this，执⾏构造函数<br>
let result = Con.apply(obj, arguments)<br>
// 确保 new 出来的是个对象<br>
return typeof result === 'object' ? result : obj<br>
}<br>
function Foo() {}<br>
// function 就是个语法糖<br>
// 内部等同于 new Function()<br>
let a = { b: 1 }<br>
// 这个字⾯量内部也是使⽤了 new Object()<br>
对于 new 来说，还需要注意下运算符优先级。<br>
从上图可以看出， new Foo() 的优先级⼤于 new Foo ，所以对于上述代码来说可以这样划<br>
分执⾏顺序<br>
对于第⼀个函数来说，先执⾏了 Foo.getName() ，所以结果为 1；对于后者来说，先执⾏<br>
new Foo() 产⽣了⼀个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果<br>
为 2。<br>
function Foo() {<br>
return this;<br>
}<br>
Foo.getName = function () {<br>
console.log('1');<br>
};<br>
Foo.prototype.getName = function () {<br>
console.log('2');<br>
};<br>
new Foo.getName(); // -&gt; 1<br>
new Foo().getName(); // -&gt; 2<br>
new (Foo.getName());<br>
(new Foo()).getName();<br>
instanceof<br>
instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是<br>
能找到类型的 prototype 。<br>
我们也可以试着实现⼀下 instanceof<br>
this<br>
this 是很多⼈会混淆的概念，但是其实他⼀点都不难，你只需要记住⼏个规则就可以了。<br>
function instanceof(left, right) {<br>
// 获得类型的原型<br>
let prototype = right.prototype<br>
// 获得对象的原型<br>
left = left.<strong>proto</strong><br>
// 判断对象的类型是否等于类型的原型<br>
while (true) {<br>
if (left === null)<br>
return false<br>
if (prototype === left)<br>
return true<br>
left = left.<strong>proto</strong><br>
}<br>
}<br>
function foo() {<br>
console.log(this.a)<br>
}<br>
var a = 1<br>
foo()<br>
var obj = {<br>
a: 2,<br>
foo: foo<br>
以上⼏种情况明⽩了，很多代码中的 this 应该就没什么问题了，下⾯让我们看看箭头函数<br>
中的 this<br>
箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外⾯的第⼀个不是箭头函数<br>
的函数的 this 。在这个例⼦中，因为调⽤ a 符合前⾯代码中的第⼀个情况，所以 this<br>
是 window 。并且 this ⼀旦绑定了上下⽂，就不会被任何代码改变。<br>
执⾏上下⽂<br>
当执⾏ JS 代码时，会产⽣三种执⾏上下⽂<br>
全局执⾏上下⽂<br>
函数执⾏上下⽂<br>
}<br>
obj.foo()<br>
// 以上两者情况 <code>this</code> 只依赖于调⽤函数前的对象，优先级是第⼆个情况⼤于第⼀个情况<br>
// 以下情况是优先级最⾼的，<code>this</code> 只会绑定在 <code>c</code> 上，不会被任何⽅式修改 <code>this</code> 指<br>
向<br>
var c = new foo()<br>
c.a = 3<br>
console.log(c.a)<br>
// 还有种就是利⽤ call，apply，bind 改变 this，这个优先级仅次于 new<br>
function a() {<br>
return () =&gt; {<br>
return () =&gt; {<br>
console.log(this)<br>
}<br>
}<br>
}<br>
console.log(a()()())<br>
eval 执⾏上下⽂<br>
每个执⾏上下⽂中都有三个重要的属性<br>
变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下⽂中访问<br>
作⽤域链（JS 采⽤词法作⽤域，也就是说变量的作⽤域是在定义时就决定了）<br>
this<br>
对于上述代码，执⾏栈中有两个上下⽂：全局上下⽂和函数 foo 上下⽂。<br>
对于全局上下⽂来说，VO ⼤概是这样的<br>
对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO）<br>
var a = 10<br>
function foo(i) {<br>
var b = 20<br>
}<br>
foo()<br>
stack = [<br>
globalContext,<br>
fooContext<br>
]<br>
globalContext.VO === globe<br>
globalContext.VO = {<br>
a: undefined,<br>
foo: <Function>,<br>
}<br>
对于作⽤域链，可以把它理解成包含⾃身变量对象和上级变量对象的列表，通过 [[Scope]]<br>
属性查找上级变量<br>
接下来让我们看⼀个⽼⽣常谈的例⼦， var<br>
fooContext.VO === foo.AO<br>
fooContext.AO {<br>
i: undefined,<br>
b: undefined,<br>
arguments: &lt;&gt;<br>
}<br>
// arguments 是函数独有的对象(箭头函数没有)<br>
// 该对象是⼀个伪数组，有 <code>length</code> 属性且可以通过下标访问元素<br>
// 该对象中的 <code>callee</code> 属性代表函数本身<br>
// <code>caller</code> 属性代表函数的调⽤者<br>
fooContext.[[Scope]] = [<br>
globalContext.VO<br>
]<br>
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO<br>
fooContext.Scope = [<br>
fooContext.VO,<br>
globalContext.VO<br>
]<br>
b() // call b<br>
console.log(a) // undefined<br>
var a = 'Hello world'<br>
function b() {<br>
console.log('call b')<br>
}<br>
想必以上的输出⼤家肯定都已经明⽩了，这是因为函数和变量提升的原因。通常提升的解释<br>
是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤家理解。但是更准确的解释<br>
应该是：在⽣成执⾏上下⽂时，会有两个阶段。第⼀个阶段是创建的阶段（具体步骤是创建<br>
VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数<br>
的话会将整个函数存⼊内存中，变量只声明并且赋值为 undefined，所以在第⼆个阶段，也就<br>
是代码执⾏阶段，我们可以直接提前使⽤。<br>
在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升<br>
var 会产⽣很多错误，所以在 ES6中引⼊了 let 。 let 不能在声明前使⽤，但是这并不是<br>
常说的 let 不会提升， let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前<br>
使⽤。<br>
对于⾮匿名的⽴即执⾏函数需要注意以下⼀点<br>
因为当 JS 解释器在遇到⾮匿名的⽴即执⾏函数时，会创建⼀个辅助的特定对象，然后将函数<br>
名称作为这个对象的属性，因此函数内部才可以访问到 foo ，但是这个值⼜是只读的，所以<br>
对它的赋值并不⽣效，所以打印的结果还是这个函数，并且外部的值也没有发⽣更改。<br>
b() // call b second<br>
function b() {<br>
console.log('call b fist')<br>
}<br>
function b() {<br>
console.log('call b second')<br>
}<br>
var b = 'Hello world'<br>
var foo = 1<br>
(function foo() {<br>
foo = 10<br>
console.log(foo)<br>
}()) // -&gt; ƒ foo() { foo = 10 ; console.log(foo) }<br>
闭包<br>
闭包的定义很简单：函数 A 返回了⼀个函数 B，并且函数 B 中使⽤了函数 A 的变量，函数 B<br>
就被称为闭包。<br>
你是否会疑惑，为什么函数 A 已经弹出调⽤栈了，为什么函数 B 还能引⽤到函数 A 中的变<br>
量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出<br>
哪些变量需要存储在堆上，哪些需要存储在栈上。<br>
经典⾯试题，循环中使⽤闭包解决 var 定义函数的问题<br>
specialObject = {};</li>
</ol>
<p>Scope = specialObject + Scope;</p>
<p>foo = new FunctionExpression;<br>
foo.[[Scope]] = Scope;<br>
specialObject.foo = foo; // {DontDelete}, {ReadOnly}</p>
<p>delete Scope[0]; // remove specialObject from the front of scope chain<br>
function A() {<br>
let a = 1<br>
function B() {<br>
console.log(a)<br>
}<br>
return B<br>
}<br>
for ( var i=1; i&lt;=5; i++) {<br>
setTimeout( function timer() {<br>
console.log( i );<br>
}, i<em>1000 );<br>
}<br>
⾸先因为 setTimeout 是个异步函数，所有会先把循环全部执⾏完毕，这时候 i 就是 6<br>
了，所以会输出⼀堆 6。<br>
解决办法两种，第⼀种使⽤闭包<br>
第⼆种就是使⽤ setTimeout 的第三个参数<br>
第三种就是使⽤ let 定义 i 了<br>
因为对于 let 来说，他会创建⼀个块级作⽤域，相当于<br>
for (var i = 1; i &lt;= 5; i++) {<br>
(function(j) {<br>
setTimeout(function timer() {<br>
console.log(j);<br>
}, j * 1000);<br>
})(i);<br>
}<br>
for ( var i=1; i&lt;=5; i++) {<br>
setTimeout( function timer(j) {<br>
console.log( j );<br>
}, i</em>1000, i);<br>
}<br>
for ( let i=1; i&lt;=5; i++) {<br>
setTimeout( function timer() {<br>
console.log( i );<br>
}, i<em>1000 );<br>
}<br>
{ // 形成块级作⽤域<br>
let i = 0<br>
{<br>
深浅拷⻉<br>
从上述例⼦中我们可以发现，如果给⼀个变量赋值⼀个对象，那么两者的值会是同⼀个引<br>
⽤，其中⼀⽅改变，另⼀⽅也会相应改变。<br>
通常在开发中我们不希望出现这样的问题，我们可以使⽤浅拷⻉来解决这个问题。<br>
浅拷⻉<br>
⾸先可以通过 Object.assign 来解决这个问题。<br>
let ii = i<br>
setTimeout( function timer() {<br>
console.log( ii );<br>
}, i</em>1000 );<br>
}<br>
i++<br>
{<br>
let ii = i<br>
}<br>
i++<br>
{<br>
let ii = i<br>
}<br>
...<br>
}<br>
let a = {<br>
age: 1<br>
}<br>
let b = a<br>
a.age = 2<br>
console.log(b.age) // 2<br>
当然我们也可以通过展开运算符（…）来解决<br>
通常浅拷⻉就能解决⼤部分问题了，但是当我们遇到如下情况就需要使⽤到深拷⻉了<br>
浅拷⻉只解决了第⼀层的问题，如果接下去的值中还有对象的话，那么就⼜回到刚开始的话<br>
题了，两者享有相同的引⽤。要解决这个问题，我们需要引⼊深拷⻉。<br>
let a = {<br>
age: 1<br>
}<br>
let b = Object.assign({}, a)<br>
a.age = 2<br>
console.log(b.age) // 1<br>
let a = {<br>
age: 1<br>
}<br>
let b = {...a}<br>
a.age = 2<br>
console.log(b.age) // 1<br>
let a = {<br>
age: 1,<br>
jobs: {<br>
first: 'FE'<br>
}<br>
}<br>
let b = {...a}<br>
a.jobs.first = 'native'<br>
console.log(b.jobs.first) // native<br>
深拷⻉<br>
这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。<br>
但是该⽅法也是有局限性的：<br>
会忽略 undefined<br>
会忽略 symbol<br>
不能序列化函数<br>
不能解决循环引⽤的对象<br>
let a = {<br>
age: 1,<br>
jobs: {<br>
first: 'FE'<br>
}<br>
}<br>
let b = JSON.parse(JSON.stringify(a))<br>
a.jobs.first = 'native'<br>
console.log(b.jobs.first) // FE<br>
let obj = {<br>
a: 1,<br>
b: {<br>
c: 2,<br>
d: 3,<br>
},<br>
}<br>
obj.c = obj.b<br>
obj.e = obj.a<br>
obj.b.c = obj.c<br>
obj.b.d = obj.b<br>
obj.b.e = obj.b.c<br>
let newObj = JSON.parse(JSON.stringify(obj))<br>
console.log(newObj)<br>
如果你有这么⼀个循环引⽤对象，你会发现你不能通过该⽅法深拷⻉<br>
在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化<br>
你会发现在上述情况中，该⽅法会忽略掉函数和 undefined 。<br>
但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决⼤部分问题，并且<br>
该函数是内置函数中处理深拷⻉性能最快的。当然如果你的数据中含有以上三种情况下，可<br>
以使⽤ lodash 的深拷⻉函数。<br>
如果你所需拷⻉的对象含有内置类型并且不包含函数，可以使⽤ MessageChannel<br>
let a = {<br>
age: undefined,<br>
sex: Symbol('male'),<br>
jobs: function() {},<br>
name: 'yck'<br>
}<br>
let b = JSON.parse(JSON.stringify(a))<br>
console.log(b) // {name: &quot;yck&quot;}<br>
function structuralClone(obj) {<br>
return new Promise(resolve =&gt; {<br>
const {port1, port2} = new MessageChannel();<br>
port2.onmessage = ev =&gt; resolve(ev.data);<br>
port1.postMessage(obj);<br>
});<br>
}<br>
var obj = {a: 1, b: {<br>
c: b<br>
模块化<br>
在有 Babel 的情况下，我们可以直接使⽤ ES6 的模块化<br>
CommonJS<br>
CommonJs 是 Node 独有的规范，浏览器中使⽤就需要⽤到 Browserify 解析了。<br>
}}<br>
// 注意该⽅法是异步的<br>
// 可以处理 undefined 和循环引⽤对象<br>
(async () =&gt; {<br>
const clone = await structuralClone(obj)<br>
})()<br>
// file a.js<br>
export function a() {}<br>
export function b() {}<br>
// file b.js<br>
export default function() {}<br>
import {a, b} from './a.js'<br>
import XXX from './b.js'<br>
// a.js<br>
module.exports = {<br>
a: 1<br>
}<br>
// or<br>
exports.a = 1<br>
// b.js<br>
var module = require('./a.js')<br>
module.a // -&gt; log 1<br>
在上述代码中， module.exports 和 exports 很容易混淆，让我们来看看⼤致内部实现<br>
再来说说 module.exports 和 exports ，⽤法其实是相似的，但是不能对 exports 直接<br>
赋值，不会有任何效果。<br>
对于 CommonJS 和 ES6 中的模块化的两者区别是：<br>
前者⽀持动态导⼊，也就是 require(${path}/xx.js) ，后者⽬前不⽀持，但是已有提<br>
案<br>
前者是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不<br>
⼤。⽽后者是异步导⼊，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染<br>
有很⼤影响<br>
前者在导出时都是值拷⻉，就算导出的值变了，导⼊的值也不会改变，所以如果想更新<br>
值，必须重新导⼊⼀次。但是后者采⽤实时绑定的⽅式，导⼊导出的值都指向同⼀个内存<br>
地址，所以导⼊值会跟随导出值变化<br>
var module = require('./a.js')<br>
module.a<br>
// 这⾥其实就是包装了⼀层⽴即执⾏函数，这样就不会污染全局变量了，<br>
// 重要的是 module 这⾥，module 是 Node 独有的⼀个变量<br>
module.exports = {<br>
a: 1<br>
}<br>
// 基本实现<br>
var module = {<br>
exports: {} // exports 就是个空对象<br>
}<br>
// 这个是为什么 exports 和 module.exports ⽤法相似的原因<br>
var exports = module.exports<br>
var load = function (module) {<br>
// 导出的东⻄<br>
var a = 1<br>
module.exports = a<br>
return module.exports<br>
};<br>
后者会编译成 require/exports 来执⾏的<br>
AMD<br>
AMD 是由 RequireJS 提出的<br>
防抖<br>
你是否在⽇常开发中遇到⼀个问题，在滚动事件中需要做个复杂计算或者实现⼀个按钮的防<br>
⼆次点击操作。<br>
这些需求都可以通过函数防抖动来实现。尤其是第⼀个需求，如果在频繁的事件回调中做复<br>
杂计算，很有可能导致⻚⾯卡顿，不如将多次计算合并为⼀次计算，只在⼀个精确点做操<br>
作。<br>
PS：防抖和节流的作⽤都是防⽌函数多次调⽤。区别在于，假设⼀个⽤户⼀直触发这个函<br>
数，且每次触发函数的间隔⼩于wait，防抖的情况下只会调⽤⼀次，⽽节流的 情况会每隔⼀<br>
定时间（参数wait）调⽤函数。<br>
我们先来看⼀个袖珍版的防抖理解⼀下防抖的实现：<br>
// AMD<br>
define(['./a', './b'], function(a, b) {<br>
a.do()<br>
b.do()<br>
})<br>
define(function(require, exports, module) {<br>
var a = require('./a')<br>
a.doSomething()<br>
var b = require('./b')<br>
b.doSomething()<br>
})<br>
// func是⽤户传⼊需要防抖的函数<br>
这是⼀个简单版的防抖，但是有缺陷，这个防抖只能在最后调⽤。⼀般的防抖会有immediate<br>
选项，表示是否⽴即调⽤。这两者的区别，举个栗⼦来说：<br>
例如在搜索引擎搜索问题的时候，我们当然是希望⽤户输⼊完最后⼀个字才调⽤查询接<br>
⼝，这个时候适⽤ 延迟执⾏ 的防抖函数，它总是在⼀连串（间隔⼩于wait的）函数触发之<br>
后调⽤。<br>
例如⽤户给interviewMap点star的时候，我们希望⽤户点第⼀下的时候就去调⽤接⼝，并<br>
且成功之后改变star按钮的样⼦，⽤户就可以⽴⻢得到反馈是否star成功了，这个情况适<br>
⽤ ⽴即执⾏ 的防抖函数，它总是在第⼀次调⽤，并且下⼀次调⽤必须与前⼀次调⽤的时<br>
间间隔⼤于wait才会触发。<br>
下⾯我们来实现⼀个带有⽴即执⾏选项的防抖函数<br>
// wait是等待时间<br>
const debounce = (func, wait = 50) =&gt; {<br>
// 缓存⼀个定时器id<br>
let timer = 0<br>
// 这⾥返回的函数是每次⽤户实际调⽤的防抖函数<br>
// 如果已经设定过定时器了就清空上⼀次的定时器<br>
// 开始⼀个新的定时器，延迟执⾏⽤户传⼊的⽅法<br>
return function(...args) {<br>
if (timer) clearTimeout(timer)<br>
timer = setTimeout(() =&gt; {<br>
func.apply(this, args)<br>
}, wait)<br>
}<br>
}<br>
// 不难看出如果⽤户调⽤该函数的间隔⼩于wait的情况下，上⼀次的时间还未到就被清除了，并<br>
不会执⾏函数<br>
// 这个是⽤来获取当前时间戳的<br>
function now() {<br>
return +new Date()<br>
}<br>
/**</p>
<ul>
<li>防抖函数，返回函数连续调⽤时，空闲时间必须⼤于或等于 wait，func 才会执⾏</li>
<li></li>
<li>@param {function} func 回调函数</li>
<li>@param {number} wait 表示时间窗⼝的间隔</li>
<li>@param {boolean} immediate 设置为ture时，是否⽴即调⽤函数</li>
<li>@return {function} 返回客户调⽤函数<br>
*/<br>
function debounce (func, wait = 50, immediate = true) {<br>
let timer, context, args</li>
</ul>
<p>// 延迟执⾏函数<br>
const later = () =&gt; setTimeout(() =&gt; {<br>
// 延迟函数执⾏完毕，清空缓存的定时器序号<br>
timer = null<br>
// 延迟执⾏的情况下，函数会在延迟函数中执⾏<br>
// 使⽤到之前缓存的参数和上下⽂<br>
if (!immediate) {<br>
func.apply(context, args)<br>
context = args = null<br>
}<br>
}, wait)<br>
// 这⾥返回的函数是每次实际调⽤的函数<br>
return function(...params) {<br>
// 如果没有创建延迟执⾏函数（later），就创建⼀个<br>
if (!timer) {<br>
timer = later()<br>
// 如果是⽴即执⾏，调⽤函数<br>
// 否则缓存参数和调⽤上下⽂<br>
if (immediate) {<br>
func.apply(this, params)<br>
} else {<br>
context = this<br>
args = params<br>
}<br>
// 如果已有延迟执⾏函数（later），调⽤的时候清除原来的并重新设定⼀个<br>
整体函数实现的不难，总结⼀下。<br>
对于按钮防点击来说的实现：如果函数是⽴即执⾏的，就⽴即调⽤，如果函数是延迟执⾏<br>
的，就缓存上下⽂和参数，放到延迟函数中去执⾏。⼀旦我开始⼀个定时器，只要我定时<br>
器还在，你每次点击我都重新计时。⼀旦你点累了，定时器时间到，定时器重置为<br>
null ，就可以再次点击了。<br>
对于延时执⾏函数来说的实现：清除定时器ID，如果是延迟调⽤就调⽤函数<br>
节流<br>
防抖动和节流本质是不⼀样的。防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏<br>
变成每隔⼀段时间执⾏。<br>
// 这样做延迟函数会重新计时<br>
} else {<br>
clearTimeout(timer)<br>
timer = later()<br>
}<br>
}<br>
}<br>
/**</p>
<ul>
<li>underscore 节流函数，返回函数连续调⽤时，func 执⾏频率限定为 次 / wait</li>
<li></li>
<li>@param {function} func 回调函数</li>
<li>@param {number} wait 表示时间窗⼝的间隔</li>
<li>@param {object} options 如果想忽略开始函数的的调⽤，传⼊{leading:<br>
false}。</li>
<li>如果想忽略结尾函数的调⽤，传⼊{trailing:<br>
false}</li>
<li>两者不能共存，否则函数不能执⾏</li>
<li>@return {function} 返回客户调⽤函数<br>
<em>/<br>
_.throttle = function(func, wait, options) {<br>
var context, args, result;<br>
var timeout = null;<br>
// 之前的时间戳<br>
var previous = 0;<br>
// 如果 options 没传则设为空对象<br>
if (!options) options = {};<br>
// 定时器回调函数<br>
var later = function() {<br>
// 如果设置了 leading，就将 previous 设为 0<br>
// ⽤于下⾯函数的第⼀个 if 判断<br>
previous = options.leading === false ? 0 : _.now();<br>
// 置空⼀是为了防⽌内存泄漏，⼆是为了下⾯的定时器判断<br>
timeout = null;<br>
result = func.apply(context, args);<br>
if (!timeout) context = args = null;<br>
};<br>
return function() {<br>
// 获得当前时间戳<br>
var now = <em>.now();<br>
// ⾸次进⼊前者肯定为 true<br>
// 如果需要第⼀次不执⾏函数<br>
// 就将上次时间戳设为当前的<br>
// 这样在接下来计算 remaining 的值时会⼤于0<br>
if (!previous &amp;&amp; options.leading === false) previous = now;<br>
// 计算剩余时间<br>
var remaining = wait - (now - previous);<br>
context = this;<br>
args = arguments;<br>
// 如果当前调⽤已经⼤于上次调⽤时间 + wait<br>
// 或者⽤户⼿动调了时间<br>
// 如果设置了 trailing，只会进⼊这个条件<br>
// 如果没有设置 leading，那么第⼀次会进⼊这个条件<br>
// 还有⼀点，你可能会觉得开启了定时器那么应该不会进⼊这个 if 条件了<br>
// 其实还是会进⼊的，因为定时器的延时<br>
// 并不是准确的时间，很可能你设置了2秒<br>
// 但是他需要2.2秒才触发，这时候就会进⼊这个条件<br>
if (remaining &lt;= 0 || remaining &gt; wait) {<br>
继承<br>
在 ES5 中，我们可以使⽤如下⽅式解决继承的问题<br>
// 如果存在定时器就清理掉否则会调⽤⼆次回调<br>
if (timeout) {<br>
clearTimeout(timeout);<br>
timeout = null;<br>
}<br>
previous = now;<br>
result = func.apply(context, args);<br>
if (!timeout) context = args = null;<br>
} else if (!timeout &amp;&amp; options.trailing !== false) {<br>
// 判断是否设置了定时器和 trailing<br>
// 没有的话就开启⼀个定时器<br>
// 并且不能不能同时设置 leading 和 trailing<br>
timeout = setTimeout(later, remaining);<br>
}<br>
return result;<br>
};<br>
};<br>
function Super() {}<br>
Super.prototype.getNumber = function() {<br>
return 1<br>
}<br>
function Sub() {}<br>
let s = new Sub()<br>
Sub.prototype = Object.create(Super.prototype, {<br>
constructor: {<br>
value: Sub,<br>
enumerable: false,<br>
writable: true,<br>
configurable: true<br>
以上继承实现思路就是将⼦类的原型设置为⽗类的原型<br>
在 ES6 中，我们可以通过 class 语法轻松解决这个问题<br>
但是 ES6 不是所有浏览器都兼容，所以我们需要使⽤ Babel 来编译这段代码。<br>
如果你使⽤编译过得代码调⽤ myDate.test() 你会惊奇地发现出现了报错<br>
因为在 JS 底层有限制，如果不是由 Date 构造出来的实例的话，是不能调⽤ Date ⾥的函<br>
数的。所以这也侧⾯的说明了：ES6 中的 class class 继承与 ES5 中的⼀般继承写法是不同的。<br>
既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承<br>
}<br>
})<br>
class MyDate extends Date {<br>
test() {<br>
return this.getTime()<br>
}<br>
}<br>
let myDate = new MyDate()<br>
myDate.test()<br>
以上继承实现思路：先创建⽗类实例 =&gt; 改变实例原先的 <em>proto</em></em> 转⽽连接到⼦类的<br>
prototype =&gt; ⼦类的 prototype 的 <strong>proto</strong> 改为⽗类的 prototype 。<br>
通过以上⽅法实现的继承就可以完美解决 JS 底层的这个限制。<br>
call, apply, bind 区别<br>
⾸先说下前两者的区别。<br>
call 和 apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不<br>
同。<br>
除了第⼀个参数外， call 可以接收⼀个参数列表， apply 只接受⼀个参数数组。<br>
function MyData() {<br>
}<br>
MyData.prototype.test = function () {<br>
return this.getTime()<br>
}<br>
let d = new Date()<br>
Object.setPrototypeOf(d, MyData.prototype)<br>
Object.setPrototypeOf(MyData.prototype, Date.prototype)<br>
let a = {<br>
value: 1<br>
}<br>
function getValue(name, age) {<br>
console.log(name)<br>
console.log(age)<br>
console.log(this.value)<br>
}<br>
getValue.call(a, 'yck', '24')<br>
getValue.apply(a, ['yck', '24'])<br>
模拟实现 call 和 apply<br>
可以从以下⼏点来考虑如何实现<br>
不传⼊第⼀个参数，那么默认为 window<br>
改变了 this 指向，让新的对象可以执⾏该函数。那么思路是否可以变成给新的对象添加<br>
⼀个函数，然后在执⾏完以后删除？<br>
以上就是 call 的思路， apply 的实现也类似<br>
Function.prototype.myCall = function (context) {<br>
var context = context || window<br>
// 给 context 添加⼀个属性<br>
// getValue.call(a, 'yck', '24') =&gt; a.fn = getValue<br>
context.fn = this<br>
// 将 context 后⾯的参数取出来<br>
var args = [...arguments].slice(1)<br>
// getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24')<br>
var result = context.fn(...args)<br>
// 删除 fn<br>
delete context.fn<br>
return result<br>
}<br>
Function.prototype.myApply = function (context) {<br>
var context = context || window<br>
context.fn = this<br>
var result<br>
// 需要判断是否存储第⼆个参数<br>
// 如果存在，就将第⼆个参数展开<br>
if (arguments[1]) {<br>
result = context.fn(...arguments[1])<br>
} else {<br>
result = context.fn()<br>
bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过<br>
bind 实现柯⾥化。<br>
同样的，也来模拟实现下 bind<br>
Promise 实现<br>
Promise 是 ES6 新增的语法，解决了回调地狱的问题。<br>
可以把 Promise 看成⼀个状态机。初始是 pending 状态，可以通过函数 resolve 和<br>
reject ，将状态转变为 resolved 或者 rejected 状态，状态⼀旦改变就不能再次变化。<br>
}<br>
delete context.fn<br>
return result<br>
}<br>
Function.prototype.myBind = function (context) {<br>
if (typeof this !== 'function') {<br>
throw new TypeError('Error')<br>
}<br>
var _this = this<br>
var args = [...arguments].slice(1)<br>
// 返回⼀个函数<br>
return function F() {<br>
// 因为返回了⼀个函数，我们可以 new F()，所以需要判断<br>
if (this instanceof F) {<br>
return new _this(...args, ...arguments)<br>
}<br>
return _this.apply(context, args.concat(...arguments))<br>
}<br>
}<br>
then 函数会返回⼀个 Promise 实例，并且该返回值是⼀个新的实例⽽不是之前的实例。因<br>
为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是⼀个相<br>
同实例的话，多个 then 调⽤就失去意义了。<br>
对于 then 来说，本质上可以把它看成是 flatMap<br>
// 三种状态<br>
const PENDING = &quot;pending&quot;;<br>
const RESOLVED = &quot;resolved&quot;;<br>
const REJECTED = &quot;rejected&quot;;<br>
// promise 接收⼀个函数参数，该函数会⽴即执⾏<br>
function MyPromise(fn) {<br>
let _this = this;<br>
_this.currentState = PENDING;<br>
_this.value = undefined;<br>
// ⽤于保存 then 中的回调，只有当 promise<br>
// 状态为 pending 时才会缓存，并且每个实例⾄多缓存⼀个<br>
_this.resolvedCallbacks = [];<br>
_this.rejectedCallbacks = [];<br>
_this.resolve = function (value) {<br>
if (value instanceof MyPromise) {<br>
// 如果 value 是个 Promise，递归执⾏<br>
return value.then(_this.resolve, _this.reject)<br>
}<br>
setTimeout(() =&gt; { // 异步执⾏，保证执⾏顺序<br>
if (_this.currentState === PENDING) {<br>
_this.currentState = RESOLVED;<br>
_this.value = value;<br>
_this.resolvedCallbacks.forEach(cb =&gt; cb());<br>
}<br>
})<br>
};<br>
_this.reject = function (reason) {<br>
setTimeout(() =&gt; { // 异步执⾏，保证执⾏顺序<br>
if (_this.currentState === PENDING) {<br>
_this.currentState = REJECTED;<br>
_this.value = reason;<br>
_this.rejectedCallbacks.forEach(cb =&gt; cb());<br>
}<br>
})<br>
}<br>
// ⽤于解决以下问题<br>
// new Promise(() =&gt; throw Error('error))<br>
try {<br>
fn(_this.resolve, _this.reject);<br>
} catch (e) {<br>
_this.reject(e);<br>
}<br>
}<br>
MyPromise.prototype.then = function (onResolved, onRejected) {<br>
var self = this;<br>
// 规范 2.2.7，then 必须返回⼀个新的 promise<br>
var promise2;<br>
// 规范 2.2.onResolved 和 onRejected 都为可选参数<br>
// 如果类型不是函数需要忽略，同时也实现了透传<br>
// Promise.resolve(4).then().then((value) =&gt; console.log(value))<br>
onResolved = typeof onResolved === 'function' ? onResolved : v =&gt; v;<br>
onRejected = typeof onRejected === 'function' ? onRejected : r =&gt;<br>
throw r;<br>
if (self.currentState === RESOLVED) {<br>
return (promise2 = new MyPromise(function (resolve, reject) {<br>
// 规范 2.2.4，保证 onFulfilled，onRjected 异步执⾏<br>
// 所以⽤了 setTimeout 包裹下<br>
setTimeout(function () {<br>
try {<br>
var x = onResolved(self.value);<br>
resolutionProcedure(promise2, x, resolve, reject);<br>
} catch (reason) {<br>
reject(reason);<br>
}<br>
});<br>
}));<br>
}<br>
if (self.currentState === REJECTED) {<br>
return (promise2 = new MyPromise(function (resolve, reject) {<br>
setTimeout(function () {<br>
// 异步执⾏onRejected<br>
try {<br>
var x = onRejected(self.value);<br>
resolutionProcedure(promise2, x, resolve, reject);<br>
} catch (reason) {<br>
reject(reason);<br>
}<br>
});<br>
}));<br>
}<br>
if (self.currentState === PENDING) {<br>
return (promise2 = new MyPromise(function (resolve, reject) {<br>
self.resolvedCallbacks.push(function () {<br>
// 考虑到可能会有报错，所以使⽤ try/catch 包裹<br>
try {<br>
var x = onResolved(self.value);<br>
resolutionProcedure(promise2, x, resolve, reject);<br>
} catch (r) {<br>
reject(r);<br>
}<br>
});<br>
self.rejectedCallbacks.push(function () {<br>
try {<br>
var x = onRejected(self.value);<br>
resolutionProcedure(promise2, x, resolve, reject);<br>
} catch (r) {<br>
reject(r);<br>
}<br>
});<br>
}));<br>
}<br>
};<br>
// 规范 2.3<br>
function resolutionProcedure(promise2, x, resolve, reject) {<br>
// 规范 2.3.1，x 不能和 promise2 相同，避免循环引⽤<br>
if (promise2 === x) {<br>
return reject(new TypeError(&quot;Error&quot;));<br>
}<br>
// 规范 2.3.2<br>
// 如果 x 为 Promise，状态为 pending 需要继续等待否则执⾏<br>
if (x instanceof MyPromise) {<br>
if (x.currentState === PENDING) {<br>
x.then(function (value) {<br>
// 再次调⽤该函数是为了确认 x resolve 的<br>
// 参数是什么类型，如果是基本类型就再次 resolve<br>
// 把值传给下个 then<br>
resolutionProcedure(promise2, value, resolve, reject);<br>
}, reject);<br>
} else {<br>
x.then(resolve, reject);<br>
}<br>
return;<br>
}<br>
// 规范 2.3.3.3.3<br>
// reject 或者 resolve 其中⼀个执⾏过得话，忽略其他的<br>
let called = false;<br>
// 规范 2.3.3，判断 x 是否为对象或者函数<br>
if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;))<br>
{<br>
// 规范 2.3.3.2，如果不能取出 then，就 reject<br>
try {<br>
// 规范 2.3.3.1<br>
let then = x.then;<br>
// 如果 then 是函数，调⽤ x.then<br>
if (typeof then === &quot;function&quot;) {<br>
// 规范 2.3.3.3<br>
then.call(<br>
x,<br>
y =&gt; {<br>
if (called) return;<br>
called = true;<br>
// 规范 2.3.3.3.1<br>
resolutionProcedure(promise2, y, resolve, reject);<br>
},<br>
e =&gt; {<br>
if (called) return;<br>
called = true;<br>
reject(e);<br>
}<br>
);<br>
} else {<br>
// 规范 2.3.3.4<br>
resolve(x);<br>
}<br>
} catch (e) {<br>
if (called) return;<br>
called = true;<br>
reject(e);<br>
}<br>
} else {<br>
// 规范 2.3.4，x 为基本类型<br>
resolve(x);<br>
}<br>
}<br>
以上就是根据 Promise / A+ 规范来实现的代码，可以通过 promises-aplus-tests 的完整<br>
测试<br>
Generator 实现<br>
Generator 是 ES6 中新增的语法，和 Promise ⼀样，都可以⽤来异步编程<br>
// 使⽤ * 表示这是⼀个 Generator 函数<br>
// 内部可以通过 yield 暂停代码<br>
// 通过调⽤ next 恢复执⾏<br>
function</em> test() {<br>
let a = 1 + 2;<br>
yield 2;<br>
yield 3;<br>
}<br>
let b = test();<br>
console.log(b.next()); // &gt; { value: 2, done: false }<br>
console.log(b.next()); // &gt; { value: 3, done: false }<br>
console.log(b.next()); // &gt; { value: undefined, done: true }<br>
从以上代码可以发现，加上 * 的函数执⾏后拥有了 next 函数，也就是说函数执⾏后返回<br>
了⼀个对象。每次调⽤ next 函数可以继续执⾏被暂停的代码。以下是 Generator 函数的简<br>
单实现<br>
// cb 也就是编译过的 test 函数<br>
function generator(cb) {<br>
return (function() {<br>
var object = {<br>
next: 0,<br>
stop: function() {}<br>
};<br>
return {<br>
next: function() {<br>
var ret = cb(object);<br>
if (ret === undefined) return { value: undefined, done: true };<br>
return {<br>
value: ret,<br>
done: false<br>
};<br>
}<br>
};<br>
})();<br>
}<br>
// 如果你使⽤ babel 编译后可以发现 test 函数变成了这样<br>
function test() {<br>
var a;<br>
return generator(function(_context) {<br>
while (1) {<br>
switch ((_context.prev = _context.next)) {<br>
// 可以发现通过 yield 将代码分割成⼏块<br>
// 每次执⾏ next 函数就执⾏⼀块代码<br>
// 并且表明下次需要执⾏哪块代码<br>
case 0:<br>
a = 1 + 2;<br>
Map、FlatMap 和 Reduce<br>
Map 作⽤是⽣成⼀个新数组，遍历原数组，将每个元素拿出来做⼀些变换然后 append 到新<br>
的数组中。<br>
Map 有三个参数，分别是当前索引元素，索引，原数组<br>
FlatMap 和 map 的作⽤⼏乎是相同的，但是对于多维数组来说，会将原数组降维。可以将<br>
FlatMap 看成是 map + flatten ，⽬前该函数在浏览器中还不⽀持。<br>
_context.next = 4;<br>
return 2;<br>
case 4:<br>
_context.next = 6;<br>
return 3;<br>
// 执⾏完毕<br>
case 6:<br>
case &quot;end&quot;:<br>
return _context.stop();<br>
}<br>
}<br>
});<br>
}<br>
[1, 2, 3].map((v) =&gt; v + 1)<br>
// -&gt; [2, 3, 4]<br>
['1','2','3'].map(parseInt)<br>
// parseInt('1', 0) -&gt; 1<br>
// parseInt('2', 1) -&gt; NaN<br>
// parseInt('3', 2) -&gt; NaN<br>
[1, [2], 3].flatMap((v) =&gt; v + 1)<br>
// -&gt; [2, 3, 4]<br>
如果想将⼀个多维数组彻底的降维，可以这样实现<br>
Reduce 作⽤是数组中的值组合起来，最终得到⼀个值<br>
async 和 await<br>
⼀个函数如果加上 async ，那么该函数就会返回⼀个 Promise<br>
可以把 async 看成将函数返回值使⽤ Promise.resolve() 包裹了下。<br>
await 只能在 async 函数中使⽤<br>
const flattenDeep = (arr) =&gt; Array.isArray(arr)<br>
? arr.reduce( (a, b) =&gt; [...a, ...flattenDeep(b)] , [])<br>
: [arr]<br>
flattenDeep([1, [[2], [3, [4]], 5]])<br>
function a() {<br>
console.log(1);<br>
}<br>
function b() {<br>
console.log(2);<br>
}<br>
[a, b].reduce((a, b) =&gt; a(b()))<br>
// -&gt; 2 1<br>
async function test() {<br>
return &quot;1&quot;;<br>
}<br>
console.log(test()); // -&gt; Promise {<resolved>: &quot;1&quot;}<br>
上⾯代码会先打印 finish 然后再打印 object 。因为 await 会等待 sleep 函数<br>
resolve ，所以即使后⾯是同步代码，也不会先去执⾏同步代码再来执⾏异步代码。<br>
async 和 await 相⽐直接使⽤ Promise 来说，优势在于处理 then 的调⽤链，能够更清<br>
晰准确的写出代码。缺点在于滥⽤ await 可能会导致性能问题，因为 await 会阻塞代码，<br>
也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。<br>
下⾯来看⼀个使⽤ await 的代码。<br>
对于以上代码你可能会有疑惑，这⾥说明下原理<br>
function sleep() {<br>
return new Promise(resolve =&gt; {<br>
setTimeout(() =&gt; {<br>
console.log('finish')<br>
resolve(&quot;sleep&quot;);<br>
}, 2000);<br>
});<br>
}<br>
async function test() {<br>
let value = await sleep();<br>
console.log(&quot;object&quot;);<br>
}<br>
test()<br>
var a = 0<br>
var b = async () =&gt; {<br>
a = a + await 10<br>
console.log('2', a) // -&gt; '2' 10<br>
a = (await 10) + a<br>
console.log('3', a) // -&gt; '3' 20<br>
}<br>
b()<br>
a++<br>
console.log('1', a) // -&gt; '1' 1<br>
⾸先函数 b 先执⾏，在执⾏到 await 10 之前变量 a 还是 0，因为在 await 内部实<br>
现了 generators ， generators 会保留堆栈中东⻄，所以这时候 a = 0 被保存了下<br>
来<br>
因为 await 是异步操作，遇到 await 就会⽴即返回⼀个 pending 状态的 Promise 对<br>
象，暂时返回执⾏代码的控制权，使得函数外的代码得以继续执⾏，所以会先执⾏<br>
console.log('1', a)<br>
这时候同步代码执⾏完毕，开始执⾏异步代码，将保存下来的值拿出来使⽤，这时候 a<br>
= 10<br>
然后后⾯就是常规执⾏代码了<br>
Proxy<br>
Proxy 是 ES6 中新增的功能，可以⽤来⾃定义对象中的操作<br>
可以很⽅便的使⽤ Proxy 来实现⼀个数据绑定和监听<br>
let p = new Proxy(target, handler);<br>
// <code>target</code> 代表需要添加代理的对象<br>
// <code>handler</code> ⽤来⾃定义对象中的操作<br>
let onWatch = (obj, setBind, getLogger) =&gt; {<br>
let handler = {<br>
get(target, property, receiver) {<br>
getLogger(target, property)<br>
return Reflect.get(target, property, receiver);<br>
},<br>
set(target, property, value, receiver) {<br>
setBind(value);<br>
return Reflect.set(target, property, value);<br>
}<br>
};<br>
return new Proxy(obj, handler);<br>
};<br>
let obj = { a: 1 }<br>
为什么 0.1 + 0.2 != 0.3<br>
因为 JS 采⽤ IEEE 754 双精度版本（64位），并且只要采⽤ IEEE 754 的语⾔都有该问题。<br>
我们都知道计算机表示⼗进制是采⽤⼆进制表示的，所以 0.1 在⼆进制表示为<br>
那么如何得到这个⼆进制的呢，我们可以来演算下<br>
let value<br>
let p = onWatch(obj, (v) =&gt; {<br>
value = v<br>
}, (target, property) =&gt; {<br>
console.log(<code>Get '${property}' = ${target[property]}</code>);<br>
})<br>
p.a = 2 // bind <code>value</code> to <code>2</code><br>
p.a // -&gt; Get 'a' = 2<br>
// (0011) 表示循环<br>
0.1 = 2^-4 * 1.10011(0011)<br>
⼩数算⼆进制和整数不同。乘法计算时，只计算⼩数位，整数位⽤作每⼀位的⼆进制，并且<br>
得到的第⼀位为最⾼位。所以我们得出 0.1 = 2^-4 * 1.10011(0011) ，那么 0.2 的演算<br>
也基本如上所示，只需要去掉第⼀步乘法，所以得出 0.2 = 2^-3 * 1.10011(0011) 。<br>
回来继续说 IEEE 754 双精度。六⼗四位中符号位占⼀位，整数位占⼗⼀位，其余五⼗⼆位都<br>
为⼩数位。因为 0.1 和 0.2 都是⽆限循环的⼆进制了，所以在⼩数位末尾处需要判断是否<br>
进位（就和⼗进制的四舍五⼊⼀样）。<br>
所以 2^-4 * 1.10011...001 进位后就变成了 2^-4 * 1.10011(0011 * 12次)010 。那么<br>
把这两个⼆进制加起来会得出 2^-2 * 1.0011(0011 * 11次)0100 , 这个值算成⼗进制就是<br>
0.30000000000000004<br>
元字<br>
符<br>
作⽤<br>
. 匹配任意字符除了换⾏符和回⻋符<br>
[] 匹配⽅括号内的任意字符。⽐如 [0-9] 就可以⽤来匹配任意数字<br>
^ ^9，这样使⽤代表匹配以 9 开头。[ ^ 9]，这样使⽤代表不匹配⽅括号内除了 9<br>
的字符<br>
{1, 2} 匹配 1 到 2 位字符<br>
(yck) 只匹配和 yck 相同字符串<br>
| 匹配 | 前后任意字符<br>
\ 转义</li>
<li>只匹配出现 0 次及以上 * 前的字符</li>
</ul>
<ul>
<li>只匹配出现 1 次及以上 + 前的字符<br>
? ? 之前字符可选<br>
修饰语 作⽤<br>
i 忽略⼤⼩写<br>
g 全局搜索<br>
m 多⾏<br>
下⾯说⼀下原⽣解决办法，如下代码所示<br>
正则表达式<br>
元字符<br>
修饰语<br>
parseFloat((0.1 + 0.2).toFixed(10))<br>
简写 作⽤<br>
\w 匹配字⺟数字或下划线<br>
\W 和上⾯相反<br>
\s 匹配任意的空⽩符<br>
\S 和上⾯相反<br>
\d 匹配数字<br>
\D 和上⾯相反<br>
\b 匹配单词的开始或结束<br>
\B 和上⾯相反<br>
字符简写<br>
V8 下的垃圾回收机制<br>
V8 实现了准确式 GC，GC 算法采⽤了分代式垃圾回收机制。因此，V8 将内存（堆）分为新<br>
⽣代和⽼⽣代两部分。<br>
新⽣代算法<br>
新⽣代中的对象⼀般存活时间较短，使⽤ Scavenge GC 算法。<br>
在新⽣代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必<br>
定有⼀个空间是使⽤的，另⼀个空间是空闲的。新分配的对象会被放⼊ From 空间中，当<br>
From 空间被占满时，新⽣代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到<br>
To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样<br>
GC 就结束了。<br>
⽼⽣代算法<br>
⽼⽣代中的对象⼀般存活时间较⻓且数量也多，使⽤了两个算法，分别是标记清除算法和标<br>
记压缩算法。<br>
在讲算法前，先来说下什么情况下对象会出现在⽼⽣代空间中：<br>
新⽣代中的对象是否已经经历过⼀次 Scavenge 算法，如果经历过的话，会将对象从新⽣<br>
代空间移到⽼⽣代空间中。<br>
To 空间的对象占⽐⼤⼩超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从<br>
新⽣代空间移到⽼⽣代空间中。<br>
⽼⽣代中的空间很复杂，有如下⼏个空间<br>
在⽼⽣代中，以下情况会先启动标记清除算法：<br>
某⼀个空间没有分块的时候<br>
空间中被对象超过⼀定限制<br>
空间不能保证新⽣代中的对象移动到⽼⽣代中<br>
在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有<br>
被标记的对象。在标记⼤型对内存时，可能需要⼏百毫秒才能完成⼀次标记。这就会导致⼀<br>
些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标<br>
志。在增量标记期间，GC 将标记⼯作分解为更⼩的模块，可以让 JS 应⽤逻辑在模块间隙执<br>
⾏⼀会，从⽽不⾄于让应⽤出现停顿情况。但在 2018 年，GC 技术⼜有了⼀个重⼤突破，这<br>
项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运⾏，你可以点击<br>
enum AllocationSpace {<br>
// TODO(v8:7464): Actually map this space's memory as read-only.<br>
RO_SPACE, // 不变的对象空间<br>
NEW_SPACE, // 新⽣代⽤于 GC 复制算法的空间<br>
OLD_SPACE, // ⽼⽣代常驻对象空间<br>
CODE_SPACE, // ⽼⽣代代码对象空间<br>
MAP_SPACE, // ⽼⽣代 map 对象<br>
LO_SPACE, // ⽼⽣代⼤空间对象<br>
NEW_LO_SPACE, // 新⽣代⼤空间对象<br>
FIRST_SPACE = RO_SPACE,<br>
LAST_SPACE = NEW_LO_SPACE,<br>
FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,<br>
LAST_GROWABLE_PAGED_SPACE = MAP_SPACE<br>
};<br>
该博客 详细阅读。<br>
清除对象后会造成堆内存出现碎⽚的情况，当碎⽚超过⼀定限制后会启动压缩算法。在压缩<br>
过程中，将活的对象像⼀端移动，直到所有对象都移动完成然后清理掉不需要的内存。<br>
⽹络章节<br>
事件机制<br>
事件触发三阶段<br>
事件触发有三个阶段<br>
window 往事件触发处传播，遇到注册的捕获事件会触发<br>
传播到事件触发处时触发注册的事件<br>
从事件触发处往 window 传播，遇到注册的冒泡事件会触发<br>
事件触发⼀般来说会按照上⾯的顺序进⾏，但是也有特例，如果给⼀个⽬标节点同时注册冒<br>
泡和捕获事件，事件触发会按照注册的顺序执⾏。<br>
注册事件<br>
通常我们使⽤ addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是<br>
对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。 useCapture 决定了<br>
注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使⽤以下⼏个属性<br>
// 以下会先打印冒泡然后是捕获<br>
node.addEventListener('click',(event) =&gt;{<br>
console.log('冒泡')<br>
},false);<br>
node.addEventListener('click',(event) =&gt;{<br>
console.log('捕获 ')<br>
},true)<br>
capture ，布尔值，和 useCapture 作⽤⼀样<br>
once ，布尔值，值为 true 表示该回调只会调⽤⼀次，调⽤后会移除监听<br>
passive ，布尔值，表示永远不会调⽤ preventDefault<br>
⼀般来说，我们只希望事件只触发在⽬标上，这时候可以使⽤ stopPropagation 来阻⽌事<br>
件的进⼀步传播。通常我们认为 stopPropagation 是⽤来阻⽌事件冒泡的，其实该函数也<br>
可以阻⽌捕获事件。 stopImmediatePropagation 同样也能实现阻⽌事件，但是还能阻⽌该<br>
事件⽬标执⾏别的注册事件。<br>
事件代理<br>
如果⼀个节点中的⼦节点是动态⽣成的，那么⼦节点需要注册事件的话应该注册在⽗节点上<br>
node.addEventListener('click',(event) =&gt;{<br>
event.stopImmediatePropagation()<br>
console.log('冒泡')<br>
},false);<br>
// 点击 node 只会执⾏上⾯的函数，该函数不会执⾏<br>
node.addEventListener('click',(event) =&gt; {<br>
console.log('捕获 ')<br>
},true)<br>
事件代理的⽅式相对于直接给⽬标注册事件来说，有以下优点<br>
节省内存<br>
不需要给⼦节点注销事件<br>
跨域<br>
因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端⼝有⼀个不同就<br>
是跨域，Ajax 请求会失败。<br>
我们可以通过以下⼏种常⽤⽅法解决跨域的问题<br>
JSONP<br>
JSONP 的原理很简单，就是利⽤ <script> 标签没有跨域限制的漏洞。通过 <script> 标<br>
签指向⼀个需要访问的地址并提供⼀个回调函数来接收数据当需要通讯时。</li>
</ul>
<ul id="ul">
 <li>1</li>
 <li>2</li>
 <li>3</li>
 <li>4</li>
 <li>5</li>
</ul>
<script>
 let ul = document.querySelector('#ul')
 ul.addEventListener('click', (event) => {
 console.log(event.target);
 })
</script>
JSONP 使⽤简单且兼容性不错，但是只限于 get 请求。
在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要⾃⼰封装⼀个
JSONP，以下是简单实现
<script src="http://domain/api?param1=a&param2=b&callback=jsonp">
</script>
<script>
 function jsonp(data) {
 console.log(data)
 }
</script>
function jsonp(url, jsonpCallback, success) {
 let script = document.createElement("script");
 script.src = url;
 script.async = true;
 script.type = "text/javascript";
 window[jsonpCallback] = function(data) {
 success && success(data);
 };
 document.body.appendChild(script);
}
jsonp(
 "http://xxx",
 "callback",
 function(value) {
 console.log(value);
 }
);
CORS
CORS需要浏览器和后端同时⽀持。IE 8 和 9 需要通过 XDomainRequest 来实现。
浏览器会⾃动进⾏ CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就
实现了跨域。
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以
访问资源，如果设置通配符则表示所有⽹站都可以访问资源。
document.domain
该⽅式只能⽤于⼆级域名相同的情况下，⽐如 a.test.com 和 b.test.com 适⽤于该⽅式。
只需要给⻚⾯添加 document.domain = 'test.com' 表示⼆级域名都相同就可以实现跨域
postMessage
这种⽅式通常⽤于获取嵌⼊⻚⾯中的第三⽅⻚⾯数据。⼀个⻚⾯发送消息，另⼀个⻚⾯判断
来源并接收消息
// 发送消息端
window.parent.postMessage('message', 'http://test.com');
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener('message', (event) => {
 var origin = event.origin || event.originalEvent.origin;
 if (origin === 'http://test.com') {
 console.log('验证通过')
 }
});
Event loop
众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的。如果
JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加
节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题。
JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异
步的代码，会被挂起并加⼊到 Task（有多种 task） 队列中。⼀旦执⾏栈为空，Event Loop
就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说 JS 中的异步
还是同步⾏为。
以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数
第⼆个参数不得⼩于 4 毫秒，不⾜会⾃动增加。所以 setTimeout 还是会在 script end
之后打印。
不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任
务（macrotask）。在 ES6 规范中，microtask 称为 jobs ，macrotask 称为 task 。
console.log('script start');
setTimeout(function() {
 console.log('setTimeout');
}, 0);
console.log('script end');
console.log('script start');
setTimeout(function() {
 console.log('setTimeout');
}, 0);
new Promise((resolve) => {
 console.log('Promise')
 resolve()
以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务⽽
setTimeout 属于宏任务，所以会有以上的打印。
微任务包括 process.nextTick ， promise ， Object.observe ， MutationObserver
宏任务包括 script ， setTimeout ， setInterval ， setImmediate ， I/O ， UI
rendering
很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，
浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务。
所以正确的⼀次 Event loop 顺序是这样的
1. 执⾏同步代码，这属于宏任务
2. 执⾏栈为空，查询是否有微任务需要执⾏
3. 执⾏所有微任务
4. 必要的话渲染 UI
5. 然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码
通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有⼤量的计算并且需要操作
DOM 的话，为了更快的 界⾯响应，我们可以把操作 DOM 放⼊微任务中。
}).then(function() {
 console.log('promise1');
}).then(function() {
 console.log('promise2');
});
console.log('script end');
// script start => Promise => script end => promise1 => promise2 =>
setTimeout
Node 中的 Event loop
Node 中的 Event loop 和浏览器中的不相同。
Node 的 Event loop 分为6个阶段，它们会按照顺序反复运⾏
timer
timers 阶段会执⾏ setTimeout 和 setInterval
⼀个 timer 指定的时间并不是准确时间，⽽是在达到这个时间后尽快执⾏回调，可能会因为
系统正在执⾏别的事务⽽延迟。
下限的时间有⼀个范围： [1, 2147483647] ，如果设定的时间不在这个范围，将被设置为
1。
!"""""""""""""""""""""""#
!">$ timers $
$ %""""""""""&""""""""""""'
$ !""""""""""(""""""""""""#
$ $ I/O callbacks $
$ %""""""""""&""""""""""""'
$ !""""""""""(""""""""""""#
$ $ idle, prepare $
$ %""""""""""&""""""""""""' !"""""""""""""""#
$ !""""""""""(""""""""""""# $ incoming: $
$ $ poll $<""connections""" $
$ %""""""""""&""""""""""""' $ data, etc. $
$ !""""""""""(""""""""""""# %"""""""""""""""'
$ $ check $
$ %""""""""""&""""""""""""'
$ !""""""""""(""""""""""""#
%"") close callbacks $
 %"""""""""""""""""""""""'
I/O
I/O 阶段会执⾏除了 close 事件，定时器和 setImmediate 的回调
idle, prepare
idle, prepare 阶段内部实现
poll
poll 阶段很重要，这⼀阶段中，系统会做两件事情
1. 执⾏到点的定时器
2. 执⾏ poll 队列中的事件
并且当 poll 中没有定时器的情况下，会发现以下两件事情
如果 poll 队列不为空，会遍历回调队列并同步执⾏，直到队列为空或者系统限制
如果 poll 队列为空，会有两件事发⽣
如果有 setImmediate 需要执⾏，poll 阶段会停⽌并且进⼊到 check 阶段执⾏
setImmediate
如果没有 setImmediate 需要执⾏，会等待回调被加⼊到队列中并⽴即执⾏回调
如果有别的定时器需要被执⾏，会回到 timer 阶段执⾏回调。
check
check 阶段执⾏ setImmediate
close callbacks
close callbacks 阶段执⾏ close 事件
并且在 Node 中，有些情况下的定时器执⾏顺序是随机的
当然在这种情况下，执⾏顺序是相同的
上⾯介绍的都是 macrotask 的执⾏情况，microtask 会在以上每个阶段完成后⽴即执⾏。
setTimeout(() => {
 console.log('setTimeout');
}, 0);
setImmediate(() => {
 console.log('setImmediate');
})
// 这⾥可能会输出 setTimeout，setImmediate
// 可能也会相反的输出，这取决于性能
// 因为可能进⼊ event loop ⽤了不到 1 毫秒，这时候会执⾏ setImmediate
// 否则会执⾏ setTimeout
var fs = require('fs')
fs.readFile(__filename, () => {
 setTimeout(() => {
 console.log('timeout');
 }, 0);
 setImmediate(() => {
 console.log('immediate');
 });
});
// 因为 readFile 的回调在 poll 中执⾏
// 发现有 setImmediate ，所以会⽴即跳到 check 阶段执⾏回调
// 再去 timer 阶段执⾏ setTimeout
// 所以以上输出⼀定是 setImmediate，setTimeout
setTimeout(()=>{
 console.log('timer1')
 Promise.resolve().then(function() {
Node 中的 process.nextTick 会先于其他 microtask 执⾏。
 console.log('promise1')
 })
}, 0)
setTimeout(()=>{
 console.log('timer2')
 Promise.resolve().then(function() {
 console.log('promise2')
 })
}, 0)
// 以上代码在浏览器和 node 中打印情况是不同的
// 浏览器中⼀定打印 timer1, promise1, timer2, promise2
// node 中可能打印 timer1, timer2, promise1, promise2
// 也可能打印 timer1, promise1, timer2, promise2
setTimeout(() => {
 console.log("timer1");
 Promise.resolve().then(function() {
 console.log("promise1");
 });
}, 0);
process.nextTick(() => {
 console.log("nextTick");
});
// nextTick, timer1, promise1
特性 cookie localStorage sessionStorage indexDB
数据⽣
命周期
⼀般由服务器⽣成，可以设
置过期时间
除⾮被清理，否
则⼀直存在
⻚⾯关闭就清理 除⾮被清
理，否则
⼀直存在
数据存
储⼤⼩
4K 5M 5M ⽆限
与服务
端通信
每次都会携带在 header
中，对于请求性能影响
不参与 不参与 不参与
属性 作⽤
value 如果⽤于保存⽤户登录态，应该将该值加密，不能使⽤明⽂的⽤户标识
http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击
secure 只能在协议为 HTTPS 的请求中携带
same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击
存储
cookie，localStorage，sessionStorage，indexDB
从上表可以看到， cookie 已经不建议⽤于存储。如果没有⼤量数据存储需求的话，可以使
⽤ localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使⽤ localStorage
存储，否则可以⽤ sessionStorage 存储。
对于 cookie ，我们还需要注意安全性。
Service Worker
Service workers 本质上充当Web应⽤程序与浏览器之间的代理服务器，也可以在⽹
络可⽤时作为浏览器和⽹络间的代理。它们旨在（除其他之外）使得能够创建有效的
离线体验，拦截⽹络请求并基于⽹络是否可⽤以及更新的资源是否驻留在服务器上来
采取适当的动作。他们还允许访问推送通知和后台同步API。
⽬前该技术通常⽤来做缓存⽂件，提⾼⾸屏速度，可以试着来实现这个功能。
// index.js
if (navigator.serviceWorker) {
 navigator.serviceWorker
 .register("sw.js")
 .then(function(registration) {
 console.log("service worker 注册成功");
 })
 .catch(function(err) {
 console.log("servcie worker 注册失败");
 });
}
// sw.js
// 监听 `install` 事件，回调中缓存所需⽂件
self.addEventListener("install", e => {
 e.waitUntil(
 caches.open("my-cache").then(function(cache) {
 return cache.addAll(["./index.html", "./index.js"]);
 })
 );
});
// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接⽤缓存，否则去请求数据
self.addEventListener("fetch", e => {
 e.respondWith(
 caches.match(e.request).then(function(response) {
 if (response) {
 return response;
 }
 console.log("fetch source");
 })
 );
});
打开⻚⾯，可以在开发者⼯具中的 Application 看到 Service Worker 已经启动了
在 Cache 中也可以发现我们所需的⽂件已被缓存
当我们重新刷新⻚⾯可以发现我们缓存的数据是从 Service Worker 中读取的
渲染机制
浏览器的渲染机制⼀般分为以下⼏个步骤
1. 处理 HTML 并构建 DOM 树。
2. 处理 CSS 构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成⼀个渲染树。
4. 根据渲染树来布局，计算每个节点的位置。
5. 调⽤ GPU 绘制，合成图层，显示在屏幕上。
在构建 CSSOM 树时，会阻塞渲染，直⾄ CSSOM 树构建完成。并且构建 CSSOM 树是⼀个
⼗分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择
器，执⾏速度越慢。
当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地⽅重新开始。也
就是说，如果你想⾸屏渲染的越快，就越不应该在⾸屏就加载 JS ⽂件。并且 CSS 也会影响
JS 的执⾏，只有当解析完样式表才会执⾏ JS，所以也可以认为这种情况下，CSS 也会暂停
构建 DOM。
Load 和 DOMContentLoaded 区别
Load 事件触发代表⻚⾯中的 DOM，CSS，JS，图⽚已经全部加载完毕。
DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，
JS，图⽚加载。
图层
⼀般来说，可以把普通⽂档流看成⼀个图层。特定的属性可以⽣成⼀个新的图层。不同的图
层渲染互不影响，所以对于某些频繁需要渲染的建议单独⽣成⼀个新图层，提⾼性能。但也
不能⽣成过多的图层，会引起反作⽤。
通过以下⼏个常⽤属性可以⽣成新图层
3D 变换： translate3d 、 translateZ
will-change
video 、 iframe 标签
通过动画实现的 opacity 动画转换
position: fixed
重绘（Repaint）和回流（Reflow）
重绘和回流是渲染步骤中的⼀⼩节，但是这两个步骤对于性能影响很⼤。
重绘是当节点需要更改外观⽽不会影响布局的，⽐如改变 color 就叫称为重绘
回流是布局或者⼏何属性需要改变就称为回流。
回流必定会发⽣重绘，重绘不⼀定会引发回流。回流所需的成本⽐重绘⾼的多，改变深层次
的节点很可能导致⽗节点的⼀系列回流。
所以以下⼏个动作可能会导致性能问题：
改变 window ⼤⼩
改变字体
添加或删除样式
⽂字改变
定位或者浮动
盒模型
很多⼈不知道的是，重绘和回流其实和 Event loop 有关。
1. 当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是
60Hz 的刷新率，每 16ms 才会更新⼀次。
2. 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和
scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执⾏ requestAnimationFrame 回调
7. 执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载
上，但是兼容性不好
8. 更新界⾯
9. 以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏
requestIdleCallback 回调。
以上内容来⾃于 HTML ⽂档
减少重绘和回流
使⽤ translate 替代 top
<div class="test"></div>
<style>
 .test {
 position: absolute;
 top: 10px;
 width: 100px;
 height: 100px;
 background: red;
 }
</style>
<script>
 setTimeout(() => {
 // 引起回流
 document.querySelector('.test').style.top = '100px'
 }, 1000)
</script>
使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流
（改变了布局）
把 DOM 离线后修改，⽐如：先把 DOM 给 display:none (有⼀次 Reflow)，然后你修
改100次，然后再把它显示出来
不要把 DOM 结点的属性值放在⼀个循环⾥当成循环⾥的变量
不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局
动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤
requestAnimationFrame
CSS 选择符从右往左匹配查找，避免 DOM 深度过深
将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。⽐如对于 video
标签，浏览器会⾃动将该节点变为图层。
for(let i = 0; i < 1000; i++) {
 // 获取 offsetTop 会导致回流，因为需要去获取正确的值
 console.log(document.querySelector('.test').style.offsetTop)
}
性能章节
DNS 预解析
DNS 解析也是需要时间的，可以通过预解析的⽅式来预先获得域名所对应的 IP。
缓存
缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提⾼
⽹⻚的整体加载速度。
通常浏览器缓存策略分为两种：强缓存和协商缓存。
强缓存
实现强缓存可以通过两种响应头实现： Expires 和 Cache-Control 。强缓存表示在缓存期
间不需要请求， state code 为 200
Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过
期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存
失效。
Cache-Control 出现于 HTTP / 1.1，优先级⾼于 Expires 。该属性表示资源会在 30 秒后
过期，需要再次请求。
<link rel="dns-prefetch" href="//yuchengkai.cn">
Expires: Wed, 22 Oct 2018 08:41:00 GMT
Cache-control: max-age=30
协商缓存
如果缓存过期了，我们就可以使⽤协商缓存来解决问题。协商缓存需要请求，如果缓存有效
会返回 304。
协商缓存需要客户端和服务端共同实现，和强缓存⼀样，也有两种实现⽅式。
Last-Modified 和 If-Modified-Since
Last-Modified 表示本地⽂件最后修改⽇期， If-Modified-Since 会将 Last-Modified
的值发送给服务器，询问服务器在该⽇期后资源是否有更新，有更新的话就会将新的资源发
送回来。
但是如果在本地打开缓存⽂件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现
了 ETag 。
ETag 和 If-None-Match
ETag 类似于⽂件指纹， If-None-Match 会将当前 ETag 发送给服务器，询问该资源
ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级⽐ LastModified ⾼。
选择合适的缓存策略
对于⼤部分的场景都可以使⽤强缓存配合协商缓存解决，但是在⼀些特殊的地⽅可能需要选
择特殊的缓存策略
对于某些不需要缓存的资源，可以使⽤ Cache-control: no-store ，表示该资源不需
要缓存
对于频繁变动的资源，可以使⽤ Cache-Control: no-cache 并配合 ETag 使⽤，表示
该资源已被缓存，但是每次都会发送请求询问资源是否更新。
对于代码⽂件来说，通常使⽤ Cache-Control: max-age=31536000 并配合策略缓存使
⽤，然后对⽂件进⾏指纹处理，⼀旦⽂件名变动就会⽴刻下载新的⽂件。
使⽤ HTTP / 2.0
因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建⽴和断开，消耗了好
⼏个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积⼤的⽂件会需要更多的时间。
在 HTTP / 2.0 中引⼊了多路复⽤，能够让多个请求使⽤同⼀个 TCP 链接，极⼤的加快了⽹
⻚的加载速度。并且还⽀持 Header 压缩，进⼀步的减少了请求的数据⼤⼩。
更详细的内容你可以查看 该⼩节
预加载
在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候
就可以使⽤预加载。
预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以
使⽤以下代码开启预加载
预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后
加载，唯⼀缺点就是兼容性不好。
预渲染
可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染
预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则
就⽩⽩浪费资源去渲染
<link rel="preload" href="http://example.com">
<link rel="prerender" href="http://example.com">
优化渲染过程
对于代码层⾯的优化，你可以查阅浏览器系列中的 相关内容。
懒执⾏
懒执⾏就是将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于某些耗时逻辑
并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。懒执⾏需要唤醒，⼀般可以通过定时器或者
事件的调⽤来唤醒。
懒加载
懒加载就是将不关键的资源延后加载。
懒加载的原理就是只加载⾃定义区域（通常是可视区域，但也可以是即将进⼊可视区域）内
需要加载的东⻄。对于图⽚来说，先设置图⽚标签的 src 属性为⼀张占位图，将真实的图⽚
资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域时，就将⾃定义属性替换为 src 属性，这样
图⽚就会去下载资源，实现了图⽚懒加载。
懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频等
等。
⽂件优化
图⽚优化
计算图⽚⼤⼩
对于⼀张 100 * 100 像素的图⽚来说，图像上有 10000 个像素点，如果每个像素的值是
RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字
节），所以该图⽚⼤⼩⼤概为 39KB（10000 * 1 * 4 / 1024）。
但是在实际项⽬中，⼀张图⽚可能并不需要使⽤那么多颜⾊去显示，我们可以通过减少每个
像素的调⾊板来相应缩⼩图⽚的⼤⼩。
了解了如何计算图⽚⼤⼩的知识，那么对于如何优化图⽚，想必⼤家已经有 2 个思路了：
减少像素点
减少每个像素点能够显示的颜⾊
图⽚加载优化
1. 不⽤图⽚。很多时候会使⽤到很多修饰类图⽚，其实这类修饰图⽚完全可以⽤ CSS 去代
替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。⼀般图⽚都⽤
CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图⽚。
3. ⼩图使⽤ base64 格式
4. 将多个图标⽂件整合到⼀张图⽚中（雪碧图）
5. 选择正确的图⽚格式：
对于能够显示 WebP 格式的浏览器尽量使⽤ WebP 格式。因为 WebP 格式具有更好
的图像数据压缩算法，能带来更⼩的图⽚体积，⽽且拥有⾁眼识别⽆差异的图像质
量，缺点就是兼容性并不好
⼩图使⽤ PNG，其实对于⼤部分图标这类图⽚，完全可以使⽤ SVG 代替
照⽚使⽤ JPEG
其他⽂件优化
CSS ⽂件放在 head 中
服务端开启⽂件压缩功能
将 script 标签放在 body 底部，因为 JS ⽂件执⾏会阻塞渲染。当然也可以把
script 标签放在任意位置然后加上 defer ，表示该⽂件会并⾏下载，但是会放到
HTML 解析完成后顺序执⾏。对于没有任何依赖的 JS ⽂件可以加上 async ，表示加载
和渲染后续⽂档元素的过程将和 JS ⽂件的加载与执⾏并⾏⽆序进⾏。
执⾏ JS 代码过⻓会卡住渲染，对于需要很多时间计算的代码可以考虑使⽤
Webworker 。 Webworker 可以让我们另开⼀个线程执⾏脚本⽽不影响渲染。
CDN
静态资源尽量使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个
CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带
上主站的 Cookie。
其他
使⽤ Webpack 优化项⽬
对于 Webpack4，打包项⽬使⽤ production 模式，这样会⾃动开启代码压缩
使⽤ ES6 模块来开启 tree shaking，这个技术可以移除没有使⽤的代码
优化图⽚，对于⼩图可以使⽤ base64 的⽅式写⼊⽂件中
按照路由拆分代码，实现按需加载
给打包出来的⽂件名添加哈希，实现浏览器缓存⽂件
监控
对于代码运⾏错误，通常的办法是使⽤ window.onerror 拦截报错。该⽅法能拦截到⼤部分
的详细报错信息，但是也有例外
对于跨域的代码运⾏错误会显示 Script error. 对于这种情况我们需要给 script 标
签添加 crossorigin 属性
对于某些浏览器可能不会显示调⽤栈信息，这种情况可以通过
arguments.callee.caller 来做栈递归
对于异步代码来说，可以使⽤ catch 的⽅式捕获错误。⽐如 Promise 可以直接使⽤
catch 函数， async await 可以使⽤ try catch
但是要注意线上运⾏的代码都是压缩过的，需要在打包时⽣成 sourceMap ⽂件便于 debug。
对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起⼀个请求。
⾯试题
如何渲染⼏万条数据并不卡住界⾯
这道题考察了如何在不卡住⻚⾯的情况下渲染数据，也就是说不能⼀次性将⼏万条都渲染出
来，⽽应该⼀次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷
新⼀次。
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <meta http-equiv="X-UA-Compatible" content="ie=edge">
 <title>Document</title>
</head>
<body>
 <ul>控件</ul>
 <script>
 setTimeout(() => {
 // 插⼊⼗万条数据
 const total = 100000
 // ⼀次插⼊ 20 条，如果觉得性能不好就减少
 const once = 20
 // 渲染数据总共需要⼏次
 const loopCount = total / once
 let countOfRender = 0
 let ul = document.querySelector("ul");
 function add() {
 // 优化性能，插⼊不会造成回流
 const fragment = document.createDocumentFragment();
 for (let i = 0; i < once; i++) {
 const li = document.createElement("li");
 li.innerText = Math.floor(Math.random() * total);
 fragment.appendChild(li);
 }
 ul.appendChild(fragment);
 countOfRender += 1;
 loop();
 }
 function loop() {
 if (countOfRender < loopCount) {
 window.requestAnimationFrame(add);
 }
框架基本原理篇
MVVM
MVVM 由以下三个内容组成
View：界⾯
Model：数据模型
ViewModel：作为桥梁负责沟通 View 和 Model
在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务
的逻辑就和⻚⾯有强耦合。
在 MVVM 中，UI 是通过数据驱动的，数据⼀旦改变就会相应的刷新对应的 UI，UI 如果改
变，也会改变对应的数据。这种⽅式就可以在业务处理中只关⼼数据的流转，⽽⽆需直接和
⻚⾯打交道。ViewModel 只关⼼数据和业务的处理，不关⼼ View 如何处理数据，在这种情况
下，View 和 Model 都可以独⽴出来，任何⼀⽅改变了也不⼀定需要改变另⼀⽅，并且可以将
⼀些可复⽤的逻辑放在⼀个 ViewModel 中，让多个 View 复⽤这个 ViewModel。
在 MVVM 中，最核⼼的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫
持。
 }
 loop();
 }, 0);
 </script>
</body>
</html>
脏数据检测
当触发了指定事件后会进⼊脏数据检测，这时会调⽤ $digest 循环遍历所有的数据观察者，
判断当前值是否和先前的值有区别，如果检测到变化的话，会调⽤ $watch 函数，然后再次
调⽤ $digest 循环直到发现没有变化。循环⾄少为⼆次 ，⾄多为⼗次。
脏数据检测虽然存在低效的问题，但是不关⼼数据是通过什么⽅式改变的，都可以完成任
务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的
值，再去统⼀更新 UI，⼤⼤减少了操作 DOM 的次数。所以低效也是相对的，这就仁者⻅仁
智者⻅智了。
数据劫持
Vue 内部使⽤了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到
set 和 get 的事件。
var data = { name: 'yck' }
observe(data)
let name = data.name // -> get value
data.name = 'yyy' // -> change value
function observe(obj) {
 // 判断类型
 if (!obj || typeof obj !== 'object') {
 return
 }
 Object.keys(obj).forEach(key => {
 defineReactive(obj, key, obj[key])
 })
}
function defineReactive(obj, key, val) {
 // 递归⼦属性
 observe(val)
 Object.defineProperty(obj, key, {
 enumerable: true,
以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需
要在适当的时候给属性添加发布订阅
::: v-pre
在解析如上模板代码时，遇到 {{name}} 就会给属性 name 添加发布订阅。
:::
 configurable: true,
 get: function reactiveGetter() {
 console.log('get value')
 return val
 },
 set: function reactiveSetter(newVal) {
 console.log('change value')
 val = newVal
 }
 })
}
<div>
 {{name}}
</div>
// 通过 Dep 解耦
class Dep {
 constructor() {
 this.subs = []
 }
 addSub(sub) {
 // sub 是 Watcher 实例
 this.subs.push(sub)
 }
 notify() {
 this.subs.forEach(sub => {
 sub.update()
 })
 }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null
function update(value) {
 document.querySelector('div').innerText = value
}
class Watcher {
 constructor(obj, key, cb) {
 // 将 Dep.target 指向⾃⼰
 // 然后触发属性的 getter 添加监听
 // 最后将 Dep.target 置空
 Dep.target = this
 this.cb = cb
 this.obj = obj
 this.key = key
 this.value = obj[key]
 Dep.target = null
 }
 update() {
 // 获得新值
 this.value = this.obj[this.key]
 // 调⽤ update ⽅法更新 Dom
 this.cb(this.value)
 }
}
var data = { name: 'yck' }
observe(data)
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update)
// update Dom innerText
data.name = 'yyy'
接下来,对 defineReactive 函数进⾏改造
以上实现了⼀个简易的双向绑定，核⼼思路就是⼿动触发⼀次属性的 getter 来实现发布订阅
的添加。
Proxy 与 Object.defineProperty 对⽐
Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。
1. 只能对属性进⾏数据劫持，所以需要深度遍历整个对象
2. 对于数组不能监听到数据的变化
function defineReactive(obj, key, val) {
 // 递归⼦属性
 observe(val)
 let dp = new Dep()
 Object.defineProperty(obj, key, {
 enumerable: true,
 configurable: true,
 get: function reactiveGetter() {
 console.log('get value')
 // 将 Watcher 添加到订阅
 if (Dep.target) {
 dp.addSub(Dep.target)
 }
 return val
 },
 set: function reactiveSetter(newVal) {
 console.log('change value')
 val = newVal
 // 执⾏ watcher 的 update ⽅法
 dp.notify()
 }
 })
}
虽然 Vue 中确实能检测到数组数据的变化，但是其实是使⽤了 hack 的办法，并且也是有缺
陷的。
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
// hack 以下⼏个函数
const methodsToPatch = [
 'push',
 'pop',
 'shift',
 'unshift',
 'splice',
 'sort',
 'reverse'
]
methodsToPatch.forEach(function (method) {
 // 获得原⽣函数
 const original = arrayProto[method]
 def(arrayMethods, method, function mutator (...args) {
 // 调⽤原⽣函数
 const result = original.apply(this, args)
 const ob = this.__ob__
 let inserted
 switch (method) {
 case 'push':
 case 'unshift':
 inserted = args
 break
 case 'splice':
 inserted = args.slice(2)
 break
 }
 if (inserted) ob.observeArray(inserted)
 // 触发更新
 ob.dep.notify()
反观 Proxy 就没以上的问题，原⽣⽀持监听数组变化，并且可以直接对整个对象进⾏拦截，
所以 Vue 也将在下个⼤版本中使⽤ Proxy 替换 Object.defineProperty
 return result
 })
})
let onWatch = (obj, setBind, getLogger) => {
 let handler = {
 get(target, property, receiver) {
 getLogger(target, property)
 return Reflect.get(target, property, receiver);
 },
 set(target, property, value, receiver) {
 setBind(value);
 return Reflect.set(target, property, value);
 }
 };
 return new Proxy(obj, handler);
};
let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
 value = v
}, (target, property) => {
 console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2
路由原理
前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的
⻚⾯，并且⽆须刷新。⽬前单⻚⾯使⽤的路由就只有两种实现⽅式
hash 模式
history 模式
www.test.com/#/ 就是 Hash URL，当 # 后⾯的哈希值发⽣变化时，不会向服务器请求数
据，可以通过 hashchange 事件来监听到 URL 的变化，从⽽进⾏跳转⻚⾯。
History 模式是 HTML5 新推出的功能，⽐之 Hash URL 更加美观
Virtual Dom
代码地址
为什么需要 Virtual Dom
众所周知，操作 DOM 是很耗费性能的⼀件事情，既然如此，我们可以考虑通过 JS 对象来模
拟 DOM 对象，毕竟操作 JS 对象⽐操作 DOM 省时的多。
举个例⼦
从上述例⼦中，我们⼀眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。
如果以上操作对应到 DOM 中，那么就是以下代码
// 假设这⾥模拟⼀个 ul，其中包含了 5 个 li
[1, 2, 3, 4, 5]
// 这⾥替换上⾯的 li
[1, 2, 5, 4]
当然在实际操作中，我们还需要给每个节点⼀个标识，作为判断是同⼀个节点的依据。所以
这也是 Vue 和 React 中官⽅推荐列表⾥的节点使⽤唯⼀的 key 来保证性能。
那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的
DOM
以下是⼀个 JS 对象模拟 DOM 对象的简单实现
// 删除第三个 li
ul.childNodes[2].remove()
// 将第四个 li 和第五个交换位置
let fromNode = ul.childNodes[4]
let toNode = node.childNodes[3]
let cloneFromNode = fromNode.cloneNode(true)
let cloenToNode = toNode.cloneNode(true)
ul.replaceChild(cloneFromNode, toNode)
ul.replaceChild(cloenToNode, fromNode)
export default class Element {
 /**
 * @param {String} tag 'div'
 * @param {Object} props { class: 'item' }
 * @param {Array} children [ Element1, 'text']
 * @param {String} key option
 */
 constructor(tag, props, children, key) {
 this.tag = tag
 this.props = props
 if (Array.isArray(children)) {
 this.children = children
 } else if (isString(children)) {
 this.key = children
 this.children = null
 }
 if (key) this.key = key
 }
 // 渲染
 render() {
 let root = this._createElement(
 this.tag,
 this.props,
 this.children,
 this.key
 )
 document.body.appendChild(root)
 return root
 }
 create() {
 return this._createElement(this.tag, this.props, this.children,
this.key)
 }
 // 创建节点
 _createElement(tag, props, child, key) {
 // 通过 tag 创建节点
 let el = document.createElement(tag)
 // 设置节点属性
 for (const key in props) {
 if (props.hasOwnProperty(key)) {
 const value = props[key]
 el.setAttribute(key, value)
 }
 }
 if (key) {
 el.setAttribute('key', key)
 }
 // 递归添加⼦节点
 if (child) {
 child.forEach(element => {
 let child
 if (element instanceof Element) {
 child = this._createElement(
Virtual Dom 算法简述
既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新
的对象之间的差异。
DOM 是多叉树的结构，如果需要完整的对⽐两颗树的差异，那么需要的时间复杂度会是 O(n
^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来
对⽐差异。
实现 O(n) 复杂度的关键就是只对⽐同层的节点，⽽不是跨层对⽐，这也是考虑到在实际业务
中很少会去跨层的移动 DOM 元素。
所以判断差异的算法就分为了两步
⾸先从上⾄下，从左往右遍历对象，也就是树的深度遍历，这⼀步中会给每个节点添加索
引，便于最后渲染差异
⼀旦节点有⼦元素，就去判断⼦元素是否有不同
 element.tag,
 element.props,
 element.children,
 element.key
 )
 } else {
 child = document.createTextNode(element)
 }
 el.appendChild(child)
 })
 }
 return el
 }
}
Virtual Dom 算法实现
树的递归
⾸先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对⽐会有⼏种情况
1. 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也
不再需要遍历新旧节点的⼦元素了，因为整个旧节点都被删掉了
2. 新的节点的 tagName 和 key （可能都没有）和旧的相同，开始遍历⼦树
3. 没有新的节点，那么什么都不⽤做
import { StateEnums, isString, move } from './util'
import Element from './element'
export default function diff(oldDomTree, newDomTree) {
 // ⽤于记录差异
 let pathchs = {}
 // ⼀开始的索引为 0
 dfs(oldDomTree, newDomTree, 0, pathchs)
 return pathchs
}
function dfs(oldNode, newNode, index, patches) {
 // ⽤于保存⼦树的更改
 let curPatches = []
 // 需要判断三种情况
 // 1.没有新的节点，那么什么都不⽤做
 // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换
 // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历⼦树
 if (!newNode) {
 } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key)
{
 // 判断属性是否变更
 let props = diffProps(oldNode.props, newNode.props)
 if (props.length) curPatches.push({ type: StateEnums.ChangeProps,
props })
判断属性的更改
判断属性的更改也分三个步骤
1. 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中
2. 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化
3. 在第⼆步中同时查看是否有属性不存在与旧的属性列列表中
 // 遍历⼦树
 diffChildren(oldNode.children, newNode.children, index, patches)
 } else {
 // 节点不同，需要替换
 curPatches.push({ type: StateEnums.Replace, node: newNode })
 }
 if (curPatches.length) {
 if (patches[index]) {
 patches[index] = patches[index].concat(curPatches)
 } else {
 patches[index] = curPatches
 }
 }
}
function diffProps(oldProps, newProps) {
 // 判断 Props 分以下三步骤
 // 先遍历 oldProps 查看是否存在删除的属性
 // 然后遍历 newProps 查看是否有属性值被修改
 // 最后查看是否有属性新增
 let change = []
 for (const key in oldProps) {
 if (oldProps.hasOwnProperty(key) && !newProps[key]) {
 change.push({
 prop: key
 })
判断列表差异算法实现
这个算法是整个 Virtual Dom 中最核⼼的算法，且让我⼀⼀为你道来。
这⾥的主要步骤其实和判断属性差异是类似的，也是分为三步
1. 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中
2. 遍历新的节点列表，判断是否有新的节点
3. 在第⼆步中同时判断节点是否有移动
PS：该算法只对有 key 的节点做处理
 }
 }
 for (const key in newProps) {
 if (newProps.hasOwnProperty(key)) {
 const prop = newProps[key]
 if (oldProps[key] && oldProps[key] !== newProps[key]) {
 change.push({
 prop: key,
 value: newProps[key]
 })
 } else if (!oldProps[key]) {
 change.push({
 prop: key,
 value: newProps[key]
 })
 }
 }
 }
 return change
}
function listDiff(oldList, newList, index, patches) {
 // 为了遍历⽅便，先取出两个 list 的所有 keys
 let oldKeys = getKeys(oldList)
 let newKeys = getKeys(newList)
 let changes = []
 // ⽤于保存变更后的节点数据
 // 使⽤该数组保存有以下好处
 // 1.可以正确获得被删除节点索引
 // 2.交换节点位置只需要操作⼀遍 DOM
 // 3.⽤于 `diffChildren` 函数中的判断，只需要遍历
 // 两个树中都存在的节点，⽽对于新增或者删除的节点来说，完全没必要
 // 再去判断⼀遍
 let list = []
 oldList &&
 oldList.forEach(item => {
 let key = item.key
 if (isString(item)) {
 key = item
 }
 // 寻找新的 children 中是否含有当前节点
 // 没有的话需要删除
 let index = newKeys.indexOf(key)
 if (index === -1) {
 list.push(null)
 } else list.push(key)
 })
 // 遍历变更后的数组
 let length = list.length
 // 因为删除数组元素是会更改索引的
 // 所有从后往前删可以保证索引不变
 for (let i = length - 1; i >= 0; i--) {
 // 判断当前元素是否为空，为空表示需要删除
 if (!list[i]) {
 list.splice(i, 1)
 changes.push({
 type: StateEnums.Remove,
 index: i
 })
 }
 }
 // 遍历新的 list，判断是否有节点新增或移动
 // 同时也对 `list` 做节点新增和移动节点的操作
 newList &&
 newList.forEach((item, i) => {
 let key = item.key
 if (isString(item)) {
 key = item
 }
 // 寻找旧的 children 中是否含有当前节点
 let index = list.indexOf(key)
 // 没找到代表新节点，需要插⼊
 if (index === -1 || key == null) {
 changes.push({
 type: StateEnums.Insert,
 node: item,
 index: i
 })
 list.splice(i, 0, key)
 } else {
 // 找到了，需要判断是否需要移动
 if (index !== i) {
 changes.push({
 type: StateEnums.Move,
 from: index,
 to: i
 })
 move(list, index, i)
 }
 }
 })
 return { changes, list }
}
function getKeys(list) {
遍历⼦元素打标识
对于这个函数来说，主要功能就两个
1. 判断两个列表差异
2. 给节点打上标记
总体来说，该函数实现的功能很简单
 let keys = []
 let text
 list &&
 list.forEach(item => {
 let key
 if (isString(item)) {
 key = [item]
 } else if (item instanceof Element) {
 key = item.key
 }
 keys.push(key)
 })
 return keys
}
function diffChildren(oldChild, newChild, index, patches) {
 let { changes, list } = listDiff(oldChild, newChild, index, patches)
 if (changes.length) {
 if (patches[index]) {
 patches[index] = patches[index].concat(changes)
 } else {
 patches[index] = changes
 }
 }
 // 记录上⼀个遍历过的节点
 let last = null
 oldChild &&
渲染差异
通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新
DOM 了，下⾯就让我们来看看 Virtual Dom 算法的最后⼀步骤
这个函数主要两个功能
1. 深度遍历树，将需要做变更操作的取出来
2. 局部更新 DOM
整体来说这部分代码还是很好理解的
 oldChild.forEach((item, i) => {
 let child = item && item.children
 if (child) {
 index =
 last && last.children ? index + last.children.length + 1 :
index + 1
 let keyIndex = list.indexOf(item.key)
 let node = newChild[keyIndex]
 // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历
 if (node) {
 dfs(item, node, index, patches)
 }
 } else index += 1
 last = item
 })
}
let index = 0
export default function patch(node, patchs) {
 let changes = patchs[index]
 let childNodes = node && node.childNodes
 // 这⾥的深度遍历和 diff 中是⼀样的
 if (!childNodes) index += 1
 if (changes && changes.length && patchs[index]) {
 changeDom(node, changes)
 }
 let last = null
 if (childNodes && childNodes.length) {
 childNodes.forEach((item, i) => {
 index =
 last && last.children ? index + last.children.length + 1 : index
+ 1
 patch(item, patchs)
 last = item
 })
 }
}
function changeDom(node, changes, noChild) {
 changes &&
 changes.forEach(change => {
 let { type } = change
 switch (type) {
 case StateEnums.ChangeProps:
 let { props } = change
 props.forEach(item => {
 if (item.value) {
 node.setAttribute(item.prop, item.value)
 } else {
 node.removeAttribute(item.prop)
 }
 })
 break
 case StateEnums.Remove:
 node.childNodes[change.index].remove()
 break
 case StateEnums.Insert:
 let dom
 if (isString(change.node)) {
 dom = document.createTextNode(change.node)
最后
Virtual Dom 算法的实现也就是以下三步
1. 通过 JS 来模拟创建 DOM 对象
2. 判断两个对象的差异
3. 渲染差异
 } else if (change.node instanceof Element) {
 dom = change.node.create()
 }
 node.insertBefore(dom, node.childNodes[change.index])
 break
 case StateEnums.Replace:
 node.parentNode.replaceChild(change.node.create(), node)
 break
 case StateEnums.Move:
 let fromNode = node.childNodes[change.from]
 let toNode = node.childNodes[change.to]
 let cloneFromNode = fromNode.cloneNode(true)
 let cloenToNode = toNode.cloneNode(true)
 node.replaceChild(cloneFromNode, toNode)
 node.replaceChild(cloenToNode, fromNode)
 break
 default:
 break
 }
 })
}
let test4 = new Element('div', { class: 'my-div' }, ['test4'])
let test5 = new Element('ul', { class: 'my-div' }, ['test5'])
let test1 = new Element('div', { class: 'my-div' }, [test4])
当然⽬前的实现还略显粗糙，但是对于理解 Virtual Dom 算法来说已经是完全⾜够的了。
Vue 章节
NextTick 原理分析
nextTick 可以让我们在下次 DOM 更新循环结束之后执⾏延迟回调，⽤于获得更新后的
DOM。
在 Vue 2.4 之前都是使⽤的 microtasks，但是 microtasks 的优先级过⾼，在某些情况下可能
会出现⽐事件冒泡更快的情况，但如果都使⽤ macrotasks ⼜可能会出现渲染的性能问题。所
以在新版本中，会默认使⽤ microtasks，但在特殊情况下会使⽤ macrotasks，⽐如 v-on。
对于实现 macrotasks ，会先判断是否能使⽤ setImmediate ，不能的话降级为
MessageChannel ，以上都不⾏的话就使⽤ setTimeout
let test2 = new Element('div', { id: '11' }, [test5, test4])
let root = test1.render()
let pathchs = diff(test1, test2)
console.log(pathchs)
setTimeout(() => {
 console.log('开始更新')
 patch(root, pathchs)
 console.log('结束更新')
}, 1000)
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
 macroTimerFunc = () => {
 setImmediate(flushCallbacks)
nextTick 同时也⽀持 Promise 的使⽤，会判断是否实现了 Promise
 }
} else if (
 typeof MessageChannel !== 'undefined' &&
 (isNative(MessageChannel) ||
 // PhantomJS
 MessageChannel.toString() === '[object MessageChannelConstructor]')
) {
 const channel = new MessageChannel()
 const port = channel.port2
 channel.port1.onmessage = flushCallbacks
 macroTimerFunc = () => {
 port.postMessage(1)
 }
} else {
 /* istanbul ignore next */
 macroTimerFunc = () => {
 setTimeout(flushCallbacks, 0)
 }
}
export function nextTick(cb?: Function, ctx?: Object) {
 let _resolve
 // 将回调函数整合进⼀个数组中
 callbacks.push(() => {
 if (cb) {
 try {
 cb.call(ctx)
 } catch (e) {
 handleError(e, ctx, 'nextTick')
 }
 } else if (_resolve) {
 _resolve(ctx)
 }
⽣命周期分析
⽣命周期函数就是组件在初始化或者数据更新时会触发的钩⼦函数。
 })
 if (!pending) {
 pending = true
 if (useMacroTask) {
 macroTimerFunc()
 } else {
 microTimerFunc()
 }
 }
 // 判断是否可以使⽤ Promise
 // 可以的话给 _resolve 赋值
 // 这样回调函数就能以 promise 的⽅式调⽤
 if (!cb && typeof Promise !== 'undefined') {
 return new Promise(resolve => {
 _resolve = resolve
 })
 }
}
<p>在初始化时，会调⽤以下代码，⽣命周期就是通过 callHook 调⽤的<br>
可以发现在以上代码中， beforeCreate 调⽤的时候，是获取不到 props 或者 data 中的数据<br>
的，因为这些数据的初始化都在 initState 中。<br>
接下来会执⾏挂载函数<br>
Vue.prototype._init = function(options) {<br>
initLifecycle(vm)<br>
initEvents(vm)<br>
initRender(vm)<br>
callHook(vm, 'beforeCreate') // 拿不到 props data<br>
initInjections(vm)<br>
initState(vm)<br>
initProvide(vm)<br>
callHook(vm, 'created')<br>
}<br>
beforeMount 就是在挂载前执⾏的，然后开始创建 VDOM 并替换成真实 DOM，最后执⾏<br>
mounted 钩⼦。这⾥会有个判断逻辑，如果是外部 new Vue({}) 的话，不会存在 <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …// ...
 if (vm.'>vnode
，所以直接执⾏ mounted 钩⼦了。如果有⼦组件的话，会递归挂载⼦组件，只有当所有⼦组
件全部挂载完毕，才会执⾏根组件的挂载钩⼦。
接下来是数据更新时会调⽤的钩⼦函数
export function mountComponent {
 callHook(vm, &#039;beforeMount&#039;)
 // ...
 if (vm.</span>vnode == null) {<br>
vm._isMounted = true<br>
callHook(vm, 'mounted')<br>
}<br>
}<br>
function flushSchedulerQueue() {<br>
// ...<br>
for (index = 0; index &lt; queue.length; index++) {<br>
watcher = queue[index]<br>
if (watcher.before) {<br>
watcher.before() // 调⽤ beforeUpdate<br>
}<br>
id = watcher.id<br>
has[id] = null<br>
watcher.run()<br>
// in dev build, check and stop circular updates.<br>
if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) {<br>
circular[id] = (circular[id] || 0) + 1<br>
if (circular[id] &gt; MAX_UPDATE_COUNT) {<br>
warn(<br>
'You may have an infinite update loop ' +<br>
(watcher.user<br>
? <code>in watcher with expression &quot;${watcher.expression}&quot;</code><br>
: <code>in a component render function.</code>),<br>
上图还有两个⽣命周期没有说，分别为 activated 和 deactivated ，这两个钩⼦函数是<br>
keep-alive 组件独有的。⽤ keep-alive 包裹的组件在切换时不会进⾏销毁，⽽是缓存到<br>
内存中并执⾏ deactivated 钩⼦函数，命中缓存渲染后会执⾏ actived 钩⼦函数。<br>
最后就是销毁组件的钩⼦函数了<br>
watcher.vm<br>
)<br>
break<br>
}<br>
}<br>
}<br>
callUpdatedHooks(updatedQueue)<br>
}<br>
function callUpdatedHooks(queue) {<br>
let i = queue.length<br>
while (i--) {<br>
const watcher = queue[i]<br>
const vm = watcher.vm<br>
if (vm._watcher === watcher &amp;&amp; vm._isMounted) {<br>
callHook(vm, 'updated')<br>
}<br>
}<br>
}<br>
Vue.prototype.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …st parent = vm.'>destroy = function() {
 // ...
 callHook(vm, &#039;beforeDestroy&#039;)
 vm._isBeingDestroyed = true
 // remove self from parent
 const parent = vm.</span>parent<br>
if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: … remove(parent.'>options.abstract) {
 remove(parent.</span>children, vm)<br>
}<br>
在执⾏销毁操作前会调⽤ beforeDestroy 钩⼦函数，然后进⾏⼀系列的销毁操作，如果有<br>
⼦组件的话，也会递归销毁⼦组件，所有⼦组件都销毁完毕后才会执⾏根组件的 destroyed<br>
钩⼦函数。<br>
// teardown watchers<br>
if (vm._watcher) {<br>
vm._watcher.teardown()<br>
}<br>
let i = vm._watchers.length<br>
while (i--) {<br>
vm._watchers[i].teardown()<br>
}<br>
// remove reference from data ob<br>
// frozen object may not have observer.<br>
if (vm._data.<strong>ob</strong>) {<br>
vm._data.<strong>ob</strong>.vmCount--<br>
}<br>
// call the last hook...<br>
vm._isDestroyed = true<br>
// invoke destroy hooks on current rendered tree<br>
vm.<strong>patch</strong>(vm._vnode, null)<br>
// fire destroyed hook<br>
callHook(vm, 'destroyed')<br>
// turn off all instance listeners.<br>
vm.<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 18: …f()
 // remove _̲_vue__ referenc…'>off()
 // remove __vue__ reference
 if (vm.</span>el) {<br>
vm.<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 4: el._̲_vue__ = null
 …'>el.__vue__ = null
 }
 // release circular reference (#6759)
 if (vm.</span>vnode) {<br>
vm.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 22: …parent = null
 }̲
}
VueRouter 源码…'>vnode.parent = null
 }
}
VueRouter 源码解析
重要函数思维导图
以下思维导图罗列了源码中重要的⼀些函数
路由注册
在开始之前，推荐⼤家 clone ⼀份源码对照着看。因为篇幅较⻓，函数间的跳转也很多。
使⽤路由之前，需要调⽤ Vue.use(VueRouter) ，这是因为让插件可以使⽤ Vue
export function initUse (Vue: GlobalAPI) {
 Vue.use = function (plugin: Function | Object) {
 // 判断重复安装插件
 const installedPlugins = (this._installedPlugins ||
(this._installedPlugins = []))
 if (installedPlugins.indexOf(plugin) &gt; -1) {
 return this
 }
 const args = toArray(arguments, 1)
 // 插⼊ Vue
 args.unshift(this)
 // ⼀般插件都会有⼀个 install 函数
接下来看下 install 函数的部分实现
 // 通过该函数让插件可以使⽤ Vue
 if (typeof plugin.install === &#039;function&#039;) {
 plugin.install.apply(plugin, args)
 } else if (typeof plugin === &#039;function&#039;) {
 plugin.apply(null, args)
 }
 installedPlugins.push(plugin)
 return this
 }
}
export function install (Vue) {
 // 确保 install 调⽤⼀次
 if (install.installed &amp;&amp; _Vue === Vue) return
 install.installed = true
 // 把 Vue 赋值给全局变量
 _Vue = Vue
 const registerInstance = (vm, callVal) =&gt; {
 let i = vm.</span>options._parentVnode<br>
if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i =<br>
i.registerRouteInstance)) {<br>
i(vm, callVal)<br>
}<br>
}<br>
// 给每个组件的钩⼦函数混⼊实现<br>
// 可以发现在 <code>beforeCreate</code> 钩⼦执⾏时<br>
// 会初始化路由<br>
Vue.mixin({<br>
beforeCreate () {<br>
// 判断组件是否存在 router 对象，该对象只在根组件上有<br>
if (isDef(this.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …_router = this.'>options.router)) {
 // 根路由设置为⾃⼰
 this._routerRoot = this
对于路由注册来说，核⼼就是调⽤ Vue.use(VueRouter) ，使得 VueRouter 可以使⽤ Vue。
然后通过 Vue 来调⽤ VueRouter 的 install 函数。在该函数中，核⼼就是给组件混⼊钩⼦
函数和全局注册两个路由组件。
VueRouter 实例化
在安装插件后，对 VueRouter 进⾏实例化。
 this._router = this.</span>options.router<br>
// 初始化路由<br>
this._router.init(this)<br>
// 很重要，为 _route 属性实现双向绑定<br>
// 触发组件渲染<br>
Vue.util.defineReactive(this, '_route',<br>
this._router.history.current)<br>
} else {<br>
// ⽤于 router-view 层级判断<br>
this._routerRoot = (this.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 8: parent &amp;̲&amp; this.'>parent &amp;&amp; this.</span>parent._routerRoot) ||<br>
this<br>
}<br>
registerInstance(this, this)<br>
},<br>
destroyed () {<br>
registerInstance(this)<br>
}<br>
})<br>
// 全局注册组件 router-link 和 router-view<br>
Vue.component('RouterView', View)<br>
Vue.component('RouterLink', Link)<br>
}<br>
const Home = { template: '<div>home</div>' }<br>
const Foo = { template: '<div>foo</div>' }<br>
const Bar = { template: '<div>bar</div>' }<br>
来看⼀下 VueRouter 的构造函数<br>
// 3. Create the router<br>
const router = new VueRouter({<br>
mode: 'hash',<br>
base: __dirname,<br>
routes: [<br>
{ path: '/', component: Home }, // all paths are defined without the<br>
hash.<br>
{ path: '/foo', component: Foo },<br>
{ path: '/bar', component: Bar }<br>
]<br>
})<br>
constructor(options: RouterOptions = {}) {<br>
// ...<br>
// 路由匹配对象<br>
this.matcher = createMatcher(options.routes || [], this)<br>
// 根据 mode 采取不同的路由⽅式<br>
let mode = options.mode || 'hash'<br>
this.fallback =<br>
mode === 'history' &amp;&amp; !supportsPushState &amp;&amp; options.fallback !==<br>
false<br>
if (this.fallback) {<br>
mode = 'hash'<br>
}<br>
if (!inBrowser) {<br>
mode = 'abstract'<br>
}<br>
this.mode = mode<br>
switch (mode) {<br>
case 'history':<br>
this.history = new HTML5History(this, options.base)<br>
在实例化 VueRouter 的过程中，核⼼是创建⼀个路由匹配对象，并且根据 mode 来采取不同<br>
的路由⽅式。<br>
创建路由匹配对象<br>
break<br>
case 'hash':<br>
this.history = new HashHistory(this, options.base,<br>
this.fallback)<br>
break<br>
case 'abstract':<br>
this.history = new AbstractHistory(this, options.base)<br>
break<br>
default:<br>
if (process.env.NODE_ENV !== 'production') {<br>
assert(false, <code>invalid mode: ${mode}</code>)<br>
}<br>
}<br>
}<br>
export function createMatcher (<br>
routes: Array<RouteConfig>,<br>
router: VueRouter<br>
): Matcher {<br>
// 创建路由映射表<br>
const { pathList, pathMap, nameMap } = createRouteMap(routes)</p>
<p>function addRoutes (routes) {<br>
createRouteMap(routes, pathList, pathMap, nameMap)<br>
}<br>
// 路由匹配<br>
function match (<br>
raw: RawLocation,<br>
currentRoute?: Route,<br>
redirectedFrom?: Location<br>
createMatcher 函数的作⽤就是创建路由映射表，然后通过闭包的⽅式让 addRoutes 和<br>
match 函数能够使⽤路由映射表的⼏个对象，最后返回⼀个 Matcher 对象。<br>
接下来看 createMatcher 函数时如何创建映射表的<br>
): Route {<br>
//...<br>
}<br>
return {<br>
match,<br>
addRoutes<br>
}<br>
}<br>
export function createRouteMap (<br>
routes: Array<RouteConfig>,<br>
oldPathList?: Array<string>,<br>
oldPathMap?: Dictionary<RouteRecord>,<br>
oldNameMap?: Dictionary<RouteRecord><br>
): {<br>
pathList: Array<string>;<br>
pathMap: Dictionary<RouteRecord>;<br>
nameMap: Dictionary<RouteRecord>;<br>
} {<br>
// 创建映射表<br>
const pathList: Array<string> = oldPathList || []<br>
const pathMap: Dictionary<RouteRecord> = oldPathMap ||<br>
Object.create(null)<br>
const nameMap: Dictionary<RouteRecord> = oldNameMap ||<br>
Object.create(null)<br>
// 遍历路由配置，为每个配置添加路由记录<br>
routes.forEach(route =&gt; {<br>
addRouteRecord(pathList, pathMap, nameMap, route)<br>
})<br>
// 确保通配符在最后<br>
for (let i = 0, l = pathList.length; i &lt; l; i++) {<br>
if (pathList[i] === '<em>') {<br>
pathList.push(pathList.splice(i, 1)[0])<br>
l--<br>
i--<br>
}<br>
}<br>
return {<br>
pathList,<br>
pathMap,<br>
nameMap<br>
}<br>
}<br>
// 添加路由记录<br>
function addRouteRecord (<br>
pathList: Array<string>,<br>
pathMap: Dictionary<RouteRecord>,<br>
nameMap: Dictionary<RouteRecord>,<br>
route: RouteConfig,<br>
parent?: RouteRecord,<br>
matchAs?: string<br>
) {<br>
// 获得路由配置下的属性<br>
const { path, name } = route<br>
const pathToRegexpOptions: PathToRegexpOptions =<br>
route.pathToRegexpOptions || {}<br>
// 格式化 url，替换 /<br>
const normalizedPath = normalizePath(<br>
path,<br>
parent,<br>
pathToRegexpOptions.strict<br>
)<br>
// ⽣成记录对象<br>
const record: RouteRecord = {<br>
path: normalizedPath,<br>
regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),<br>
components: route.components || { default: route.component },<br>
instances: {},<br>
name,<br>
parent,<br>
matchAs,<br>
redirect: route.redirect,<br>
beforeEnter: route.beforeEnter,<br>
meta: route.meta || {},<br>
props: route.props == null<br>
? {}<br>
: route.components<br>
? route.props<br>
: { default: route.props }<br>
}<br>
if (route.children) {<br>
// 递归路由配置的 children 属性，添加路由记录<br>
route.children.forEach(child =&gt; {<br>
const childMatchAs = matchAs<br>
? cleanPath(<code>${matchAs}/${child.path}</code>)<br>
: undefined<br>
addRouteRecord(pathList, pathMap, nameMap, child, record,<br>
childMatchAs)<br>
})<br>
}<br>
// 如果路由有别名的话<br>
// 给别名也添加路由记录<br>
if (route.alias !== undefined) {<br>
const aliases = Array.isArray(route.alias)<br>
? route.alias<br>
: [route.alias]<br>
aliases.forEach(alias =&gt; {<br>
const aliasRoute = {<br>
path: alias,<br>
以上就是创建路由匹配对象的全过程，通过⽤户配置的路由规则来创建对应的路由映射表。<br>
children: route.children<br>
}<br>
addRouteRecord(<br>
pathList,<br>
pathMap,<br>
nameMap,<br>
aliasRoute,<br>
parent,<br>
record.path || '/' // matchAs<br>
)<br>
})<br>
}<br>
// 更新映射表<br>
if (!pathMap[record.path]) {<br>
pathList.push(record.path)<br>
pathMap[record.path] = record<br>
}<br>
// 命名路由添加记录<br>
if (name) {<br>
if (!nameMap[name]) {<br>
nameMap[name] = record<br>
} else if (process.env.NODE_ENV !== 'production' &amp;&amp; !matchAs) {<br>
warn(<br>
false,<br>
<code>Duplicate named routes definition:</code> +<br>
<code>{ name: &quot;${name}&quot;, path: &quot;${record.path}&quot; }</code><br>
)<br>
}<br>
}<br>
}<br>
路由初始化<br>
当根组件调⽤ beforeCreate 钩⼦函数时，会执⾏以下代码<br>
接下来看下路由初始化会做些什么<br>
beforeCreate () {<br>
// 只有根组件有 router 属性，所以根组件初始化时会初始化路由<br>
if (isDef(this.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …_router = this.'>options.router)) {
 this._routerRoot = this
 this._router = this.</span>options.router<br>
this._router.init(this)<br>
Vue.util.defineReactive(this, '_route',<br>
this._router.history.current)<br>
} else {<br>
this._routerRoot = (this.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 8: parent &amp;̲&amp; this.'>parent &amp;&amp; this.</span>parent._routerRoot) ||<br>
this<br>
}<br>
registerInstance(this, this)<br>
}<br>
init(app: any /</em> Vue component instance */) {<br>
// 保存组件实例<br>
this.apps.push(app)<br>
// 如果根组件已经有了就返回<br>
if (this.app) {<br>
return<br>
}<br>
this.app = app<br>
// 赋值路由模式<br>
const history = this.history<br>
// 判断路由模式，以哈希模式为例<br>
if (history instanceof HTML5History) {<br>
history.transitionTo(history.getCurrentLocation())<br>
} else if (history instanceof HashHistory) {<br>
在路由初始化时，核⼼就是进⾏路由的跳转，改变 URL 然后渲染对应的组件。接下来来看⼀<br>
下路由是如何进⾏跳转的。<br>
路由跳转<br>
// 添加 hashchange 监听<br>
const setupHashListener = () =&gt; {<br>
history.setupListeners()<br>
}<br>
// 路由跳转<br>
history.transitionTo(<br>
history.getCurrentLocation(),<br>
setupHashListener,<br>
setupHashListener<br>
)<br>
}<br>
// 该回调会在 transitionTo 中调⽤<br>
// 对组件的 _route 属性进⾏赋值，触发组件渲染<br>
history.listen(route =&gt; {<br>
this.apps.forEach(app =&gt; {<br>
app._route = route<br>
})<br>
})<br>
}<br>
transitionTo (location: RawLocation, onComplete?: Function, onAbort?:<br>
Function) {<br>
// 获取匹配的路由信息<br>
const route = this.router.match(location, this.current)<br>
// 确认切换路由<br>
this.confirmTransition(route, () =&gt; {<br>
// 以下为切换路由成功或失败的回调<br>
// 更新路由信息，对组件的 _route 属性进⾏赋值，触发组件渲染<br>
// 调⽤ afterHooks 中的钩⼦函数<br>
this.updateRoute(route)<br>
在路由跳转中，需要先获取匹配的路由信息，所以先来看下如何获取匹配的路由信息<br>
// 添加 hashchange 监听<br>
onComplete &amp;&amp; onComplete(route)<br>
// 更新 URL<br>
this.ensureURL()<br>
// 只执⾏⼀次 ready 回调<br>
if (!this.ready) {<br>
this.ready = true<br>
this.readyCbs.forEach(cb =&gt; { cb(route) })<br>
}<br>
}, err =&gt; {<br>
// 错误处理<br>
if (onAbort) {<br>
onAbort(err)<br>
}<br>
if (err &amp;&amp; !this.ready) {<br>
this.ready = true<br>
this.readyErrorCbs.forEach(cb =&gt; { cb(err) })<br>
}<br>
})<br>
}<br>
function match (<br>
raw: RawLocation,<br>
currentRoute?: Route,<br>
redirectedFrom?: Location<br>
): Route {<br>
// 序列化 url<br>
// ⽐如对于该 url 来说 /abc?foo=bar&amp;baz=qux#hello<br>
// 会序列化路径为 /abc<br>
// 哈希为 #hello<br>
// 参数为 foo: 'bar', baz: 'qux'<br>
const location = normalizeLocation(raw, currentRoute, false, router)<br>
const { name } = location<br>
// 如果是命名路由，就判断记录中是否有该命名路由配置<br>
if (name) {<br>
const record = nameMap[name]<br>
// 没找到表示没有匹配的路由<br>
if (!record) return _createRoute(null, location)<br>
const paramNames = record.regex.keys<br>
.filter(key =&gt; !key.optional)<br>
.map(key =&gt; key.name)<br>
// 参数处理<br>
if (typeof location.params !== 'object') {<br>
location.params = {}<br>
}<br>
if (currentRoute &amp;&amp; typeof currentRoute.params === 'object') {<br>
for (const key in currentRoute.params) {<br>
if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {<br>
location.params[key] = currentRoute.params[key]<br>
}<br>
}<br>
}<br>
if (record) {<br>
location.path = fillParams(record.path, location.params, <code>named route &quot;${name}&quot;</code>)<br>
return _createRoute(record, location, redirectedFrom)<br>
}<br>
} else if (location.path) {<br>
// ⾮命名路由处理<br>
location.params = {}<br>
for (let i = 0; i &lt; pathList.length; i++) {<br>
// 查找记录<br>
const path = pathList[i]<br>
const record = pathMap[path]<br>
// 如果匹配路由，则创建路由<br>
if (matchRoute(record.regex, location.path, location.params)) {<br>
return _createRoute(record, location, redirectedFrom)<br>
}<br>
}<br>
接下来看看如何创建路由<br>
}<br>
// 没有匹配的路由<br>
return _createRoute(null, location)<br>
}<br>
// 根据条件创建不同的路由<br>
function _createRoute(<br>
record: ?RouteRecord,<br>
location: Location,<br>
redirectedFrom?: Location<br>
): Route {<br>
if (record &amp;&amp; record.redirect) {<br>
return redirect(record, redirectedFrom || location)<br>
}<br>
if (record &amp;&amp; record.matchAs) {<br>
return alias(record, location, record.matchAs)<br>
}<br>
return createRoute(record, location, redirectedFrom, router)<br>
}<br>
export function createRoute (<br>
record: ?RouteRecord,<br>
location: Location,<br>
redirectedFrom?: ?Location,<br>
router?: VueRouter<br>
): Route {<br>
const stringifyQuery = router &amp;&amp; router.options.stringifyQuery<br>
// 克隆参数<br>
let query: any = location.query || {}<br>
try {<br>
query = clone(query)<br>
} catch (e) {}<br>
// 创建路由对象<br>
⾄此匹配路由已经完成，我们回到 transitionTo 函数中，接下来执⾏<br>
confirmTransition<br>
const route: Route = {<br>
name: location.name || (record &amp;&amp; record.name),<br>
meta: (record &amp;&amp; record.meta) || {},<br>
path: location.path || '/',<br>
hash: location.hash || '',<br>
query,<br>
params: location.params || {},<br>
fullPath: getFullPath(location, stringifyQuery),<br>
matched: record ? formatMatch(record) : []<br>
}<br>
if (redirectedFrom) {<br>
route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)<br>
}<br>
// 让路由对象不可修改<br>
return Object.freeze(route)<br>
}<br>
// 获得包含当前路由的所有嵌套路径⽚段的路由记录<br>
// 包含从根路由到当前路由的匹配记录，从上⾄下<br>
function formatMatch(record: ?RouteRecord): Array<RouteRecord> {<br>
const res = []<br>
while (record) {<br>
res.unshift(record)<br>
record = record.parent<br>
}<br>
return res<br>
}<br>
transitionTo (location: RawLocation, onComplete?: Function, onAbort?:<br>
Function) {<br>
// 确认切换路由<br>
this.confirmTransition(route, () =&gt; {}<br>
}<br>
confirmTransition(route: Route, onComplete: Function, onAbort?:<br>
Function) {<br>
const current = this.current<br>
// 中断跳转路由函数<br>
const abort = err =&gt; {<br>
if (isError(err)) {<br>
if (this.errorCbs.length) {<br>
this.errorCbs.forEach(cb =&gt; {<br>
cb(err)<br>
})<br>
} else {<br>
warn(false, 'uncaught error during route navigation:')<br>
console.error(err)<br>
}<br>
}<br>
onAbort &amp;&amp; onAbort(err)<br>
}<br>
// 如果是相同的路由就不跳转<br>
if (<br>
isSameRoute(route, current) &amp;&amp;<br>
route.matched.length === current.matched.length<br>
) {<br>
this.ensureURL()<br>
return abort()<br>
}<br>
// 通过对⽐路由解析出可复⽤的组件，需要渲染的组件，失活的组件<br>
const { updated, deactivated, activated } = resolveQueue(<br>
this.current.matched,<br>
route.matched<br>
)</p>
<p>function resolveQueue(<br>
current: Array<RouteRecord>,<br>
next: Array<RouteRecord><br>
): {<br>
updated: Array<RouteRecord>,<br>
activated: Array<RouteRecord>,<br>
deactivated: Array<RouteRecord><br>
} {<br>
let i<br>
const max = Math.max(current.length, next.length)<br>
for (i = 0; i &lt; max; i++) {<br>
// 当前路由路径和跳转路由路径不同时跳出遍历<br>
if (current[i] !== next[i]) {<br>
break<br>
}<br>
}<br>
return {<br>
// 可复⽤的组件对应路由<br>
updated: next.slice(0, i),<br>
// 需要渲染的组件对应路由<br>
activated: next.slice(i),<br>
// 失活的组件对应路由<br>
deactivated: current.slice(i)<br>
}<br>
}<br>
// 导航守卫数组<br>
const queue: Array&lt;?NavigationGuard&gt; = [].concat(<br>
// 失活的组件钩⼦<br>
extractLeaveGuards(deactivated),<br>
// 全局 beforeEach 钩⼦<br>
this.router.beforeHooks,<br>
// 在当前路由改变，但是该组件被复⽤时调⽤<br>
extractUpdateHooks(updated),<br>
// 需要渲染组件 enter 守卫钩⼦<br>
activated.map(m =&gt; m.beforeEnter),<br>
// 解析异步路由组件<br>
resolveAsyncComponents(activated)<br>
)<br>
// 保存路由<br>
this.pending = route<br>
// 迭代器，⽤于执⾏ queue 中的导航守卫钩⼦<br>
const iterator = (hook: NavigationGuard, next) =&gt; {<br>
// 路由不相等就不跳转路由<br>
if (this.pending !== route) {<br>
return abort()<br>
}<br>
try {<br>
// 执⾏钩⼦<br>
hook(route, current, (to: any) =&gt; {<br>
// 只有执⾏了钩⼦函数中的 next，才会继续执⾏下⼀个钩⼦函数<br>
// 否则会暂停跳转<br>
// 以下逻辑是在判断 next() 中的传参<br>
if (to === false || isError(to)) {<br>
// next(false)<br>
this.ensureURL(true)<br>
abort(to)<br>
} else if (<br>
typeof to === 'string' ||<br>
(typeof to === 'object' &amp;&amp;<br>
(typeof to.path === 'string' || typeof to.name ===<br>
'string'))<br>
) {<br>
// next('/') 或者 next({ path: '/' }) -&gt; 重定向<br>
abort()<br>
if (typeof to === 'object' &amp;&amp; to.replace) {<br>
this.replace(to)<br>
} else {<br>
this.push(to)<br>
}<br>
} else {<br>
// 这⾥执⾏ next<br>
// 也就是执⾏下⾯函数 runQueue 中的 step(index + 1)<br>
next(to)<br>
}<br>
})<br>
} catch (e) {<br>
abort(e)<br>
}<br>
}<br>
// 经典的同步执⾏异步函数<br>
runQueue(queue, iterator, () =&gt; {<br>
const postEnterCbs = []<br>
const isValid = () =&gt; this.current === route<br>
// 当所有异步组件加载完成后，会执⾏这⾥的回调，也就是 runQueue 中的 cb()<br>
// 接下来执⾏ 需要渲染组件的导航守卫钩⼦<br>
const enterGuards = extractEnterGuards(activated, postEnterCbs,<br>
isValid)<br>
const queue = enterGuards.concat(this.router.resolveHooks)<br>
runQueue(queue, iterator, () =&gt; {<br>
// 跳转完成<br>
if (this.pending !== route) {<br>
return abort()<br>
}<br>
this.pending = null<br>
onComplete(route)<br>
if (this.router.app) {<br>
this.router.app.$nextTick(() =&gt; {<br>
postEnterCbs.forEach(cb =&gt; {<br>
cb()<br>
})<br>
})<br>
}<br>
})<br>
})<br>
}<br>
export function runQueue (queue: Array&lt;?NavigationGuard&gt;, fn: Function,<br>
cb: Function) {<br>
const step = index =&gt; {<br>
// 队列中的函数都执⾏完毕，就执⾏回调函数<br>
if (index &gt;= queue.length) {<br>
cb()<br>
} else {<br>
if (queue[index]) {<br>
接下来介绍导航守卫<br>
第⼀步是先执⾏失活组件的钩⼦函数<br>
// 执⾏迭代器，⽤户在钩⼦函数中执⾏ next() 回调<br>
// 回调中判断传参，没有问题就执⾏ next()，也就是 fn 函数中的第⼆个参数<br>
fn(queue[index], () =&gt; {<br>
step(index + 1)<br>
})<br>
} else {<br>
step(index + 1)<br>
}<br>
}<br>
}<br>
// 取出队列中第⼀个钩⼦函数<br>
step(0)<br>
}<br>
const queue: Array&lt;?NavigationGuard&gt; = [].concat(<br>
// 失活的组件钩⼦<br>
extractLeaveGuards(deactivated),<br>
// 全局 beforeEach 钩⼦<br>
this.router.beforeHooks,<br>
// 在当前路由改变，但是该组件被复⽤时调⽤<br>
extractUpdateHooks(updated),<br>
// 需要渲染组件 enter 守卫钩⼦<br>
activated.map(m =&gt; m.beforeEnter),<br>
// 解析异步路由组件<br>
resolveAsyncComponents(activated)<br>
)<br>
function extractLeaveGuards(deactivated: Array<RouteRecord>): Array&lt;?<br>
Function&gt; {<br>
// 传⼊需要执⾏的钩⼦函数名<br>
return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)<br>
}<br>
function extractGuards(<br>
records: Array<RouteRecord>,<br>
name: string,<br>
bind: Function,<br>
reverse?: boolean<br>
): Array&lt;?Function&gt; {<br>
const guards = flatMapComponents(records, (def, instance, match, key)<br>
=&gt; {<br>
// 找出组件中对应的钩⼦函数<br>
const guard = extractGuard(def, name)<br>
if (guard) {<br>
// 给每个钩⼦函数添加上下⽂对象为组件⾃身<br>
return Array.isArray(guard)<br>
? guard.map(guard =&gt; bind(guard, instance, match, key))<br>
: bind(guard, instance, match, key)<br>
}<br>
})<br>
// 数组降维，并且判断是否需要翻转数组<br>
// 因为某些钩⼦函数需要从⼦执⾏到⽗<br>
return flatten(reverse ? guards.reverse() : guards)<br>
}<br>
export function flatMapComponents (<br>
matched: Array<RouteRecord>,<br>
fn: Function<br>
): Array&lt;?Function&gt; {<br>
// 数组降维<br>
return flatten(matched.map(m =&gt; {<br>
// 将组件中的对象传⼊回调函数中，获得钩⼦函数数组<br>
return Object.keys(m.components).map(key =&gt; fn(<br>
m.components[key],<br>
m.instances[key],<br>
m, key<br>
))<br>
}))<br>
}<br>
第⼆步执⾏全局 beforeEach 钩⼦函数<br>
在 VueRouter 类中有以上代码，每当给 VueRouter 实例添加 beforeEach 函数时就会将函数<br>
push 进 beforeHooks 中。<br>
第三步执⾏ beforeRouteUpdate 钩⼦函数，调⽤⽅式和第⼀步相同，只是传⼊的函数名不<br>
同，在该函数中可以访问到 this 对象。<br>
第四步执⾏ beforeEnter 钩⼦函数，该函数是路由独享的钩⼦函数。<br>
第五步是解析异步组件。<br>
beforeEach(fn: Function): Function {<br>
return registerHook(this.beforeHooks, fn)<br>
}<br>
function registerHook(list: Array<any>, fn: Function): Function {<br>
list.push(fn)<br>
return () =&gt; {<br>
const i = list.indexOf(fn)<br>
if (i &gt; -1) list.splice(i, 1)<br>
}<br>
}<br>
export function resolveAsyncComponents (matched: Array<RouteRecord>):<br>
Function {<br>
return (to, from, next) =&gt; {<br>
let hasAsync = false<br>
let pending = 0<br>
let error = null<br>
// 该函数作⽤之前已经介绍过了<br>
flatMapComponents(matched, (def, _, match, key) =&gt; {<br>
// 判断是否是异步组件<br>
if (typeof def === 'function' &amp;&amp; def.cid === undefined) {<br>
hasAsync = true<br>
pending++<br>
// 成功回调<br>
// once 函数确保异步组件只加载⼀次<br>
const resolve = once(resolvedDef =&gt; {<br>
if (isESModule(resolvedDef)) {<br>
resolvedDef = resolvedDef.default<br>
}<br>
// 判断是否是构造函数<br>
// 不是的话通过 Vue 来⽣成组件构造函数<br>
def.resolved = typeof resolvedDef === 'function'<br>
? resolvedDef<br>
: _Vue.extend(resolvedDef)<br>
// 赋值组件<br>
// 如果组件全部解析完毕，继续下⼀步<br>
match.components[key] = resolvedDef<br>
pending--<br>
if (pending &lt;= 0) {<br>
next()<br>
}<br>
})<br>
// 失败回调<br>
const reject = once(reason =&gt; {<br>
const msg = <code>Failed to resolve async component ${key}: ${reason}</code><br>
process.env.NODE_ENV !== 'production' &amp;&amp; warn(false, msg)<br>
if (!error) {<br>
error = isError(reason)<br>
? reason<br>
: new Error(msg)<br>
next(error)<br>
}<br>
})<br>
let res<br>
try {<br>
// 执⾏异步组件函数<br>
res = def(resolve, reject)<br>
以上就是第⼀个 runQueue 中的逻辑，第五步完成后会执⾏第⼀个 runQueue 中回调函数<br>
} catch (e) {<br>
reject(e)<br>
}<br>
if (res) {<br>
// 下载完成执⾏回调<br>
if (typeof res.then === 'function') {<br>
res.then(resolve, reject)<br>
} else {<br>
const comp = res.component<br>
if (comp &amp;&amp; typeof comp.then === 'function') {<br>
comp.then(resolve, reject)<br>
}<br>
}<br>
}<br>
}<br>
})<br>
// 不是异步组件直接下⼀步<br>
if (!hasAsync) next()<br>
}<br>
}<br>
// 该回调⽤于保存 <code>beforeRouteEnter</code> 钩⼦中的回调函数<br>
const postEnterCbs = []<br>
const isValid = () =&gt; this.current === route<br>
// beforeRouteEnter 导航守卫钩⼦<br>
const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)<br>
// beforeResolve 导航守卫钩⼦<br>
const queue = enterGuards.concat(this.router.resolveHooks)<br>
runQueue(queue, iterator, () =&gt; {<br>
if (this.pending !== route) {<br>
return abort()<br>
}<br>
this.pending = null<br>
第六步是执⾏ beforeRouteEnter 导航守卫钩⼦， beforeRouteEnter 钩⼦不能访问<br>
this 对象，因为钩⼦在导航确认前被调⽤，需要渲染的组件还没被创建。但是该钩⼦函数<br>
是唯⼀⼀个⽀持在回调中获取 this 对象的函数，回调会在路由确认执⾏。<br>
下⾯来看看是如何⽀持在回调中拿到 this 对象的<br>
// 这⾥会执⾏ afterEach 导航守卫钩⼦<br>
onComplete(route)<br>
if (this.router.app) {<br>
this.router.app.<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 63: … cb()
 })
 })
 }̲
})
beforeRoute…'>nextTick(() =&gt; {
 postEnterCbs.forEach(cb =&gt; {
 cb()
 })
 })
 }
})
beforeRouteEnter (to, from, next) {
 next(vm =&gt; {
 // 通过 `vm` 访问组件实例
 })
}
function extractEnterGuards(
 activated: Array&lt;RouteRecord&gt;,
 cbs: Array&lt;Function&gt;,
 isValid: () =&gt; boolean
): Array&lt;?Function&gt; {
// 这⾥和之前调⽤导航守卫基本⼀致
 return extractGuards(
 activated,
 &#039;beforeRouteEnter&#039;,
 (guard, _, match, key) =&gt; {
 return bindEnterGuard(guard, match, key, cbs, isValid)
 }
 )
}
function bindEnterGuard(
 guard: NavigationGuard,
 match: RouteRecord,
 key: string,
 cbs: Array&lt;Function&gt;,
 isValid: () =&gt; boolean
): NavigationGuard {
 return function routeEnterGuard(to, from, next) {
 return guard(to, from, cb =&gt; {
 // 判断 cb 是否是函数
 // 是的话就 push 进 postEnterCbs
 next(cb)
 if (typeof cb === &#039;function&#039;) {
 cbs.push(() =&gt; {
 // 循环直到拿到组件实例
 poll(cb, match.instances, key, isValid)
 })
 }
 })
 }
}
// 该函数是为了解决 issus #750
// 当 router-view 外⾯包裹了 mode 为 out-in 的 transition 组件
// 会在组件初次导航到时获得不到组件实例对象
function poll(
 cb: any, // somehow flow cannot infer this is a function
 instances: Object,
 key: string,
 isValid: () =&gt; boolean
) {
 if (
 instances[key] &amp;&amp;
 !instances[key]._isBeingDestroyed // do not reuse being destroyed
instance
第七步是执⾏ beforeResolve 导航守卫钩⼦，如果注册了全局 beforeResolve 钩⼦就会
在这⾥执⾏。
第⼋步就是导航确认，调⽤ afterEach 导航守卫钩⼦了。
以上都执⾏完成后，会触发组件的渲染
以上回调会在 updateRoute 中调⽤
 ) {
 cb(instances[key])
 } else if (isValid()) {
 // setTimeout 16ms 作⽤和 nextTick 基本相同
 setTimeout(() =&gt; {
 poll(cb, instances, key, isValid)
 }, 16)
 }
}
history.listen(route =&gt; {
 this.apps.forEach(app =&gt; {
 app._route = route
 })
})
updateRoute(route: Route) {
 const prev = this.current
 this.current = route
 this.cb &amp;&amp; this.cb(route)
 this.router.afterHooks.forEach(hook =&gt; {
 hook &amp;&amp; hook(route, prev)
 })
}
⾄此，路由跳转已经全部分析完毕。核⼼就是判断需要跳转的路由是否存在于记录中，然后
执⾏各种导航守卫函数，最后完成 URL 的改变和组件的渲染。
React 章节
React ⽣命周期分析
在 V16 版本中引⼊了 Fiber 机制。这个机制⼀定程度上的影响了部分⽣命周期的调⽤，并且
也引⼊了新的 2 个 API 来解决问题。
在之前的版本中，如果你拥有⼀个很复杂的复合组件，然后改动了最上层组件的 state ，那
么调⽤栈可能会很⻓
调⽤栈过⻓，再加上中间进⾏了复杂的操作，就可能导致⻓时间阻塞主线程，带来不好的⽤
户体验。Fiber 就是为了解决该问题⽽⽣。
Fiber 本质上是⼀个虚拟的堆栈帧，新的调度器会按照优先级⾃由调度这些帧，从⽽将之前的
同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。
对于如何区别优先级，React 有⾃⼰的⼀套逻辑。对于动画这种实时性很⾼的东⻄，也就是
16 ms 必须渲染⼀次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停⼀下更新，返回
来继续渲染动画。
对于异步渲染，现在渲染有两个阶段： reconciliation 和 commit 。前者过程是可以打断
的，后者不能暂停，会⼀直更新界⾯直到完成。
Reconciliation 阶段
componentWillMount
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
Commit 阶段
componentDidMount
componentDidUpdate
componentWillUnmount
因为 reconciliation 阶段是可以被打断的，所以 reconciliation 阶段会执⾏的⽣命周
期函数就可能会出现调⽤多次的情况，从⽽引起 Bug。所以对于 reconciliation 阶段调⽤
的⼏个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使⽤，并且 V16 中也
引⼊了新的 API 来解决这个问题。
getDerivedStateFromProps ⽤于替换 componentWillReceiveProps ，该函数会在初始化
和 update 时被调⽤
getSnapshotBeforeUpdate ⽤于替换 componentWillUpdate ，该函数会在 update 后
DOM 更新前被调⽤，⽤于读取最新的 DOM 数据。
V16 ⽣命周期函数⽤法建议
class ExampleComponent extends React.Component {
 // Initialize state in constructor,
 // Or with a property initializer.
 state = {};
 static getDerivedStateFromProps(nextProps, prevState) {
 if (prevState.someMirroredValue !== nextProps.someValue) {
 return {
 derivedData: computeDerivedState(nextProps),
 someMirroredValue: nextProps.someValue
 };
 }
 // Return null to indicate no change to state.
 return null;
 }
}
class ExampleComponent extends React.Component {
 // ⽤于初始化 state
 constructor() {}
setState
setState 在 React 中是经常使⽤的⼀个 API，但是它存在⼀些问题，可能会导致犯错，核
⼼原因就是因为这个 API 是异步的。
⾸先 setState 的调⽤并不会⻢上引起 state 的改变，并且如果你⼀次调⽤了多个
setState ，那么结果可能并不如你期待的⼀样。
 // ⽤于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被
调⽤
 // 因为该函数是静态函数，所以取不到 `this`
 // 如果需要对⽐ `prevProps` 需要单独在 `state` 中维护
 static getDerivedStateFromProps(nextProps, prevState) {}
 // 判断是否需要更新组件，多⽤于组件性能优化
 shouldComponentUpdate(nextProps, nextState) {}
 // 组件挂载后调⽤
 // 可以在该函数中进⾏请求或者订阅
 componentDidMount() {}
 // ⽤于获得最新的 DOM 数据
 getSnapshotBeforeUpdate() {}
 // 组件即将销毁
 // 可以在此处移除订阅，定时器等等
 componentWillUnmount() {}
 // 组件销毁后调⽤
 componentDidUnMount() {}
 // 组件更新后调⽤
 componentDidUpdate() {}
 // 渲染组件函数
 render() {}
 // 以下函数不建议使⽤
 UNSAFE_componentWillMount() {}
 UNSAFE_componentWillUpdate(nextProps, nextState) {}
 UNSAFE_componentWillReceiveProps(nextProps) {}
}
第⼀，两次的打印都为 0，因为 setState 是个异步 API，只有同步代码运⾏完毕才会执
⾏。 setState 异步的原因我认为在于， setState 可能会导致 DOM 的重绘，如果调⽤⼀
次就⻢上去进⾏重绘，那么调⽤多次就会造成不必要的性能损失。设计成异步的话，就可以
将多次调⽤放⼊⼀个队列中，在恰当的时候统⼀进⾏更新过程。
第⼆，虽然调⽤了三次 setState ，但是 count 的值还是为 1。因为多次调⽤会合并为⼀
次，只有当更新结束后 state 才会改变，三次调⽤等同于如下代码
当然你也可以通过以下⽅式来实现调⽤三次 setState 使得 count 为 3
如果你想在每次调⽤ setState 后获得正确的 state ，可以通过如下代码实现
handle() {
 // 初始化 `count` 为 0
 console.log(this.state.count) // -&gt; 0
 this.setState({ count: this.state.count + 1 })
 this.setState({ count: this.state.count + 1 })
 this.setState({ count: this.state.count + 1 })
 console.log(this.state.count) // -&gt; 0
}
Object.assign(
 {},
 { count: this.state.count + 1 },
 { count: this.state.count + 1 },
 { count: this.state.count + 1 },
)
handle() {
 this.setState((prevState) =&gt; ({ count: prevState.count + 1 }))
 this.setState((prevState) =&gt; ({ count: prevState.count + 1 }))
 this.setState((prevState) =&gt; ({ count: prevState.count + 1 }))
}
Redux 源码分析
⾸先让我们来看下 combineReducers 函数
handle() {
 this.setState((prevState) =&gt; ({ count: prevState.count + 1 }), () =&gt;
{
 console.log(this.state)
 })
}
// 传⼊⼀个 object
export default function combineReducers(reducers) {
// 获取该 Object 的 key 值
 const reducerKeys = Object.keys(reducers)
 // 过滤后的 reducers
 const finalReducers = {}
 // 获取每⼀个 key 对应的 value
 // 在开发环境下判断值是否为 undefined
 // 然后将值类型是函数的值放⼊ finalReducers
 for (let i = 0; i &lt; reducerKeys.length; i++) {
 const key = reducerKeys[i]
 if (process.env.NODE_ENV !== &#039;production&#039;) {
 if (typeof reducers[key] === &#039;undefined&#039;) {
 warning(`No reducer provided for key &quot;</span>{key}&quot;`)<br>
}<br>
}<br>
if (typeof reducers[key] === 'function') {<br>
finalReducers[key] = reducers[key]<br>
}<br>
}<br>
// 拿到过滤后的 reducers 的 key 值<br>
const finalReducerKeys = Object.keys(finalReducers)</p>
<p>// 在开发环境下判断，保存不期望 key 的缓存⽤以下⾯做警告<br>
let unexpectedKeyCache<br>
if (process.env.NODE_ENV !== 'production') {<br>
unexpectedKeyCache = {}<br>
}</p>
<p>let shapeAssertionError<br>
try {<br>
// 该函数解析在下⾯<br>
assertReducerShape(finalReducers)<br>
} catch (e) {<br>
shapeAssertionError = e<br>
}<br>
// combineReducers 函数返回⼀个函数，也就是合并后的 reducer 函数<br>
// 该函数返回总的 state<br>
// 并且你也可以发现这⾥使⽤了闭包，函数⾥⾯使⽤到了外⾯的⼀些属性<br>
return function combination(state = {}, action) {<br>
if (shapeAssertionError) {<br>
throw shapeAssertionError<br>
}<br>
// 该函数解析在下⾯<br>
if (process.env.NODE_ENV !== 'production') {<br>
const warningMessage = getUnexpectedStateShapeWarningMessage(<br>
state,<br>
finalReducers,<br>
action,<br>
unexpectedKeyCache<br>
)<br>
if (warningMessage) {<br>
warning(warningMessage)<br>
}<br>
}<br>
// state 是否改变<br>
let hasChanged = false<br>
// 改变后的 state<br>
combineReducers 函数总的来说很简单，总结来说就是接收⼀个对象，将参数过滤后返回⼀<br>
个函数。该函数⾥有⼀个过滤参数后的对象 finalReducers，遍历该对象，然后执⾏对象中的<br>
每⼀个 reducer 函数，最后将新的 state 返回。<br>
接下来让我们来看看 combinrReducers 中⽤到的两个函数<br>
const nextState = {}<br>
for (let i = 0; i &lt; finalReducerKeys.length; i++) {<br>
// 拿到相应的 key<br>
const key = finalReducerKeys[i]<br>
// 获得 key 对应的 reducer 函数<br>
const reducer = finalReducers[key]<br>
// state 树下的 key 是与 finalReducers 下的 key 相同的<br>
// 所以你在 combineReducers 中传⼊的参数的 key 即代表了 各个 reducer 也<br>
代表了各个 state<br>
const previousStateForKey = state[key]<br>
// 然后执⾏ reducer 函数获得该 key 值对应的 state<br>
const nextStateForKey = reducer(previousStateForKey, action)<br>
// 判断 state 的值，undefined 的话就报错<br>
if (typeof nextStateForKey === 'undefined') {<br>
const errorMessage = getUndefinedStateErrorMessage(key, action)<br>
throw new Error(errorMessage)<br>
}<br>
// 然后将 value 塞进去<br>
nextState[key] = nextStateForKey<br>
// 如果 state 改变<br>
hasChanged = hasChanged || nextStateForKey !== previousStateForKey<br>
}<br>
// state 只要改变过，就返回新的 state<br>
return hasChanged ? nextState : state<br>
}<br>
}<br>
// 这是执⾏的第⼀个⽤于抛错的函数<br>
function assertReducerShape(reducers) {<br>
// 将 combineReducers 中的参数遍历<br>
Object.keys(reducers).forEach(key =&gt; {<br>
const reducer = reducers[key]<br>
// 给他传⼊⼀个 action<br>
const initialState = reducer(undefined, { type: ActionTypes.INIT })<br>
// 如果得到的 state 为 undefined 就抛错<br>
if (typeof initialState === 'undefined') {<br>
throw new Error(<br>
<code>Reducer &quot;${key}&quot; returned undefined during initialization.</code> +<br>
<code>If the state passed to the reducer is undefined, you must</code> +<br>
<code>explicitly return the initial state. The initial state may</code><br>
+<br>
<code>not be undefined. If you don't want to set a value for this reducer,</code> +<br>
<code>you can use null instead of undefined.</code><br>
)<br>
}<br>
// 再过滤⼀次，考虑到万⼀你在 reducer 中给 ActionTypes.INIT 返回了值<br>
// 传⼊⼀个随机的 action 判断值是否为 undefined<br>
const type =<br>
'@@redux/PROBE_UNKNOWN_ACTION_' +<br>
Math.random()<br>
.toString(36)<br>
.substring(7)<br>
.split('')<br>
.join('.')<br>
if (typeof reducer(undefined, { type }) === 'undefined') {<br>
throw new Error(<br>
<code>Reducer &quot;${key}&quot; returned undefined when probed with a random type.</code> +<br>
<code>Don't try to handle ${ ActionTypes.INIT } or other actions in &quot;redux/*&quot;</code> +<br>
<code>namespace. They are considered private. Instead, you must return the</code> +<br>
<code>current state for any unknown actions, unless it is undefined,</code> +<br>
<code>in which case you must return the initial state, regardless of the</code> +<br>
<code>action type. The initial state may not be undefined, but can be null.</code><br>
)<br>
}<br>
})<br>
}<br>
function getUnexpectedStateShapeWarningMessage(<br>
inputState,<br>
reducers,<br>
action,<br>
unexpectedKeyCache<br>
) {<br>
// 这⾥的 reducers 已经是 finalReducers<br>
const reducerKeys = Object.keys(reducers)<br>
const argumentName =<br>
action &amp;&amp; action.type === ActionTypes.INIT<br>
? 'preloadedState argument passed to createStore'<br>
: 'previous state received by the reducer'</p>
<p>// 如果 finalReducers 为空<br>
if (reducerKeys.length === 0) {<br>
return (<br>
'Store does not have a valid reducer. Make sure the argument<br>
passed ' +<br>
'to combineReducers is an object whose values are reducers.'<br>
)<br>
}<br>
// 如果你传⼊的 state 不是对象<br>
if (!isPlainObject(inputState)) {<br>
return (<br>
<code>The ${argumentName} has unexpected type of &quot;</code> +<br>
接下来让我们先来看看 compose 函数<br>
{}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] +<br>
<code>&quot;. Expected argument to be an object with the following</code> +<br>
<code>keys: &quot;${reducerKeys.join('&quot;, &quot;')}&quot;</code><br>
)<br>
}<br>
// 将参⼊的 state 于 finalReducers 下的 key 做⽐较，过滤出多余的 key<br>
const unexpectedKeys = Object.keys(inputState).filter(<br>
key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]<br>
)<br>
unexpectedKeys.forEach(key =&gt; {<br>
unexpectedKeyCache[key] = true<br>
})<br>
if (action &amp;&amp; action.type === ActionTypes.REPLACE) return<br>
// 如果 unexpectedKeys 有值的话<br>
if (unexpectedKeys.length &gt; 0) {<br>
return (<br>
<code>Unexpected ${unexpectedKeys.length &gt; 1 ? 'keys' : 'key'}</code> +<br>
<code>&quot;${unexpectedKeys.join('&quot;, &quot;')}&quot; found in ${argumentName}.</code> +<br>
<code>Expected to find one of the known reducer keys instead:</code> +<br>
<code>&quot;${reducerKeys.join('&quot;, &quot;')}&quot;. Unexpected keys will be ignored.</code><br>
)<br>
}<br>
}<br>
// 这个函数设计的很巧妙，通过传⼊函数引⽤的⽅式让我们完成多个函数的嵌套使⽤，术语叫做<br>
⾼阶函数<br>
// 通过使⽤ reduce 函数做到从右⾄左调⽤函数<br>
// 对于上⾯项⽬中的例⼦<br>
compose(<br>
applyMiddleware(thunkMiddleware),<br>
然后我们来解析 createStore 函数的部分代码<br>
window.devToolsExtension ? window.devToolsExtension() : f =&gt; f<br>
)<br>
// 经过 compose 函数变成了 applyMiddleware(thunkMiddleware)<br>
(window.devToolsExtension()())<br>
// 所以在找不到 window.devToolsExtension 时你应该返回⼀个函数<br>
export default function compose(...funcs) {<br>
if (funcs.length === 0) {<br>
return arg =&gt; arg<br>
}<br>
if (funcs.length === 1) {<br>
return funcs[0]<br>
}<br>
return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))<br>
}<br>
export default function createStore(reducer, preloadedState, enhancer) {<br>
// ⼀般 preloadedState ⽤的少，判断类型，如果第⼆个参数是函数且没有第三个参数，<br>
就调换位置<br>
if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer ===<br>
'undefined') {<br>
enhancer = preloadedState<br>
preloadedState = undefined<br>
}<br>
// 判断 enhancer 是否是函数<br>
if (typeof enhancer !== 'undefined') {<br>
if (typeof enhancer !== 'function') {<br>
throw new Error('Expected the enhancer to be a function.')<br>
}<br>
// 类型没错的话，先执⾏ enhancer，然后再执⾏ createStore 函数<br>
return enhancer(createStore)(reducer, preloadedState)<br>
}<br>
接下来先来介绍 applyMiddleware 函数<br>
在这之前我需要先来介绍⼀下函数柯⾥化，柯⾥化是⼀种将使⽤多个参数的⼀个函数转换成<br>
⼀系列使⽤⼀个参数的函数的技术。<br>
// 判断 reducer 是否是函数<br>
if (typeof reducer !== 'function') {<br>
throw new Error('Expected the reducer to be a function.')<br>
}<br>
// 当前 reducer<br>
let currentReducer = reducer<br>
// 当前状态<br>
let currentState = preloadedState<br>
// 当前监听函数数组<br>
let currentListeners = []<br>
// 这是⼀个很重要的设计，为的就是每次在遍历监听器的时候保证 currentListeners 数<br>
组不变<br>
// 可以考虑下只存在 currentListeners 的情况，如果我在某个 subscribe 中再次执<br>
⾏ subscribe<br>
// 或者 unsubscribe，这样会导致当前的 currentListeners 数组⼤⼩发⽣改变，从⽽<br>
可能导致<br>
// 索引出错<br>
let nextListeners = currentListeners<br>
// reducer 是否正在执⾏<br>
let isDispatching = false<br>
// 如果 currentListeners 和 nextListeners 相同，就赋值回去<br>
function ensureCanMutateNextListeners() {<br>
if (nextListeners === currentListeners) {<br>
nextListeners = currentListeners.slice()<br>
}<br>
}<br>
// ......<br>
}<br>
function add(a,b) { return a + b }<br>
add(1, 2) =&gt; 3<br>
// 对于以上函数如果使⽤柯⾥化可以这样改造<br>
function add(a) {<br>
return b =&gt; {<br>
return a + b<br>
}<br>
}<br>
add(1)(2) =&gt; 3<br>
// 你可以这样理解函数柯⾥化，通过闭包保存了外部的⼀个变量，然后返回⼀个接收参数的函<br>
数，在该函数中使⽤了保存的变量，然后再返回值。<br>
// 这个函数应该是整个源码中最难理解的⼀块了<br>
// 该函数返回⼀个柯⾥化的函数<br>
// 所以调⽤这个函数应该这样写 applyMiddleware(...middlewares)(createStore)<br>
(...args)<br>
export default function applyMiddleware(...middlewares) {<br>
return createStore =&gt; (...args) =&gt; {<br>
// 这⾥执⾏ createStore 函数，把 applyMiddleware 函数最后次调⽤的参数传进来<br>
const store = createStore(...args)<br>
let dispatch = () =&gt; {<br>
throw new Error(<br>
<code>Dispatching while constructing your middleware is not allowed.</code> +<br>
<code>Other middleware would not be applied to this dispatch.</code><br>
)<br>
}<br>
let chain = []<br>
// 每个中间件都应该有这两个函数<br>
const middlewareAPI = {<br>
getState: store.getState,<br>
dispatch: (...args) =&gt; dispatch(...args)<br>
}<br>
// 把 middlewares 中的每个中间件都传⼊ middlewareAPI<br>
chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))<br>
好了，我们现在将困难的部分都攻克了，来看⼀些简单的代码<br>
// 和之前⼀样，从右⾄左调⽤每个中间件，然后传⼊ store.dispatch<br>
dispatch = compose(...chain)(store.dispatch)<br>
// 这⾥只看这部分代码有点抽象，我这⾥放⼊ redux-thunk 的代码来结合分析<br>
// createThunkMiddleware返回了3层函数，第⼀层函数接收 middlewareAPI 参数<br>
// 第⼆次函数接收 store.dispatch<br>
// 第三层函数接收 dispatch 中的参数<br>
{function createThunkMiddleware(extraArgument) {<br>
return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {<br>
// 判断 dispatch 中的参数是否为函数<br>
if (typeof action === 'function') {<br>
// 是函数的话再把这些参数传进去，直到 action 不为函数，执⾏ dispatch({tyep:<br>
'XXX'})<br>
return action(dispatch, getState, extraArgument);<br>
}<br>
return next(action);<br>
};<br>
}<br>
const thunk = createThunkMiddleware();<br>
export default thunk;}<br>
// 最后把经过中间件加强后的 dispatch 于剩余 store 中的属性返回，这样你的<br>
dispatch<br>
return {<br>
...store,<br>
dispatch<br>
}<br>
}<br>
}<br>
// 这个没啥好说的，就是把当前的 state 返回，但是当正在执⾏ reducer 时不能执⾏该⽅<br>
法<br>
function getState() {<br>
if (isDispatching) {<br>
throw new Error(<br>
'You may not call store.getState() while the reducer is<br>
executing. ' +<br>
'The reducer has already received the state as an argument. '<br>
+<br>
'Pass it down from the top reducer instead of reading it from<br>
the store.'<br>
)<br>
}<br>
return currentState<br>
}<br>
// 接收⼀个函数参数<br>
function subscribe(listener) {<br>
if (typeof listener !== 'function') {<br>
throw new Error('Expected listener to be a function.')<br>
}<br>
// 这部分最主要的设计 nextListeners 已经讲过，其他基本没什么好说的<br>
if (isDispatching) {<br>
throw new Error(<br>
'You may not call store.subscribe() while the reducer is<br>
executing. ' +<br>
'If you would like to be notified after the store has been<br>
updated, subscribe from a ' +<br>
'component and invoke store.getState() in the callback to<br>
access the latest state. ' +<br>
'See http://redux.js.org/docs/api/Store.html#subscribe for<br>
more details.'<br>
)<br>
}<br>
let isSubscribed = true<br>
ensureCanMutateNextListeners()<br>
nextListeners.push(listener)<br>
// 返回⼀个取消订阅函数<br>
return function unsubscribe() {<br>
if (!isSubscribed) {<br>
return<br>
}<br>
if (isDispatching) {<br>
throw new Error(<br>
'You may not unsubscribe from a store listener while the<br>
reducer is executing. ' +<br>
'See http://redux.js.org/docs/api/Store.html#subscribe for<br>
more details.'<br>
)<br>
}<br>
isSubscribed = false<br>
ensureCanMutateNextListeners()<br>
const index = nextListeners.indexOf(listener)<br>
nextListeners.splice(index, 1)<br>
}<br>
}<br>
function dispatch(action) {<br>
// 原⽣的 dispatch 会判断 action 是否为对象<br>
if (!isPlainObject(action)) {<br>
throw new Error(<br>
'Actions must be plain objects. ' +<br>
'Use custom middleware for async actions.'<br>
)<br>
}<br>
if (typeof action.type === 'undefined') {<br>
throw new Error(<br>
'Actions may not have an undefined &quot;type&quot; property. ' +<br>
安全章节<br>
'Have you misspelled a constant?'<br>
)<br>
}<br>
// 注意在 Reducers 中是不能执⾏ dispatch 函数的<br>
// 因为你⼀旦在 reducer 函数中执⾏ dispatch，会引发死循环<br>
if (isDispatching) {<br>
throw new Error('Reducers may not dispatch actions.')<br>
}<br>
// 执⾏ combineReducers 组合后的函数<br>
try {<br>
isDispatching = true<br>
currentState = currentReducer(currentState, action)<br>
} finally {<br>
isDispatching = false<br>
}<br>
// 然后遍历 currentListeners，执⾏数组中保存的函数<br>
const listeners = (currentListeners = nextListeners)<br>
for (let i = 0; i &lt; listeners.length; i++) {<br>
const listener = listeners[i]<br>
listener()<br>
}<br>
return action<br>
}<br>
// 然后在 createStore 末尾会发起⼀个 action dispatch({ type:<br>
ActionTypes.INIT });<br>
// ⽤以初始化 state<br>
XSS<br>
跨⽹站指令码（英语：Cross-site scripting，通常简称为：XSS）是⼀种⽹站应⽤程<br>
式的安全漏洞攻击，是代码注⼊的⼀种。它允许恶意使⽤者将程式码注⼊到⽹⻚上，<br>
其他使⽤者在观看⽹⻚时就会受到影响。这类攻击通常包含了 HTML 以及使⽤者端<br>
脚本语⾔。<br>
XSS 分为三种：反射型，存储型和 DOM-based<br>
如何攻击<br>
XSS 通过修改 HTML 节点或者执⾏ JS 代码来攻击⽹站。<br>
例如通过 URL 获取某些参数<br>
上述 URL 输⼊可能会将 HTML 改为 <div><script>alert(1)</script></div> ，这样⻚<br>
⾯中就凭空多了⼀段可执⾏脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻<br>
击。<br>
也有另⼀种场景，⽐如写了⼀篇包含攻击代码 <script>alert(1)</script> 的⽂章，那么<br>
可能浏览⽂章的⽤户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based<br>
攻击，并且这种攻击打击⾯更⼴。<br>
如何防御<br>
最普遍的做法是转义输⼊输出的内容，对于引号，尖括号，斜杠进⾏转义</p>
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>
通过转义可以将攻击代码 <script>alert(1)</script> 变成
对于显示富⽂本来说，不能通过上⾯的办法来转义所有字符，因为这样会把需要的格式也过
滤掉。这种情况通常采⽤⽩名单过滤的办法，当然也可以通过⿊名单过滤，但是考虑到需要
过滤的标签和标签属性实在太多，更加推荐使⽤⽩名单的⽅式。
以上示例使⽤了 js-xss 来实现。可以看到在输出中保留了 h1 标签且过滤了 script 标
签
CSP
内容安全策略 (CSP) 是⼀个额外的安全层，⽤于检测并削弱某些特定类型的攻击，
包括跨站脚本 (XSS) 和数据注⼊攻击等。⽆论是数据盗取、⽹站内容污染还是散发恶
意软件，这些攻击都是主要的⼿段。
function escape(str) {
 str = str.replace(/&/g, "&amp;");
 str = str.replace(/</g, "&lt;");
 str = str.replace(/>/g, "&gt;");
 str = str.replace(/"/g, "&quto;");
 str = str.replace(/'/g, "&#39;");
 str = str.replace(/`/g, "&#96;");
 str = str.replace(/\//g, "&#x2F;");
 return str
}
// -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt;
escape('<script>alert(1)</script>')
var xss = require("xss");
var html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");
</script>');
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html);
我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建⽴⽩名单，规定了浏览器只能
够执⾏特定来源的代码。
通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP
只允许加载本站资源
只允许加载 HTTPS 协议图⽚
允许加载任何来源框架
更多属性可以查看 这⾥
CSRF
跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或
者 session riding，通常缩写为 CSRF 或者 XSRF， 是⼀种挟制⽤户在当前已登录
的Web应⽤程序上执⾏⾮本意的操作的攻击⽅法。[1] 跟跨網站指令碼（XSS）相
⽐，XSS 利⽤的是⽤户对指定⽹站的信任，CSRF 利⽤的是⽹站对⽤户⽹⻚浏览器
的信任。
简单点说，CSRF 就是利⽤⽤户的登录态发起恶意请求。
如何攻击
假设⽹站中有⼀个通过 Get 请求提交⽤户评论的接⼝，那么攻击者就可以在钓⻥⽹站中加⼊
⼀个图⽚，图⽚的地址就是评论接⼝
Content-Security-Policy: default-src ‘self’
Content-Security-Policy: img-src https://*
Content-Security-Policy: child-src 'none'
<img src="http://www.domain.com/xxx?comment='attack'"/>
如果接⼝是 Post 提交的，就相对麻烦点，需要⽤表单来提交接⼝
如何防御
防范 CSRF 可以遵循以下⼏种规则：
1. Get 请求不对数据进⾏修改
2. 不让第三⽅⽹站访问到⽤户 Cookie
3. 阻⽌第三⽅⽹站请求接⼝
4. 请求时附带验证信息，⽐如验证码或者 token
SameSite
可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以
很⼤程度减少 CSRF 的攻击，但是该属性⽬前并不是所有浏览器都兼容。
验证 Referer
对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三⽅⽹站发
起的。
Token
服务器下发⼀个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验
证 Token 是否有效。
密码安全
密码安全虽然⼤多是后端的事情，但是作为⼀名优秀的前端程序员也需要熟悉这⽅⾯的知
识。
<form action="http://www.domain.com/xxx" id="CSRF" method="post">
 <input name="comment" value="attack" type="hidden">
</form>
加盐
对于密码存储来说，必然是不能明⽂存储在数据库中的，否则⼀旦数据库泄露，会对⽤户造
成很⼤的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。
通常需要对密码加盐，然后进⾏⼏次不同加密算法的加密。
但是加盐并不能阻⽌别⼈盗取账号，只能确保即使数据库泄露，也不会暴露⽤户的真实密
码。⼀旦攻击者得到了⽤户的账号，可以通过暴⼒破解的⽅式破解密码。对于这种情况，通
常使⽤验证码增加延时或者限制尝试次数的⽅式。并且⼀旦⽤户输⼊了错误的密码，也不能
直接提示⽤户输错密码，⽽应该提示账号或密码错误。
⽹络章节
UDP
⾯向报⽂
UDP 是⼀个⾯向报⽂（报⽂可以理解为⼀段段的数据）的协议。意思就是 UDP 只是报⽂的
搬运⼯，不会对报⽂进⾏任何拆分和拼接操作。
具体来说
在发送端，应⽤层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加⼀个 UDP 头
标识下是 UDP 协议，然后就传递给⽹络层了
在接收端，⽹络层将数据传递给传输层，UDP 只去除 IP 报⽂头就传递给应⽤层，不会任
何拼接操作
// 加盐也就是给原密码添加字符串，增加原密码⻓度
sha256(sha1(md5(salt + password + salt)))
不可靠性
1. UDP 是⽆连接的，也就是说通信不需要建⽴和断开连接。
2. UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对⽅能
不能收到是不关⼼的
3. UDP 没有拥塞控制，⼀直会以恒定的速度发送数据。即使⽹络条件不好，也不会对发送
速率进⾏调整。这样实现的弊端就是在⽹络条件不好的情况下可能会导致丢包，但是优点
也很明显，在某些实时性要求⾼的场景（⽐如电话会议）就需要使⽤ UDP ⽽不是 TCP。
⾼效
因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销⼩，
只有⼋字节，相⽐ TCP 的⾄少⼆⼗字节要少得多，在传输数据报⽂时是很⾼效的。
头部包含了以下⼏个数据
两个⼗六位的端⼝号，分别为源端⼝（可选字段）和⽬标端⼝
整个数据报⽂的⻓度
整个数据报⽂的检验和（IPv4 可选 字段），该字段⽤于发现头部信息和数据中的错误
传输⽅式
UDP 不⽌⽀持⼀对⼀的传输⽅式，同样⽀持⼀对多，多对多，多对⼀的⽅式，也就是说 UDP
提供了单播，多播，⼴播的功能。
TCP
头部
TCP 头部⽐ UDP 头部复杂的多
对于 TCP 头部来说，以下⼏个字段是很重要的
Sequence number，这个序号保证了 TCP 传输的报⽂都是有序的，对端可以通过序号顺
序的拼接报⽂
Acknowledgement Number，这个序号表示数据接收端期望接收的下⼀个字节的编号是
多少，同时也表示上⼀个序号的数据已经收到
Window Size，窗⼝⼤⼩，表示还能接收多少字节的数据，⽤于流量控制
标识符
URG=1：该字段为⼀表示本数据报的数据部分包含紧急信息，是⼀个⾼优先级数据
报⽂，此时紧急指针有效。紧急数据⼀定位于当前数据包数据部分的最前⾯，紧急指
针标明了紧急数据的尾部。
ACK=1：该字段为⼀表示确认号字段有效。此外，TCP 还规定在连接建⽴后传送的
所有报⽂段都必须把 ACK 置为⼀。
PSH=1：该字段为⼀表示接收端应该⽴即将数据 push 给应⽤层，⽽不是等到缓冲区
满后再提交。
RST=1：该字段为⼀表示当前 TCP 连接出现严重问题，可能需要重新建⽴ TCP 连
接，也可以⽤于拒绝⾮法的报⽂段和拒绝连接请求。
SYN=1：当SYN=1，ACK=0时，表示当前报⽂段是⼀个连接请求报⽂。当SYN=1，
ACK=1时，表示当前报⽂段是⼀个同意建⽴连接的应答报⽂。
FIN=1：该字段为⼀表示此报⽂段是⼀个释放连接的请求报⽂。
状态机
HTTP 是⽆连接的，所以作为下层的 TCP 协议也是⽆连接的，虽然看似 TCP 将两端连接了起
来，但是其实只是两端共同维护了⼀个状态
TCP 的状态机是很复杂的，并且与建⽴断开连接时的握⼿息息相关，接下来就来详细描述下
两种握⼿。
在这之前需要了解⼀个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据
所需的往返时间。
建⽴连接三次握⼿
在 TCP 协议中，主动发起请求的⼀端为客户端，被动连接的⼀端称为服务端。不管是客户端
还是服务端，TCP 连接建⽴完后都能发送和接收数据，所以 TCP 也是⼀个全双⼯的协议。
起初，两端都为 CLOSED 状态。在通信开始前，双⽅都会创建 TCB。 服务器创建完 TCB 后
遍进⼊ LISTEN 状态，此时开始等待客户端发送数据。
第⼀次握⼿
客户端向服务端发送连接请求报⽂段。该报⽂段中包含⾃身的数据通讯初始序号。请求发送
后，客户端便进⼊ SYN-SENT 状态， x 表示客户端的数据通信初始序号。
第⼆次握⼿
服务端收到连接请求报⽂段后，如果同意连接，则会发送⼀个应答，该应答中也会包含⾃身
的数据通讯初始序号，发送完成后便进⼊ SYN-RECEIVED 状态。
第三次握⼿
当客户端收到连接同意的应答后，还要向服务端发送⼀个确认报⽂。客户端发完这个报⽂段
后便进⼊ESTABLISHED 状态，服务端收到这个应答后也进⼊ ESTABLISHED 状态，此时连
接建⽴成功。
PS：第三次握⼿可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握⼿的协
议，都可以使⽤类似 TFO 的⽅式，客户端和服务端存储相同 cookie，下次握⼿时发出
cookie 达到减少 RTT 的⽬的。
你是否有疑惑明明两次握⼿就可以建⽴起连接，为什么还需要第三次应答？
因为这是为了防⽌失效的连接请求报⽂段被服务端接收，从⽽产⽣错误。
可以想象如下场景。客户端发送了⼀个连接请求 A，但是因为⽹络原因造成了超时，这时
TCP 会启动超时重传的机制再次发送⼀个连接请求 B。此时请求顺利到达服务端，服务端应
答完就建⽴了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认
为客户端⼜需要建⽴ TCP 连接，从⽽应答了该请求并进⼊ ESTABLISHED 状态。此时客户端
其实是 CLOSED 状态，那么就会导致服务端⼀直等待，造成资源的浪费。
PS：在建⽴连接中，任意⼀端掉线，TCP 都会重发 SYN 包，⼀般会重试五次，在建⽴连接
中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者⼲脆在不能处
理的情况下拒绝请求。
断开链接四次握⼿
TCP 是全双⼯的，在断开连接时两端都需要发送 FIN 和 ACK。
第⼀次握⼿
若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。
第⼆次握⼿
B 收到连接释放请求后，会告诉应⽤层要释放 TCP 链接。然后会发送 ACK 包，并进⼊
CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连
接时双向的，所以 B 仍旧可以发送数据给 A。
第三次握⼿
B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进⼊
LAST-ACK 状态。
PS：通过延迟确认的技术（通常有时间限制，否则对⽅会误认为需要重传），可以将第⼆次
和第三次握⼿合并，延迟 ACK 包的发送。
第四次握⼿
A 收到释放请求后，向 B 发送确认应答，此时 A 进⼊ TIME-WAIT 状态。该状态会持续
2MSL（最⼤段⽣存期，指报⽂段在⽹络中⽣存的时间，超时会被抛弃） 时间，若该时间段
内没有 B 的重发请求的话，就进⼊ CLOSED 状态。当 B 收到确认应答后，也便进⼊
CLOSED 状态。
为什么 A 要进⼊ TIME-WAIT 状态，等待 2MSL 时间后才进⼊ CLOSED 状态？
为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进⼊ CLOSED 状态，如果确认
应答因为⽹络问题⼀直没有到达，那么会造成 B 不能正常关闭。
ARQ 协议
ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含
停⽌等待 ARQ 和连续 ARQ
停⽌等待 ARQ
正常传输过程
只要 A 向 B 发送⼀段报⽂，都要停⽌发送并启动⼀个定时器，等待对端回应，在定时器时间
内接收到对端应答就取消定时器并发送下⼀段报⽂。
报⽂丢失或出错
在报⽂传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数
据直到对端响应，所以需要每次都备份发送的数据。
即使报⽂正常的传输到对端，也可能出现在传输过程中报⽂出错的问题。这时候对端会抛弃
该报⽂并等待 A 端重传。
PS：⼀般定时器设定的时间都会⼤于⼀个 RTT 的平均时间。
ACK 超时或丢失
对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报⽂。
这时候 B 端收到相同序号的报⽂会丢弃该报⽂并重传应答，直到 A 端发送下⼀个序号的报
⽂。
在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接
收过只需要丢弃应答即可。
这个协议的缺点就是传输效率低，在良好的⽹络环境下每次发送报⽂都得等待对端的 ACK 。
连续 ARQ
在连续 ARQ 中，发送端拥有⼀个发送窗⼝，可以在没有收到应答的情况下持续发送窗⼝内的
数据，这样相⽐停⽌等待 ARQ 协议来说减少了等待时间，提⾼了效率。
累计确认
连续 ARQ 中，接收端会持续不断收到报⽂。如果和停⽌等待 ARQ 中接收⼀个报⽂就发送⼀
个应答⼀样，就太浪费资源了。通过累计确认，可以在收到多个报⽂以后统⼀回复⼀个应答
报⽂。报⽂中的 ACK 可以⽤来告诉发送端这个序号之前的数据已经全部接收到了，下次请发
送这个序号 + 1的数据。
但是累计确认也有⼀个弊端。在连续接收报⽂时，可能会遇到接收到序号 5 的报⽂后，并未
接到序号 6 的报⽂，然⽽序号 7 以后的报⽂已经接收。遇到这种情况时，ACK 只能回复 6，
这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下⽂说到。
滑动窗⼝
在上⾯⼩节中讲到了发送窗⼝。在 TCP 中，两端都维护着窗⼝：分别为发送端窗⼝和接收端
窗⼝。
发送端窗⼝包含已发送但未收到应答的数据和可以发送但是未发送的数据。
发送端窗⼝是由接收窗⼝剩余⼤⼩决定的。接收⽅会把当前接收窗⼝的剩余⼤⼩写⼊应答报
⽂，发送端收到应答后根据该值和当前⽹络拥塞情况设置发送窗⼝的⼤⼩，所以发送窗⼝的
⼤⼩是不断变化的。
当发送端接收到应答报⽂后，会随之将窗⼝进⾏滑动
滑动窗⼝实现了流量控制。接收⽅通过报⽂告知发送⽅还可以发送多少数据，从⽽保证接收
⽅能够来得及接收数据。
Zero 窗⼝
在发送报⽂的过程中，可能会遇到对端出现零窗⼝的情况。在该情况下，发送端会停⽌发送
数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗⼝⼤⼩。在
重试次数超过⼀定次数后，可能会中断 TCP 链接。
拥塞处理
拥塞处理和流量控制不同，后者是作⽤于接收⽅，保证接收⽅来得及接受数据。⽽前者是作
⽤于⽹络，防⽌过多的数据拥塞⽹络，避免出现⽹络负载过⼤的情况。
拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。
慢开始算法
慢开始算法，顾名思义，就是在传输开始时将发送窗⼝慢慢指数级扩⼤，从⽽避免⼀开始就
传输⼤量数据导致⽹络拥塞。
慢开始算法步骤具体如下
1. 连接初始设置拥塞窗⼝（Congestion Window） 为 1 MSS（⼀个分段的最⼤数据量）
2. 每过⼀个 RTT 就将窗⼝⼤⼩乘⼆
3. 指数级增⻓肯定不能没有限制的，所以有⼀个阈值限制，当窗⼝⼤⼩⼤于阈值时就会启动
拥塞避免算法。
拥塞避免算法
拥塞避免算法相⽐简单点，每过⼀个 RTT 窗⼝⼤⼩只加⼀，这样能够避免指数级增⻓导致⽹
络拥塞，慢慢将⼤⼩调整到最佳值。
在传输过程中可能定时器超时的情况，这时候 TCP 会认为⽹络拥塞了，会⻢上进⾏以下步
骤：
将阈值设为当前拥塞窗⼝的⼀半
将拥塞窗⼝设为 1 MSS
启动拥塞避免算法
快速重传
快速重传⼀般和快恢复⼀起出现。⼀旦接收端收到的报⽂出现失序的情况，接收端只会回复
最后⼀个顺序正确的报⽂序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，⽆需等
待定时器超时再重发⽽是启动快速重传。具体算法分为两种：
TCP Taho 实现如下
将阈值设为当前拥塞窗⼝的⼀半
将拥塞窗⼝设为 1 MSS
重新开始慢开始算法
TCP Reno 实现如下
拥塞窗⼝减半
将阈值设为当前拥塞窗⼝
进⼊快恢复阶段（重发对端需要的包，⼀旦收到⼀个新的 ACK 答复就退出该阶段）
使⽤拥塞避免算法
TCP New Ren 改进后的快恢复
TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到⼀个新
的 ACK 包，就会退出快恢复。
在 TCP New Reno 中，TCP 发送⽅先记下三个重复 ACK 的分段的最⼤序号。
假如我有⼀个分段数据是 1 ~ 10 这⼗个序号的报⽂，其中丢失了序号为 3 和 7 的报⽂，那么
该分段的最⼤序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的
报⽂，接收⽅顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未
收到，会继续发送序号为 7 的报⽂，接收⽅顺利接收并会发送 ACK 序号为 11 的应答，这时
发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。
HTTP
HTTP 协议是个⽆状态协议，不会保存状态。
Post 和 Get 的区别
先引⼊副作⽤和幂等的概念。
副作⽤指对服务器上的资源做改变，搜索是⽆副作⽤的，注册是副作⽤的。
幂等指发送 M 和 N 次请求（两者不相同且都⼤于 1），服务器上资源的状态⼀致，⽐如注册
10 个和 11 个帐号是不幂等的，对⽂章进⾏更改 10 次和 11 次是幂等的。
在规范的应⽤场景上说，Get 多⽤于⽆副作⽤，幂等的场景，例如搜索关键字。Post 多⽤于
副作⽤，不幂等的场景，例如注册。
在技术上说：
Get 请求能缓存，Post 不能
Post 相对 Get 安全⼀点点，因为Get 请求都包含在 URL ⾥，且会被浏览器保存历史纪
录，Post 不会，但是在抓包的情况下都是⼀样的。
Post 可以通过 request body来传输⽐ Get 更多的数据，Get 没有这个技术
URL有⻓度限制，会影响 Get 请求，但是这个⻓度限制是浏览器规定的，不是 RFC 规定
的
Post ⽀持更多的编码类型且不对数据类型限制
常⻅状态码
2XX 成功
200 OK，表示从客户端发来的请求在服务器端被正确处理
204 No content，表示请求成功，但响应报⽂不含实体的主体部分
205 Reset Content，表示请求成功，但响应报⽂不含实体的主体部分，但是与 204 响应
不同在于要求请求⽅重置内容
206 Partial Content，进⾏范围请求
3XX 重定向
301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
302 found，临时性重定向，表示资源临时被分配了新的 URL
303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法获取资源
304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况
307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求⽅法不
变向新的地址发出请求
4XX 客户端错误
通⽤字段 作⽤
Cache-Control 控制缓存的⾏为
Connection 浏览器想要优先使⽤的连接类型，⽐如 keep-alive
Date 创建报⽂时间
Pragma 报⽂指令
Via 代理服务器相关信息
Transfer-Encoding 传输编码⽅式
Upgrade 要求客户端升级协议
Warning 在内容中可能存在错误
400 bad request，请求报⽂存在语法错误
401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
403 forbidden，表示对请求资源的访问被服务器拒绝
404 not found，表示在服务器上没有找到请求的资源
5XX 服务器错误
500 internal sever error，表示服务器端在执⾏请求时发⽣了错误
501 Not Implemented，表示服务器不⽀持当前请求所需要的某个功能
503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求
HTTP ⾸部
请求字段 作⽤
Accept 能正确接收的媒体类型
Accept-Charset 能正确接收的字符集
Accept-Encoding 能正确接收的编码格式列表
Accept-Language 能正确接收的语⾔列表
Expect 期待服务端的指定⾏为
From 请求⽅邮箱地址
Host 服务器的域名
If-Match 两端资源标记⽐较
If-Modified-Since 本地资源未修改返回 304（⽐较时间）
If-None-Match 本地资源未修改返回 304（⽐较标记）
User-Agent 客户端信息
Max-Forwards 限制可被代理及⽹关转发的次数
Proxy-Authorization 向代理服务器发送验证信息
Range 请求某个内容的⼀部分
Referer 表示浏览器所访问的前⼀个⻚⾯
TE 传输编码⽅式
响应字段 作⽤
Accept-Ranges 是否⽀持某些种类的范围
Age 资源在代理缓存中存在的时间
ETag 资源标识
Location 客户端重定向到某个 URL
Proxy-Authenticate 向代理服务器发送验证信息
Server 服务器名字
WWW-Authenticate 获取资源需要的验证信息
实体字段 作⽤
Allow 资源的正确请求⽅式
Content-Encoding 内容的编码格式
Content-Language 内容使⽤的语⾔
Content-Length request body ⻓度
Content-Location 返回数据的备⽤地址
Content-MD5 Base64加密格式的内容 MD5检验值
Content-Range 内容的位置范围
Content-Type 内容的媒体类型
Expires 内容的过期时间
Last_modified 内容的最后修改时间
PS：缓存相关已在别的模块中写完，你可以 阅读该⼩节
HTTPS
HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进⾏了加密。
TLS
TLS 协议位于传输层之上，应⽤层之下。⾸次进⾏ TLS 协议传输需要两个 RTT ，接下来可以
通过 Session Resumption 减少到⼀个 RTT。
在 TLS 中使⽤了两种加密技术，分别为：对称加密和⾮对称加密。
对称加密：
对称加密就是两边拥有相同的秘钥，两边都知道如何将密⽂加密解密。
⾮对称加密：
有公钥私钥之分，公钥所有⼈都可以知道，可以将数据⽤公钥加密，但是将数据解密必须使
⽤私钥解密，私钥只有分发公钥的⼀⽅才知道。
TLS 握⼿过程如下图：
1. 客户端发送⼀个随机值，需要的协议和加密⽅式
2. 服务端收到客户端的随机值，⾃⼰也产⽣⼀个随机值，并根据客户端需求的协议和加密⽅
式来使⽤对应的⽅式，发送⾃⼰的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，验证通过会再⽣成⼀个随机值，通过服务端证
书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带
证书
4. 服务端收到加密过的随机值并使⽤私钥解密获得第三个随机值，这时候两端都拥有了三个
随机值，可以通过这三个随机值按照之前约定的加密⽅式⽣成密钥，接下来的通信就可以
通过该密钥来加密解密
通过以上步骤可知，在 TLS 握⼿阶段，两端使⽤⾮对称加密的⽅式来通信，但是因为⾮对称
加密损耗的性能⽐对称加密⼤，所以在正式传输数据时，两端使⽤对称加密的⽅式通信。
PS：以上说明的都是 TLS 1.2 协议的握⼿情况，在 1.3 协议中，⾸次建⽴连接只需要⼀个
RTT，后⾯恢复连接不需要 RTT 了。
HTTP 2.0
HTTP 2.0 相⽐于 HTTP 1.X，可以说是⼤幅度提⾼了 web 的性能。
在 HTTP 1.X 中，为了性能考虑，我们会引⼊雪碧图、将⼩图内联、使⽤多个域名等等的⽅
式。这⼀切都是因为浏览器限制了同⼀个域名下的请求数量，当⻚⾯中需要请求很多资源的
时候，队头阻塞（Head of line blocking）会导致在达到最⼤请求数量时，剩余的资源需要等
待其他资源请求完成后才能发起请求。
你可以通过 该链接 感受下 HTTP 2.0 ⽐ HTTP 1.X 到底快了多少。
在 HTTP 1.X 中，因为队头阻塞的原因，你会发现请求是这样的
在 HTTP 2.0 中，因为引⼊了多路复⽤，你会发现请求是这样的
⼆进制传输
HTTP 2.0 中所有加强性能的核⼼点在于此。在之前的 HTTP 版本中，我们是通过⽂本的⽅式
传输数据。在 HTTP 2.0 中引⼊了新的编码机制，所有传输的数据都会被分割，并采⽤⼆进制
格式编码。
多路复⽤
在 HTTP 2.0 中，有两个⾮常重要的概念，分别是帧（frame）和流（stream）。
帧代表着最⼩的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据
流。
多路复⽤，就是在⼀个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，
对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队
头阻塞问题，极⼤的提⾼传输性能。
Header 压缩
在 HTTP 1.X 中，我们使⽤⽂本的形式传输 header，在 header 携带 cookie 的情况下，可能
每次都需要重复传输⼏百到⼏千的字节。
在 HTTP 2.0 中，使⽤了 HPACK 压缩格式对传输的 header 进⾏编码，减少了 header 的⼤
⼩。并在两端维护了索引表，⽤于记录出现过的 header ，后⾯在传输过程中就可以传输已经
记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
服务端 Push
在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。
可以想象以下情况，某些资源客户端是⼀定会请求的，这时就可以采取服务端 push 的技术，
提前给客户端推送必要的资源，这样就可以相对减少⼀点延迟时间。当然在浏览器兼容的情
况下你也可以使⽤ prefetch 。
QUIC
这是⼀个⾕歌出品的基于 UDP 实现的同为传输层的协议，⽬标很远⼤，希望替代 TCP 协
议。
该协议⽀持多路复⽤，虽然 HTTP 2.0 也⽀持多路复⽤，但是下层仍是 TCP，因为 TCP
的重传机制，只要⼀个包丢失就得判断丢失包并且重传，导致发⽣队头阻塞的问题，但是
UDP 没有这个机制
实现了⾃⼰的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已
经实现了 0-RTT 了
⽀持重传和纠错机制（向前恢复），在只丢失⼀个包的情况下不需要重传，使⽤纠错机制
恢复丢失的包
纠错机制：通过异或的⽅式，算出发出去的数据的异或值并单独发出⼀个包，服务端
在发现有⼀个包丢失的情况下，通过其他数据包和异或值包算出丢失包
在丢失两个包或以上的情况就使⽤重传机制，因为算不出来了
DNS
DNS 的作⽤就是通过域名查询到具体的 IP。
因为 IP 存在数字和英⽂的组合（IPv6），很不利于⼈类记忆，所以就出现了域名。你可以把
域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。
在 TCP 握⼿之前就已经进⾏了 DNS 查询，这个查询是操作系统⾃⼰做的。当你在浏览器中
想访问 www.google.com 时，会进⾏⼀下操作：
1. 操作系统会⾸先在本地缓存中查询
2. 没有的话会去系统配置的 DNS 服务器中查询
3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这⼀步查询会找出负责 com 这个
⼀级域名的服务器
4. 然后去该服务器查询 google 这个⼆级域名
5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置⼀个 IP，然后还
可以给别的三级域名配置⼀个 IP
以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者
是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。
PS：DNS 是基于 UDP 做的查询。
从输⼊ URL 到⻚⾯加载完成的过程
这是⼀个很经典的⾯试题，在这题中可以将本⽂讲得内容都串联起来。
1. ⾸先做 DNS 查询，如果这⼀步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址
回来
2. 接下来是 TCP 握⼿，应⽤层会下发数据给传输层，这⾥ TCP 协议会指明两端的端⼝号，
然后下发给⽹络层。⽹络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转
路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层⾯的传输了
3. TCP 握⼿结束后会进⾏ TLS 握⼿，然后就开始正式的传输数据
4. 数据在进⼊服务端之前，可能还会先经过负责负载均衡的服务器，它的作⽤就是将请求合
理的分发到多台服务器上，这时假设服务端会响应⼀个 HTML ⽂件
5. ⾸先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会
报错，如果 300 的话会进⾏重定向，这⾥会有个重定向计数器，避免过多次的重定向，
超过次数也会报错
6. 浏览器开始解析⽂件，如果是 gzip 格式的话会先解压⼀下，然后通过⽂件的编码格式知
道该如何去解码⽂件
7. ⽂件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去
构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer
，前者会并⾏进⾏下载并执⾏ JS，后者会先下载⽂件，然后等待 HTML 解析完成后顺序
执⾏，如果以上都没有，就会阻塞住渲染流程直到 JS 执⾏完毕。遇到⽂件下载的会去下
载⽂件，这⾥如果使⽤ HTTP 2.0 协议的话会极⼤的提⾼多图的下载效率。
8. 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件
9. CSSOM 树和 DOM 树构建完成后会开始⽣成 Render 树，这⼀步就是确定⻚⾯元素的布
局、样式等等诸多⽅⾯的东⻄
10. 在⽣成 Render 树的过程中，浏览器就开始调⽤ GPU 绘制，合成图层，将内容显示在屏
幕上了
数据结构章节
栈
概念
栈是⼀个线性结构，在计算机中是⼀个相当常⻅的数据结构。
栈的特点是只能在某⼀端添加或删除数据，遵循先进后出的原则
实现
每种数据结构都可以⽤很多种⽅式来实现，其实可以把栈看成是数组的⼀个⼦集，所以这⾥
使⽤数组来实现
class Stack {
 constructor() {
 this.stack = []
 }
 push(item) {
 this.stack.push(item)
 }
 pop() {
 this.stack.pop()
 }
 peek() {
 return this.stack[this.getCount() - 1]
应⽤
选取了 LeetCode 上序号为 20 的题⽬
题意是匹配括号，可以通过栈的特性来完成这道题⽬
 }
 getCount() {
 return this.stack.length
 }
 isEmpty() {
 return this.getCount() === 0
 }
}
var isValid = function (s) {
 let map = {
 '(': -1,
 ')': 1,
 '[': -2,
 ']': 2,
 '{': -3,
 '}': 3
 }
 let stack = []
 for (let i = 0; i < s.length; i++) {
 if (map[s[i]] < 0) {
 stack.push(s[i])
 } else {
 let last = stack.pop()
 if (map[last] + map[s[i]] != 0) return false
 }
 }
 if (stack.length > 0) return false
 return true
队列
概念
队列⼀个线性结构，特点是在某⼀端添加数据，在另⼀端删除数据，遵循先进先出的原则。
实现
这⾥会讲解两种实现队列的⽅式，分别是单链队列和循环队列。
单链队列
};
class Queue {
 constructor() {
 this.queue = []
 }
 enQueue(item) {
因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引⼊了循环队列。循环队列的
出队操作平均是 O(1) 的时间复杂度。
循环队列
 this.queue.push(item)
 }
 deQueue() {
 return this.queue.shift()
 }
 getHeader() {
 return this.queue[0]
 }
 getLength() {
 return this.queue.length
 }
 isEmpty() {
 return this.getLength() === 0
 }
}
class SqQueue {
 constructor(length) {
 this.queue = new Array(length + 1)
 // 队头
 this.first = 0
 // 队尾
 this.last = 0
 // 当前队列⼤⼩
 this.size = 0
 }
 enQueue(item) {
 // 判断队尾 + 1 是否为队头
 // 如果是就代表需要扩容数组
 // % this.queue.length 是为了防⽌数组越界
 if (this.first === (this.last + 1) % this.queue.length) {
 this.resize(this.getLength() * 2 + 1)
 }
 this.queue[this.last] = item
 this.size++
 this.last = (this.last + 1) % this.queue.length
 }
 deQueue() {
 if (this.isEmpty()) {
 throw Error('Queue is empty')
 }
 let r = this.queue[this.first]
 this.queue[this.first] = null
 this.first = (this.first + 1) % this.queue.length
 this.size--
 // 判断当前队列⼤⼩是否过⼩
 // 为了保证不浪费空间，在队列空间等于总⻓度四分之⼀时
 // 且不为 2 时缩⼩总⻓度为当前的⼀半
 if (this.size === this.getLength() / 4 && this.getLength() / 2 !==
0) {
 this.resize(this.getLength() / 2)
 }
 return r
 }
 getHeader() {
 if (this.isEmpty()) {
 throw Error('Queue is empty')
 }
 return this.queue[this.first]
 }
 getLength() {
 return this.queue.length - 1
 }
 isEmpty() {
 return this.first === this.last
 }
链表
概念
链表是⼀个线性结构，同时也是⼀个天然的递归结构。链表结构可以充分利⽤计算机内存空
间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了
结点的指针域，空间开销⽐较⼤。
实现
单向链表
 resize(length) {
 let q = new Array(length)
 for (let i = 0; i < length; i++) {
 q[i] = this.queue[(i + this.first) % this.queue.length]
 }
 this.queue = q
 this.first = 0
 this.last = this.size
 }
}
class Node {
 constructor(v, next) {
 this.value = v
 this.next = next
 }
}
class LinkList {
 constructor() {
 // 链表⻓度
 this.size = 0
 // 虚拟头部
 this.dummyNode = new Node(null, null)
 }
 find(header, index, currentIndex) {
 if (index === currentIndex) return header
 return this.find(header.next, index, currentIndex + 1)
 }
 addNode(v, index) {
 this.checkIndex(index)
 // 当往链表末尾插⼊时，prev.next 为空
 // 其他情况时，因为要插⼊节点，所以插⼊的节点
 // 的 next 应该是 prev.next
 // 然后设置 prev.next 为插⼊的节点
 let prev = this.find(this.dummyNode, index, 0)
 prev.next = new Node(v, prev.next)
 this.size++
 return prev.next
 }
 insertNode(v, index) {
 return this.addNode(v, index)
 }
 addToFirst(v) {
 return this.addNode(v, 0)
 }
 addToLast(v) {
 return this.addNode(v, this.size)
 }
 removeNode(index, isLast) {
 this.checkIndex(index)
 index = isLast ? index - 1 : index
 let prev = this.find(this.dummyNode, index, 0)
 let node = prev.next
 prev.next = node.next
树
⼆叉树
树拥有很多种结构，⼆叉树是树中最常⽤的结构，同时也是⼀个天然的递归结构。
⼆叉树拥有⼀个根节点，每个节点⾄多拥有两个⼦节点，分别为：左节点和右节点。树的最
底部节点称之为叶节点，当⼀颗树的叶数量数量为满时，该树可以称之为满⼆叉树。
 node.next = null
 this.size--
 return node
 }
 removeFirstNode() {
 return this.removeNode(0)
 }
 removeLastNode() {
 return this.removeNode(this.size, true)
 }
 checkIndex(index) {
 if (index < 0 || index > this.size) throw Error('Index error')
 }
 getNode(index) {
 this.checkIndex(index)
 if (this.isEmpty()) return
 return this.find(this.dummyNode, index, 0).next
 }
 isEmpty() {
 return this.size === 0
 }
 getSize() {
 return this.size
 }
}
⼆分搜索树
⼆分搜索树也是⼆叉树，拥有⼆叉树的特性。但是区别在于⼆分搜索树每个节点的值都⽐他
的左⼦树的值⼤，⽐右⼦树的值⼩。
这种存储⽅式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值⽐
根节点的值⼤，所以只需要在根节点的右⼦树上寻找，⼤⼤提⾼了搜索效率。
实现
class Node {
 constructor(value) {
 this.value = value
 this.left = null
 this.right = null
 }
}
class BST {
 constructor() {
 this.root = null
 this.size = 0
 }
 getSize() {
 return this.size
以上是最基本的⼆分搜索树实现，接下来实现树的遍历。
对于树的遍历来说，有三种遍历⽅法，分别是先序遍历、中序遍历、后序遍历。三种遍历的
区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到⾃⼰，
遍历左⼦树和遍历右⼦树。如果需要实现先序遍历，那么只需要第⼀次遍历到节点时进⾏操
作即可。
以下都是递归实现，如果你想学习⾮递归实现，可以 点击这⾥阅读
 }
 isEmpty() {
 return this.size === 0
 }
 addNode(v) {
 this.root = this._addChild(this.root, v)
 }
 // 添加节点时，需要⽐较添加的节点值和当前
 // 节点值的⼤⼩
 _addChild(node, v) {
 if (!node) {
 this.size++
 return new Node(v)
 }
 if (node.value > v) {
 node.left = this._addChild(node.left, v)
 } else if (node.value < v) {
 node.right = this._addChild(node.right, v)
 }
 return node
 }
}
// 先序遍历可⽤于打印树的结构
// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。
preTraversal() {
 this._pre(this.root)
}
_pre(node) {
 if (node) {
 console.log(node.value)
 this._pre(node.left)
 this._pre(node.right)
 }
}
// 中序遍历可⽤于排序
// 对于 BST 来说，中序遍历可以实现⼀次遍历就
// 得到有序的值
// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。
midTraversal() {
 this._mid(this.root)
}
_mid(node) {
 if (node) {
 this._mid(node.left)
 console.log(node.value)
 this._mid(node.right)
 }
}
// 后序遍历可⽤于先操作⼦节点
// 再操作⽗节点的场景
// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。
backTraversal() {
 this._back(this.root)
}
_back(node) {
 if (node) {
 this._back(node.left)
 this._back(node.right)
 console.log(node.value)
 }
}
以上的这⼏种遍历都可以称之为深度遍历，对应的还有种遍历叫做⼴度遍历，也就是⼀层层
地遍历树。对于⼴度遍历来说，我们需要利⽤之前讲过的队列结构来完成。
接下来先介绍如何在树中寻找最⼩值或最⼤数。因为⼆分搜索树的特性，所以最⼩值⼀定在
根节点的最左边，最⼤值相反
breadthTraversal() {
 if (!this.root) return null
 let q = new Queue()
 // 将根节点⼊队
 q.enQueue(this.root)
 // 循环判断队列是否为空，为空
 // 代表树遍历完毕
 while (!q.isEmpty()) {
 // 将队⾸出队，判断是否有左右⼦树
 // 有的话，就先左后右⼊队
 let n = q.deQueue()
 console.log(n.value)
 if (n.left) q.enQueue(n.left)
 if (n.right) q.enQueue(n.right)
 }
}
getMin() {
 return this._getMin(this.root).value
}
_getMin(node) {
 if (!node.left) return node
 return this._getMin(node.left)
}
getMax() {
 return this._getMax(this.root).value
}
_getMax(node) {
向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这⾥只介绍如何向下取
整。既然是向下取整，那么根据⼆分搜索树的特性，值⼀定在根节点的左侧。只需要⼀直遍
历左⼦树直到当前节点的值不再⼤于等于需要的值，然后判断节点是否还拥有右⼦树。如果
有的话，继续上⾯的递归判断。
排名，这是⽤于获取给定值的排名或者排名第⼏的节点的值，这两个操作也是相反的，所以
这个只介绍如何获取排名第⼏的节点的值。对于这个操作⽽⾔，我们需要略微的改造点代
码，让每个节点拥有⼀个 size 属性。该属性表示该节点下有多少⼦节点（包含⾃身）。
 if (!node.right) return node
 return this._getMin(node.right)
}
floor(v) {
 let node = this._floor(this.root, v)
 return node ? node.value : null
}
_floor(node, v) {
 if (!node) return null
 if (node.value === v) return v
 // 如果当前节点值还⽐需要的值⼤，就继续递归
 if (node.value > v) {
 return this._floor(node.left, v)
 }
 // 判断当前节点是否拥有右⼦树
 let right = this._floor(node.right, v)
 if (right) return right
 return node
}
class Node {
 constructor(value) {
 this.value = value
 this.left = null
 this.right = null
 // 修改代码
 this.size = 1
 }
}
// 新增代码
_getSize(node) {
 return node ? node.size : 0
}
_addChild(node, v) {
 if (!node) {
 return new Node(v)
 }
 if (node.value > v) {
 // 修改代码
 node.size++
 node.left = this._addChild(node.left, v)
 } else if (node.value < v) {
 // 修改代码
 node.size++
 node.right = this._addChild(node.right, v)
 }
 return node
}
select(k) {
 let node = this._select(this.root, k)
 return node ? node.value : null
}
_select(node, k) {
 if (!node) return null
 // 先获取左⼦树下有⼏个节点
 let size = node.left ? node.left.size : 0
 // 判断 size 是否⼤于 k
 // 如果⼤于 k，代表所需要的节点在左节点
 if (size > k) return this._select(node.left, k)
 // 如果⼩于 k，代表所需要的节点在右节点
 // 注意这⾥需要重新计算 k，减去根节点除了右⼦树的节点数量
接下来讲解的是⼆分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在
以下⼏种情况
需要删除的节点没有⼦树
需要删除的节点只有⼀条⼦树
需要删除的节点有左右两条树
对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删
除最⼩节点，对于删除最⼩节点来说，是不存在第三种情况的，删除最⼤节点操作是和删除
最⼩节点相反的，所以这⾥也就不再赘述。
最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个
难题的办法，也就是如何解决第三种情况。
 if (size < k) return this._select(node.right, k - size - 1)
 return node
}
delectMin() {
 this.root = this._delectMin(this.root)
 console.log(this.root)
}
_delectMin(node) {
 // ⼀直递归左⼦树
 // 如果左⼦树为空，就判断节点是否拥有右⼦树
 // 有右⼦树的话就把需要删除的节点替换为右⼦树
 if ((node != null) & !node.left) return node.right
 node.left = this._delectMin(node.left)
 // 最后需要重新维护下节点的 `size`
 node.size = this._getSize(node.left) + this._getSize(node.right) + 1
 return node
}
当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右⼦树的最⼩节点）来
替换需要删除的节点。然后将需要删除节点的左⼦树赋值给后继结点，右⼦树删除后继结点
后赋值给他。
你如果对于这个解决办法有疑问的话，可以这样考虑。因为⼆分搜索树的特性，⽗节点⼀定
⽐所有左⼦节点⼤，⽐所有右⼦节点⼩。那么当需要删除⽗节点时，势必需要拿出⼀个⽐⽗
节点⼤的节点来替换⽗节点。这个节点肯定不存在于左⼦树，必然存在于右⼦树。然后⼜需
要保持⽗节点都是⽐右⼦节点⼩的，那么就可以取出右⼦树中最⼩的那个节点来替换⽗节
点。
delect(v) {
 this.root = this._delect(this.root, v)
}
_delect(node, v) {
 if (!node) return null
 // 寻找的节点⽐当前节点⼩，去左⼦树找
 if (node.value < v) {
 node.right = this._delect(node.right, v)
 } else if (node.value > v) {
 // 寻找的节点⽐当前节点⼤，去右⼦树找
 node.left = this._delect(node.left, v)
 } else {
 // 进⼊这个条件说明已经找到节点
 // 先判断节点是否拥有拥有左右⼦树中的⼀个
 // 是的话，将⼦树返回出去，这⾥和 `_delectMin` 的操作⼀样
 if (!node.left) return node.right
 if (!node.right) return node.left
 // 进⼊这⾥，代表节点拥有左右⼦树
 // 先取出当前节点的后继结点，也就是取当前节点右⼦树的最⼩值
 let min = this._getMin(node.right)
 // 取出最⼩值后，删除最⼩值
 // 然后把删除节点后的⼦树赋值给最⼩值节点
 min.right = this._delectMin(node.right)
 // 左⼦树不动
 min.left = node.left
AVL 树
概念
⼆分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成
链表，⽐如加⼊⼀组升序的数字就会造成这种情况。
AVL 树改进了⼆分搜索树，在 AVL 树中任意节点的左右⼦树的⾼度差都不⼤于 1，这样保证
了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达
到⾼度的平衡。
实现
因为 AVL 树是改进了⼆分搜索树，所以部分代码是于⼆分搜索树重复的，对于重复内容不作
再次解析。
对于 AVL 树来说，添加节点会有四种情况
 node = min
 }
 // 维护 size
 node.size = this._getSize(node.left) + this._getSize(node.right) + 1
 return node
}
对于左左情况来说，新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为
搜索树的特性，节点⽐左节点⼤，⽐右节点⼩，所以旋转以后也要实现这个特性。
旋转之前：new < 2 < C < 3 < B < 5 < A，右旋之后节点 3 为根节点，这时候需要将节点 3 的
右节点加到节点 5 的左边，最后还需要更新节点的⾼度。
对于右右情况来说，相反于左左情况，所以不再赘述。
对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来
达到⽬的。
⾸先对节点的左节点左旋，这时树满⾜左左的情况，再对节点进⾏⼀次右旋就可以达到⽬
的。
class Node {
 constructor(value) {
 this.value = value
 this.left = null
 this.right = null
 this.height = 1
 }
}
class AVL {
 constructor() {
 this.root = null
 }
 addNode(v) {
 this.root = this._addChild(this.root, v)
 }
 _addChild(node, v) {
 if (!node) {
 return new Node(v)
 }
 if (node.value > v) {
 node.left = this._addChild(node.left, v)
 } else if (node.value < v) {
 node.right = this._addChild(node.right, v)
 } else {
 node.value = v
 }
 node.height =
 1 + Math.max(this._getHeight(node.left),
this._getHeight(node.right))
 let factor = this._getBalanceFactor(node)
 // 当需要右旋时，根节点的左树⼀定⽐右树⾼度⾼
 if (factor > 1 && this._getBalanceFactor(node.left) >= 0) {
 return this._rightRotate(node)
 }
 // 当需要左旋时，根节点的左树⼀定⽐右树⾼度矮
 if (factor < -1 && this._getBalanceFactor(node.right) <= 0) {
 return this._leftRotate(node)
 }
 // 左右情况
 // 节点的左树⽐右树⾼，且节点的左树的右树⽐节点的左树的左树⾼
 if (factor > 1 && this._getBalanceFactor(node.left) < 0) {
 node.left = this._leftRotate(node.left)
 return this._rightRotate(node)
 }
 // 右左情况
 // 节点的左树⽐右树矮，且节点的右树的右树⽐节点的右树的左树矮
 if (factor < -1 && this._getBalanceFactor(node.right) > 0) {
 node.right = this._rightRotate(node.right)
 return this._leftRotate(node)
 }
 return node
 }
 _getHeight(node) {
 if (!node) return 0
 return node.height
 }
 _getBalanceFactor(node) {
 return this._getHeight(node.left) - this._getHeight(node.right)
 }
 // 节点右旋
 // 5 2
 // / \ / \
 // 2 6 ==> 1 5
 // / \ / / \
 // 1 3 new 3 6
 // /
 // new
 _rightRotate(node) {
 // 旋转后新根节点
 let newRoot = node.left
 // 需要移动的节点
 let moveNode = newRoot.right
 // 节点 2 的右节点改为节点 5
 newRoot.right = node
 // 节点 5 左节点改为节点 3
 node.left = moveNode
 // 更新树的⾼度
 node.height =
 1 + Math.max(this._getHeight(node.left),
this._getHeight(node.right))
 newRoot.height =
 1 +
 Math.max(this._getHeight(newRoot.left),
this._getHeight(newRoot.right))
 return newRoot
 }
 // 节点左旋
 // 4 6
 // / \ / \
 // 2 6 ==> 4 7
 // / \ / \ \
 // 5 7 2 5 new
 // \
 // new
 _leftRotate(node) {
 // 旋转后新根节点
 let newRoot = node.right
 // 需要移动的节点
 let moveNode = newRoot.left
 // 节点 6 的左节点改为节点 4
 newRoot.left = node
 // 节点 4 右节点改为节点 5
 node.right = moveNode
 // 更新树的⾼度
 node.height =
 1 + Math.max(this._getHeight(node.left),
this._getHeight(node.right))
 newRoot.height =
Trie
概念
在计算机科学，trie，⼜称前缀树或字典树，是⼀种有序树，⽤于保存关联数组，其中的键通
常是字符串。
简单点来说，这个结构的作⽤⼤多是为了⽅便搜索字符串，该树有以下⼏个特点
根节点代表空字符串，每个节点都有 N（假如搜索英⽂字符，就有 26 条） 条链接，每条
链接代表⼀个字符
节点不存储字符，只有路径才存储，这点和其他的树结构不同
从根节点开始到任意⼀个节点，将沿途经过的字符连接起来就是该节点对应的字符串
 1 +
 Math.max(this._getHeight(newRoot.left),
this._getHeight(newRoot.right))
 return newRoot
 }
}
、
实现
总得来说 Trie 的实现相⽐别的树结构来说简单的很多，实现就以搜索英⽂字符为例。
class TrieNode {
 constructor() {
 // 代表每个字符经过节点的次数
 this.path = 0
 // 代表到该节点的字符串有⼏个
 this.end = 0
 // 链接
 this.next = new Array(26).fill(null)
 }
}
class Trie {
 constructor() {
 // 根节点，代表空字符
 this.root = new TrieNode()
 }
 // 插⼊字符串
 insert(str) {
 if (!str) return
 let node = this.root
 for (let i = 0; i < str.length; i++) {
 // 获得字符先对应的索引
 let index = str[i].charCodeAt() - 'a'.charCodeAt()
 // 如果索引对应没有值，就创建
 if (!node.next[index]) {
 node.next[index] = new TrieNode()
 }
 node.path += 1
 node = node.next[index]
 }
 node.end += 1
 }
 // 搜索字符串出现的次数
 search(str) {
 if (!str) return
 let node = this.root
 for (let i = 0; i < str.length; i++) {
 let index = str[i].charCodeAt() - 'a'.charCodeAt()
 // 如果索引对应没有值，代表没有需要搜素的字符串
 if (!node.next[index]) {
 return 0
 }
 node = node.next[index]
并查集
概念
并查集是⼀种特殊的树结构，⽤于处理⼀些不交集的合并及查询问题。该结构中每个节点都
有⼀个⽗节点，如果只有当前⼀个节点，那么该节点的⽗节点指向⾃⼰。
这个结构中有两个重要的操作，分别是：
Find：确定元素属于哪⼀个⼦集。它可以被⽤来确定两个元素是否属于同⼀⼦集。
Union：将两个⼦集合并成同⼀个集合。
 }
 return node.end
 }
 // 删除字符串
 delete(str) {
 if (!this.search(str)) return
 let node = this.root
 for (let i = 0; i < str.length; i++) {
 let index = str[i].charCodeAt() - 'a'.charCodeAt()
 // 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串
 // 已经⼀个，直接删除即可
 if (--node.next[index].path == 0) {
 node.next[index] = null
 return
 }
 node = node.next[index]
 }
 node.end -= 1
 }
}
实现
class DisjointSet {
 // 初始化样本
 constructor(count) {
 // 初始化时，每个节点的⽗节点都是⾃⼰
 this.parent = new Array(count)
 // ⽤于记录树的深度，优化搜索复杂度
 this.rank = new Array(count)
 for (let i = 0; i < count; i++) {
 this.parent[i] = i
 this.rank[i] = 1
 }
 }
 find(p) {
 // 寻找当前节点的⽗节点是否为⾃⼰，不是的话表示还没找到
 // 开始进⾏路径压缩优化
 // 假设当前节点⽗节点为 A
 // 将当前节点挂载到 A 节点的⽗节点上，达到压缩深度的⽬的
 while (p != this.parent[p]) {
 this.parent[p] = this.parent[this.parent[p]]
 p = this.parent[p]
 }
 return p
 }
 isConnected(p, q) {
堆
概念
堆通常是⼀个可以被看做⼀棵树的数组对象。
堆的实现通过构造⼆叉堆，实为⼆叉树的⼀种。这种数据结构具有以下性质。
任意节点⼩于（或⼤于）它的所有⼦节点
堆总是⼀棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填
⼊。
将根节点最⼤的堆叫做最⼤堆或⼤根堆，根节点最⼩的堆叫做最⼩堆或⼩根堆。
优先队列也完全可以⽤堆来实现，操作是⼀模⼀样的。
 return this.find(p) === this.find(q)
 }
 // 合并
 union(p, q) {
 // 找到两个数字的⽗节点
 let i = this.find(p)
 let j = this.find(q)
 if (i === j) return
 // 判断两棵树的深度，深度⼩的加到深度⼤的树下⾯
 // 如果两棵树深度相等，那就⽆所谓怎么加
 if (this.rank[i] < this.rank[j]) {
 this.parent[i] = j
 } else if (this.rank[i] > this.rank[j]) {
 this.parent[j] = i
 } else {
 this.parent[i] = j
 this.rank[j] += 1
 }
 }
}
实现⼤根堆
堆的每个节点的左边⼦节点索引是 i * 2 + 1 ，右边是 i * 2 + 2 ，⽗节点是 (i - 1)
/2 。
堆有两个核⼼的操作，分别是 shiftUp 和 shiftDown 。前者⽤于添加元素，后者⽤于删除
根节点。
shiftUp 的核⼼思路是⼀路将节点与⽗节点对⽐⼤⼩，如果⽐⽗节点⼤，就和⽗节点交换位
置。
shiftDown 的核⼼思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断
⽗节点和两个⼦节点的⼤⼩，如果⼦节点⼤，就把最⼤的⼦节点和⽗节点交换。
class MaxHeap {
 constructor() {
 this.heap = []
 }
 size() {
 return this.heap.length
 }
 empty() {
 return this.size() == 0
 }
 add(item) {
 this.heap.push(item)
 this._shiftUp(this.size() - 1)
 }
 removeMax() {
 this._shiftDown(0)
 }
 getParentIndex(k) {
 return parseInt((k - 1) / 2)
 }
 getLeftIndex(k) {
 return k * 2 + 1
 }
 _shiftUp(k) {
 // 如果当前节点⽐⽗节点⼤，就交换
 while (this.heap[k] > this.heap[this.getParentIndex(k)]) {
 this._swap(k, this.getParentIndex(k))
 // 将索引变成⽗节点
 k = this.getParentIndex(k)
 }
 }
 _shiftDown(k) {
 // 交换⾸位并删除末尾
 this._swap(k, this.size() - 1)
 this.heap.splice(this.size() - 1, 1)
 // 判断节点是否有左孩⼦，因为⼆叉堆的特性，有右必有左
 while (this.getLeftIndex(k) < this.size()) {
 let j = this.getLeftIndex(k)
 // 判断是否有右孩⼦，并且右孩⼦是否⼤于左孩⼦
 if (j + 1 < this.size() && this.heap[j + 1] > this.heap[j]) j++
 // 判断⽗节点是否已经⽐⼦节点都⼤
算法章节
时间复杂度
通常使⽤最差的时间复杂度来衡量⼀个算法的好坏。
常数时间 O(1) 代表这个操作和数据量没关系，是⼀个固定时间的操作，⽐如说四则运算。
对于⼀个算法来说，可能会计算出如下操作次数 aN + 1 ， N 代表数据量。那么该算法的时
间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是⾮常⼤的，这时候低
阶项和常数项可以忽略不计。
当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对⽐两个算法的好坏就要通过对⽐低
阶项和常数项了。
位运算
位运算在算法中很有⽤，速度可以⽐四则运算快很多。
在学习位运算之前应该知道⼗进制如何转⼆进制，⼆进制如何转⼗进制。这⾥说明下简单的
计算⽅式
 if (this.heap[k] >= this.heap[j]) break
 this._swap(k, j)
 k = j
 }
 }
 _swap(left, right) {
 let rightValue = this.heap[right]
 this.heap[right] = this.heap[left]
 this.heap[left] = rightValue
 }
}
⼗进制 33 可以看成是 32 + 1 ，并且 33 应该是六位⼆进制的（因为 33 近似 32 ，
⽽ 32 是 2 的五次⽅，所以是六位），那么 ⼗进制 33 就是 100001 ，只要是 2 的次
⽅，那么就是 1否则都为 0
那么⼆进制 100001 同理，⾸位是 2^5 ，末位是 2^0 ，相加得出 33
左移 <<
左移就是将⼆进制全部往左移动， 10 在⼆进制中表示为 1010 ，左移⼀位后变成 10100
，转换为⼗进制也就是 20，所以基本可以把左移看成以下公式 a * (2 ^ b)
算数右移 >>
算数右移就是将⼆进制全部往右移动并去除多余的右边， 10 在⼆进制中表示为 1010 ，右
移⼀位后变成 101 ，转换为⼗进制也就是 5，所以基本可以把右移看成以下公式 int v =
a / (2 ^ b)
右移很好⽤，⽐如可以⽤在⼆分算法中取中间值
按位操作
按位与
每⼀位都为 1，结果才为 1
按位或
10 << 1 // -> 20
10 >> 1 // -> 5
13 >> 1 // -> 6
8 & 7 // -> 0
// 1000 & 0111 -> 0000 -> 0
其中⼀位为 1，结果就是 1
按位异或
每⼀位都不同，结果才为 1
从以上代码中可以发现按位异或就是不进位加法
⾯试题：两个数不使⽤四则运算得出和
这道题中可以按位异或，因为按位异或就是不进位加法， 8 ^ 8 = 0 如果进位了，就是 16
了，所以我们只需要将两个数进⾏异或操作，然后进位。那么也就是说两个⼆进制都是 1 的
位置，左边应该有⼀个进位 1，所以可以得出以下公式 a + b = (a ^ b) + ((a & b) <<
1) ，然后通过迭代的⽅式模拟加法
8 | 7 // -> 15
// 1000 | 0111 -> 1111 -> 15
8 ^ 7 // -> 15
8 ^ 8 // -> 0
// 1000 ^ 0111 -> 1111 -> 15
// 1000 ^ 1000 -> 0000 -> 0
function sum(a, b) {
 if (a == 0) return b
 if (b == 0) return a
 let newA = a ^ b
 let newB = (a & b) << 1
 return sum(newA, newB)
}
排序
以下两个函数是排序中会⽤到的通⽤函数，就不⼀⼀写了
冒泡排序
冒泡排序的原理如下，从第⼀个元素开始，把当前元素和下⼀个索引元素进⾏⽐较。如果当
前元素⼤，那么就交换位置，重复操作直到⽐较到最后⼀个元素，那么此时最后⼀个元素就
是该数组中最⼤的数。下⼀轮重复以上操作，但是此时最后⼀个元素已经是最⼤数了，所以
不需要再⽐较最后⼀个元素，只需要⽐较到 length - 1 的位置。
以下是实现该算法的代码
function checkArray(array) {
 if (!array || array.length <= 2) return
}
function swap(array, left, right) {
 let rightValue = array[right]
 array[right] = array[left]
 array[left] = rightValue
}
该算法的操作次数是⼀个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时
间复杂度是 O(n * n)
插⼊排序
插⼊排序的原理如下。第⼀个元素默认是已排序元素，取出下⼀个元素和当前元素⽐较，如
果当前元素⼤就交换位置。那么此时第⼀个元素就是当前的最⼩数，所以下次取出操作从第
三个元素开始，向前对⽐，重复之前的操作。
以下是实现该算法的代码
function bubble(array) {
 checkArray(array);
 for (let i = array.length - 1; i > 0; i--) {
 // 从 0 到 `length - 1` 遍历
 for (let j = 0; j < i; j++) {
 if (array[j] > array[j + 1]) swap(array, j, j + 1)
 }
 }
 return array;
}
该算法的操作次数是⼀个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时
间复杂度是 O(n * n)
选择排序
选择排序的原理如下。遍历数组，设置最⼩值的索引为 0，如果取出的值⽐当前最⼩值⼩，就
替换最⼩值索引，遍历完成后，将第⼀个元素和最⼩值索引上的值交换。如上操作后，第⼀
个元素就是数组中的最⼩值，下次遍历就可以从索引 1 开始重复上述操作。
以下是实现该算法的代码
function insertion(array) {
 checkArray(array);
 for (let i = 1; i < array.length; i++) {
 for (let j = i - 1; j >= 0 && array[j] > array[j + 1]; j--)
 swap(array, j, j + 1);
 }
 return array;
}
该算法的操作次数是⼀个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时
间复杂度是 O(n * n)
归并排序
归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合
并，最终合并为排序好的数组。假设我有⼀组数组 [3, 1, 2, 8, 9, 7, 6] ，中间数索引
是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元
素（如果数组⻓度是奇数的话，会有⼀个拆分数组只包含⼀个元素）。然后排序数组 [3,
1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以
上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。
function selection(array) {
 checkArray(array);
 for (let i = 0; i < array.length - 1; i++) {
 let minIndex = i;
 for (let j = i + 1; j < array.length; j++) {
 minIndex = array[j] < array[minIndex] ? j : minIndex;
 }
 swap(array, i, minIndex);
 }
 return array;
}
以下是实现该算法的代码
function sort(array) {
 checkArray(array);
 mergeSort(array, 0, array.length - 1);
 return array;
}
function mergeSort(array, left, right) {
 // 左右索引相同说明已经只有⼀个数
 if (left === right) return;
 // 等同于 `left + (right - left) / 2`
 // 相⽐ `(left + right) / 2` 来说更加安全，不会溢出
 // 使⽤位运算是因为位运算⽐四则运算快
以上算法使⽤了递归的思想。递归的本质就是压栈，每递归执⾏⼀次函数，就将该函数的信
息（⽐如参数，内部的变量，执⾏到的⾏数）压栈，直到遇到终⽌条件，然后出栈并继续执
⾏函数。对于以上递归函数的调⽤轨迹如下
 let mid = parseInt(left + ((right - left) >> 1));
 mergeSort(array, left, mid);
 mergeSort(array, mid + 1, right);
 let help = [];
 let i = 0;
 let p1 = left;
 let p2 = mid + 1;
 while (p1 <= mid && p2 <= right) {
 help[i++] = array[p1] < array[p2] ? array[p1++] : array[p2++];
 }
 while (p1 <= mid) {
 help[i++] = array[p1++];
 }
 while (p2 <= right) {
 help[i++] = array[p2++];
 }
 for (let i = 0; i < help.length; i++) {
 array[left + i] = help[i];
 }
 return array;
}
mergeSort(data, 0, 6) // mid = 3
 mergeSort(data, 0, 3) // mid = 1
 mergeSort(data, 0, 1) // mid = 0
 mergeSort(data, 0, 0) // 遇到终⽌，回退到上⼀步
 mergeSort(data, 1, 1) // 遇到终⽌，回退到上⼀步
 // 排序 p1 = 0, p2 = mid + 1 = 1
 // 回退到 `mergeSort(data, 0, 3)` 执⾏下⼀个递归
 mergeSort(2, 3) // mid = 2
该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的⼀半，并且最后把整
个数组迭代了⼀次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。
根据该表达式可以套⽤ 该公式 得出时间复杂度为 O(N * logN)
快排
快排的原理如下。随机选取⼀个数组中的值作为基准值，从左⾄右取值与基准值对⽐⼤⼩。
⽐基准值⼩的放数组左边，⼤的放右边，对⽐完成后将基准值和第⼀个⽐基准值⼤的值交换
位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。
以下是实现该算法的代码
 mergeSort(3, 3) // 遇到终⽌，回退到上⼀步
 // 排序 p1 = 2, p2 = mid + 1 = 3
 // 回退到 `mergeSort(data, 0, 3)` 执⾏合并逻辑
 // 排序 p1 = 0, p2 = mid + 1 = 2
 // 执⾏完毕回退
 // 左边数组排序完毕，右边也是如上轨迹
function sort(array) {
 checkArray(array);
 quickSort(array, 0, array.length - 1);
 return array;
}
function quickSort(array, left, right) {
 if (left < right) {
 swap(array, , right)
 // 随机取值，然后和末尾交换，这样做⽐固定取⼀个位置的复杂度略低
 let indexs = part(array, parseInt(Math.random() * (right - left +
1)) + left, right);
 quickSort(array, left, indexs[0]);
 quickSort(array, indexs[1] + 1, right);
 }
}
function part(array, left, right) {
 let less = left - 1;
 let more = right;
 while (left < more) {
 if (array[left] < array[right]) {
 // 当前值⽐基准值⼩，`less` 和 `left` 都加⼀
 ++less;
 ++left;
 } else if (array[left] > array[right]) {
 // 当前值⽐基准值⼤，将当前值和右边的值交换
 // 并且不改变 `left`，因为当前换过来的值还没有判断过⼤⼩
 swap(array, --more, left);
 } else {
 // 和基准值相同，只移动下标
 left++;
 }
 }
 // 将基准值和⽐基准值⼤的第⼀个值交换位置
 // 这样数组就变成 `[⽐基准值⼩, 基准值, ⽐基准值⼤]`
 swap(array, right, more);
 return [less, more];
}
该算法的复杂度和归并排序是相同的，但是额外空间复杂度⽐归并排序少，只需 O(logN)，并
且相⽐归并排序来说，所需的常数时间也更少。
⾯试题
Sort Colors：该题⽬来⾃ LeetCode，题⽬需要我们将 [2,0,2,1,1,0] 排序成
[0,0,1,1,2,2] ，这个问题就可以使⽤三路快排的思想。
以下是代码实现
Kth Largest Element in an Array：该题⽬来⾃ LeetCode，题⽬需要找出数组中第 K ⼤的
元素，这问题也可以使⽤快排的思路。并且因为是找出第 K ⼤元素，所以在分离数组的过程
中，可以找出需要的元素在哪边，然后只需要排序相应的⼀边数组就好。
以下是代码实现
var sortColors = function(nums) {
 let left = -1;
 let right = nums.length;
 let i = 0;
 // 下标如果遇到 right，说明已经排序完成
 while (i < right) {
 if (nums[i] == 0) {
 swap(nums, i++, ++left);
 } else if (nums[i] == 1) {
 i++;
 } else {
 swap(nums, i, --right);
 }
 }
};
var findKthLargest = function(nums, k) {
 let l = 0
 let r = nums.length - 1
 // 得出第 K ⼤元素的索引位置
 k = nums.length - k
 while (l < r) {
 // 分离数组后获得⽐基准树⼤的第⼀个元素索引
 let index = part(nums, l, r)
 // 判断该索引和 k 的⼤⼩
 if (index < k) {
 l = index + 1
 } else if (index > k) {
 r = index - 1
 } else {
 break
 }
 }
 return nums[k]
};
function part(array, left, right) {
 let less = left - 1;
 let more = right;
 while (left < more) {
 if (array[left] < array[right]) {
 ++less;
 ++left;
 } else if (array[left] > array[right]) {
 swap(array, --more, left);
 } else {
 left++;
 }
 }
 swap(array, right, more);
 return more;
}
堆排序
堆排序利⽤了⼆叉堆的特性来做，⼆叉堆通常⽤数组表示，并且⼆叉堆是⼀颗完全⼆叉树
（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。⼆
叉堆⼜分为⼤根堆与⼩根堆。
⼤根堆是某个节点的所有⼦节点的值都⽐他⼩
⼩根堆是某个节点的所有⼦节点的值都⽐他⼤
堆排序的原理就是组成⼀个⼤根堆或者⼩根堆。以⼩根堆为例，某个节点的左边⼦节点索引
是 i * 2 + 1 ，右边是 i * 2 + 2 ，⽗节点是 (i - 1) /2 。
1. ⾸先遍历数组，判断该节点的⽗节点是否⽐他⼩，如果⼩就交换位置并继续判断，直到他
的⽗节点⽐他⼤
2. 重新以上操作 1，直到数组⾸位是最⼤值
3. 然后将⾸位和末尾交换位置并将数组⻓度减⼀，表示数组末尾已是最⼤值，不需要再⽐较
⼤⼩
4. 对⽐左右节点哪个⼤，然后记住⼤的节点的索引并且和⽗节点对⽐⼤⼩，如果⼦节点⼤就
交换位置
5. 重复以上操作 3 - 4 直到整个数组都是⼤根堆。
以下是实现该算法的代码
function heap(array) {
 checkArray(array);
 // 将最⼤值交换到⾸位
 for (let i = 0; i < array.length; i++) {
 heapInsert(array, i);
 }
 let size = array.length;
以上代码实现了⼩根堆，如果需要实现⼤根堆，只需要把节点对⽐反⼀下就好。
该算法的复杂度是 O(logN)
 // 交换⾸位和末尾
 swap(array, 0, --size);
 while (size > 0) {
 heapify(array, 0, size);
 swap(array, 0, --size);
 }
 return array;
}
function heapInsert(array, index) {
 // 如果当前节点⽐⽗节点⼤，就交换
 while (array[index] > array[parseInt((index - 1) / 2)]) {
 swap(array, index, parseInt((index - 1) / 2));
 // 将索引变成⽗节点
 index = parseInt((index - 1) / 2);
 }
}
function heapify(array, index, size) {
 let left = index * 2 + 1;
 while (left < size) {
 // 判断左右节点⼤⼩
 let largest =
 left + 1 < size && array[left] < array[left + 1] ? left + 1 :
left;
 // 判断⼦节点和⽗节点⼤⼩
 largest = array[index] < array[largest] ? largest : index;
 if (largest === index) break;
 swap(array, index, largest);
 index = largest;
 left = index * 2 + 1;
 }
}
系统⾃带排序实现
每个语⾔的排序内部实现都是不同的。
对于 JS 来说，数组⻓度⼤于 10 会采⽤快排，否则使⽤插⼊排序 源码实现 。选择插⼊排序
是因为虽然时间复杂度很差，但是在数据量很⼩的情况下和 O(N * logN) 相差⽆⼏，然⽽插
⼊排序需要的常数时间很⼩，所以相对别的排序来说更快。
对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采⽤稳定性好的
算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。
链表
反转单向链表
该题⽬来⾃ LeetCode，题⽬需要将⼀个单向链表反转。思路很简单，使⽤三个变量分别表示
当前节点和当前节点的前后节点，虽然这题很简单，但是却是⼀道⾯试常考题
以下是实现该算法的代码
树
⼆叉树的先序，中序，后序遍历
先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。
中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。
var reverseList = function(head) {
 // 判断下变量边界问题
 if (!head || !head.next) return head
 // 初始设置为空，因为第⼀个节点反转后就是尾部，尾部节点指向 null
 let pre = null
 let current = head
 let next
 // 判断当前节点是否为空
 // 不为空就先获取当前节点的下⼀节点
 // 然后把当前节点的 next 设为上⼀个节点
 // 然后把 current 设为下⼀个节点，pre 设为当前节点
 while(current) {
 next = current.next
 current.next = pre
 pre = current
 current = next
 }
 return pre
};
后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。
递归实现
递归实现相当简单，代码如下
对于递归的实现来说，只需要理解每个节点都会被访问三次就明⽩为什么这样实现了。
⾮递归实现
⾮递归实现使⽤了栈的结构，通过栈的先进后出模拟递归实现。
以下是先序遍历代码实现
function TreeNode(val) {
 this.val = val;
 this.left = this.right = null;
}
var traversal = function(root) {
 if (root) {
 // 先序
 console.log(root);
 traversal(root.left);
 // 中序
 // console.log(root);
 traversal(root.right);
 // 后序
 // console.log(root);
 }
};
function pre(root) {
 if (root) {
 let stack = [];
 // 先将根节点 push
 stack.push(root);
以下是中序遍历代码实现
 // 判断栈中是否为空
 while (stack.length > 0) {
 // 弹出栈顶元素
 root = stack.pop();
 console.log(root);
 // 因为先序遍历是先左后右，栈是先进后出结构
 // 所以先 push 右边再 push 左边
 if (root.right) {
 stack.push(root.right);
 }
 if (root.left) {
 stack.push(root.left);
 }
 }
 }
}
function mid(root) {
 if (root) {
 let stack = [];
 // 中序遍历是先左再根最后右
 // 所以⾸先应该先把最左边节点遍历到底依次 push 进栈
 // 当左边没有节点时，就打印栈顶元素，然后寻找右节点
 // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的⽗节点
 // 左边打印不出东⻄就把⽗节点拿出来打印，然后再看右节点
 while (stack.length > 0 || root) {
 if (root) {
 stack.push(root);
 root = root.left;
 } else {
 root = stack.pop();
 console.log(root);
 root = root.right;
以下是后序遍历代码实现，该代码使⽤了两个栈来实现遍历，相⽐⼀个栈的遍历来说要容易
理解很多
 }
 }
 }
}
function pos(root) {
 if (root) {
 let stack1 = [];
 let stack2 = [];
 // 后序遍历是先左再右最后根
 // 所以对于⼀个栈来说，应该先 push 根节点
 // 然后 push 右节点，最后 push 左节点
 stack1.push(root);
 while (stack1.length > 0) {
 root = stack1.pop();
 stack2.push(root);
 if (root.left) {
 stack1.push(root.left);
 }
 if (root.right) {
 stack1.push(root.right);
 }
 }
 while (stack2.length > 0) {
 console.log(s2.pop());
 }
 }
}
中序遍历的前驱后继节点
实现这个算法的前提是节点有⼀个 parent 的指针指向⽗节点，根节点指向 null 。
如图所示，该树的中序遍历结果是 4, 2, 5, 1, 6, 3, 7
前驱节点
对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论
1. 如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左
节点 2 ，那么节点 2 的最右节点就是 5
2. 如果左节点为空，且⽬标节点是⽗节点的右节点，那么前驱节点为⽗节点。对于节点 5
来说，没有左节点，且是节点 2 的右节点，所以节点 2 是前驱节点
3. 如果左节点为空，且⽬标节点是⽗节点的左节点，向上寻找到第⼀个是⽗节点的右节点的
节点。对于节点 6 来说，没有左节点，且是节点 3 的左节点，所以向上寻找到节点 1
，发现节点 3 是节点 1 的右节点，所以节点 1 是节点 6 的前驱节点
以下是算法实现
function predecessor(node) {
 if (!node) return
 // 结论 1
 if (node.left) {
 return getRight(node.left)
后继节点
对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论
1. 如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么
节点 3 的最左节点就是 6
2. 如果没有右节点，就向上遍历直到找到⼀个节点是⽗节点的左节点。对于节点 5 来说，
没有右节点，就向上寻找到节点 2 ，该节点是⽗节点 1 的左节点，所以节点 1 是后
继节点
以下是算法实现
 } else {
 let parent = node.parent
 // 结论 2 3 的判断
 while(parent && parent.right === node) {
 node = parent
 parent = node.parent
 }
 return parent
 }
}
function getRight(node) {
 if (!node) return
 node = node.right
 while(node) node = node.right
 return node
}
function successor(node) {
 if (!node) return
 // 结论 1
 if (node.right) {
 return getLeft(node.right)
 } else {
树的深度
树的最⼤深度：该题⽬来⾃ Leetcode，题⽬需要求出⼀颗⼆叉树的最⼤深度
以下是算法实现
对于该递归函数可以这样理解：⼀旦没有找到节点就会返回 0，每弹出⼀次递归函数就会加
⼀，树有三层就会得到3。
 // 结论 2
 let parent = node.parent
 // 判断 parent 为空
 while(parent && parent.left === node) {
 node = parent
 parent = node.parent
 }
 return parent
 }
}
function getLeft(node) {
 if (!node) return
 node = node.left
 while(node) node = node.left
 return node
}
var maxDepth = function(root) {
 if (!root) return 0
 return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
};
动态规划
动态规划背后的基本思想⾮常简单。就是将⼀个问题拆分为⼦问题，⼀般来说这些⼦问题都
是⾮常相似的，那么我们可以通过只解决⼀次每个⼦问题来达到减少计算量的⽬的。
⼀旦得出每个⼦问题的解，就存储该结果以便下次使⽤。
斐波那契数列
斐波那契数列就是从 0 和 1 开始，后⾯的数都是前两个数之和
0，1，1，2，3，5，8，13，21，34，55，89....
那么显然易⻅，我们可以通过递归的⽅式来完成求解斐波那契数列
以上代码已经可以完美的解决问题。但是以上解法却存在很严重的性能问题，当 n 越⼤的时
候，需要的时间是指数增⻓的，这时候就可以通过动态规划来解决这个问题。
动态规划的本质其实就是两点
1. ⾃底向上分解⼦问题
2. 通过变量存储已经计算过的解
根据上⾯两点，我们的斐波那契数列的动态规划思路也就出来了
1. 斐波那契数列从 0 和 1 开始，那么这就是这个⼦问题的最底层
2. 通过数组来存储每⼀位所对应的斐波那契数列的值
function fib(n) {
 if (n < 2 && n >= 0) return n
 return fib(n - 1) + fib(n - 2)
}
fib(10)
物品 ID / 重量 价值
1 3
2 7
3 12
0 - 1背包问题
该问题可以描述为：给定⼀组物品，每种物品都有⾃⼰的重量和价格，在限定的总重量内，
我们如何选择，才能使得物品的总价格最⾼。每个问题只能放⼊⾄多⼀次。
假设我们有以下物品
对于⼀个总容量为 5 的背包来说，我们可以放⼊重量 2 和 3 的物品来达到背包内的物品总价
值最⾼。
对于这个问题来说，⼦问题就两个，分别是放物品和不放物品，可以通过以下表格来理解⼦
问题
function fib(n) {
 let array = new Array(n + 1).fill(null)
 array[0] = 0
 array[1] = 1
 for (let i = 2; i <= n; i++) {
 array[i] = array[i - 1] + array[i - 2]
 }
 return array[n]
}
fib(10)
物品 ID / 剩余容量 0 1 2 3 4 5
1 0 3 3 3 3 3
2 0 3 7 10 10 10
3 0 3 7 12 15 19
直接来分析能放三种物品的情况，也就是最后⼀⾏
当容量少于 3 时，只取上⼀⾏对应的数据，因为当前容量不能容纳物品 3
当容量 为 3 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
不放物品 3 的情况下，总价值为 10
放⼊物品 3 的情况下，总价值为 12，所以应该放⼊物品 3
当容量 为 4 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
不放物品 3 的情况下，总价值为 10
放⼊物品 3 的情况下，和放⼊物品 1 的价值相加，得出总价值为 15，所以应该放⼊
物品 3
当容量 为 5 时，考虑两种情况，分别为放⼊物品 3 和不放物品 3
不放物品 3 的情况下，总价值为 10
放⼊物品 3 的情况下，和放⼊物品 2 的价值相加，得出总价值为 19，所以应该放⼊
物品 3
以下代码对照上表更容易理解
/**
 * @param {*} w 物品重量
 * @param {*} v 物品价值
 * @param {*} C 总容量
 * @returns
 */
function knapsack(w, v, C) {
 let length = w.length
 if (length === 0) return 0
 // 对照表格，⽣成的⼆维数组，第⼀维代表物品，第⼆维代表背包剩余容量
最⻓递增⼦序列
最⻓递增⼦序列意思是在⼀组数字中，找出最⻓⼀串递增的数字，⽐如
0, 3, 4, 17, 2, 8, 6, 10
对于以上这串数字来说，最⻓递增⼦序列就是 0, 3, 4, 8, 10，可以通过以下表格更清晰的理解
 // 第⼆维中的元素代表背包物品总价值
 let array = new Array(length).fill(new Array(C + 1).fill(null))
 // 完成底部⼦问题的解
 for (let i = 0; i <= C; i++) {
 // 对照表格第⼀⾏， array[0] 代表物品 1
 // i 代表剩余总容量
 // 当剩余总容量⼤于物品 1 的重量时，记录下背包物品总价值，否则价值为 0
 array[0][i] = i >= w[0] ? v[0] : 0
 }
 // ⾃底向上开始解决⼦问题，从物品 2 开始
 for (let i = 1; i < length; i++) {
 for (let j = 0; j <= C; j++) {
 // 这⾥求解⼦问题，分别为不放当前物品和放当前物品
 // 先求不放当前物品的背包总价值，这⾥的值也就是对应表格中上⼀⾏对应的值
 array[i][j] = array[i - 1][j]
 // 判断当前剩余容量是否可以放⼊当前物品
 if (j >= w[i]) {
 // 可以放⼊的话，就⽐⼤⼩
 // 放⼊当前物品和不放⼊当前物品，哪个背包总价值⼤
 array[i][j] = Math.max(array[i][j], v[i] + array[i - 1][j -
w[i]])
 }
 }
 }
 return array[length - 1][C]
}
数字 0 3 4 17 2 8 6 10
⻓度 1 2 3 4 2 4 4 5
通过以上表格可以很清晰的发现⼀个规律，找出刚好⽐当前数字⼩的数，并且在⼩的数组成
的⻓度基础上加⼀。
这个问题的动态思路解法很简单，直接上代码
字符串相关
在字符串相关算法中，Trie 树可以解决解决很多问题，同时具备良好的空间和时间复杂度，⽐
如以下问题
词频统计
function lis(n) {
 if (n.length === 0) return 0
 // 创建⼀个和参数相同⼤⼩的数组，并填充值为 1
 let array = new Array(n.length).fill(1)
 // 从索引 1 开始遍历，因为数组已经所有都填充为 1 了
 for (let i = 1; i < n.length; i++) {
 // 从索引 0 遍历到 i
 // 判断索引 i 上的值是否⼤于之前的值
 for (let j = 0; j < i; j++) {
 if (n[i] > n[j]) {
 array[i] = Math.max(array[i], 1 + array[j])
 }
 }
 }
 let res = 1
 for (let i = 0; i < array.length; i++) {
 res = Math.max(res, array[i])
 }
 return res
}
前缀匹配
如果你对于 Trie 树还不怎么了解，可以前往 这⾥ 阅读
Git 章节
本⽂不会介绍 Git 的基本操作，会对⼀些⾼级操作进⾏说明。
Rebase 合并
该命令可以让和 merge 命令得到的结果基本是⼀致的。
通常使⽤ merge 操作将分⽀上的代码合并到 master 中，分⽀样⼦如下所示
使⽤ rebase 后，会将 develop 上的 commit 按顺序移到 master 的第三个 commit 后
⾯，分⽀样⼦如下所示
Rebase 对⽐ merge，优势在于合并后的结果很清晰，只有⼀条线，劣势在于如果⼀旦出现冲
突，解决冲突很麻烦，可能要解决多个冲突，但是 merge 出现冲突只需要解决⼀次。
使⽤ rebase 应该在需要被 rebase 的分⽀上操作，并且该分⽀是本地分⽀。如果 develop
分⽀需要 rebase 到 master 上去，那么应该如下操作
stash
stash ⽤于临时保存⼯作⽬录的改动。开发中可能会遇到代码写⼀半需要切分⽀打包的问
题，如果这时候你不想 commit 的话，就可以使⽤该命令。
使⽤该命令可以暂存你的⼯作⽬录，后⾯想恢复⼯作⽬录，只需要使⽤
这样你之前临时保存的代码⼜回来了
reflog
reflog 可以看到 HEAD 的移动记录，假如之前误删了⼀个分⽀，可以通过 git reflog 看
到移动 HEAD 的哈希值
从图中可以看出，HEAD 的最后⼀次移动⾏为是 merge 后，接下来分⽀ new 就被删除了，
那么我们可以通过以下命令找回 new 分⽀
## branch develop
git rebase master
git checkout master
## ⽤于将 `master` 上的 HEAD 移动到最新的 commit
git merge develop
git stash
git stash pop
git checkout 37d9aca
git checkout -b new
PS： reflog 记录是时效的，只会保存⼀段时间内的记录。
Reset
如果你想删除刚写的 commit，就可以通过以下命令实现
但是 reset 的本质并不是删除了 commit，⽽是重新设置了 HEAD 和它指向的 branch。
职业章节
你是否时常会焦虑时间过的很快，没时间学习，本⽂将会分享⼀些个⼈的⻅解。
花时间补基础，读⽂档
在⼯作中我们时常会花很多时间去 debug，但是你是否发现很多问题最终只是你基础不扎实
或者⽂档没有仔细看。
基础是你技术的基⽯，⼀定要花时间打好基础，⽽不是追各种新的技术。⼀旦你的基础扎
实，学习各种新的技术也肯定不在话下，因为新的技术，究其根本都是相通的。
⽂档同样也是⼀⻔技术的基础。⼀个优秀的库，开发⼈员肯定已经把如何使⽤这个库都写在
⽂档中了，仔细阅读⽂档⼀定会是少写 bug 的最省事路⼦。
学会搜索
如果你还在使⽤百度搜索编程问题，请尽快抛弃这个垃圾搜索引擎。同样⼀个关键字，使⽤
百度和⾕歌，⾕歌基本完胜的。即使你使⽤中⽂在⾕歌中搜索，得到的结果也往往是⾕歌占
优，所以如果你想迅速的通过搜索引擎来解决问题，那⼀定是⾕歌。
git reset --hard HEAD^
学点英语
说到英语，⼀定是⼤家所最不想听的。其实我⼀直认为程序员学习英语是简单的，因为我们
⼯作中是⼀直接触着英语，并且看懂技术⽂章，⽂档所需要的单词量是极少的。我时常在群
⾥看到⼤家发出⼀个问题的截图问什么原因，其实在截图中英语已经很明⽩的说明了问题的
所在，如果你的英语过关，完全不需要浪费时间来提问和搜索。所以我认为学点英语也是节
省时间中很重要的⼀点。
那么如何去学习呢，chrome 装个翻译插件，直接拿英⽂⽂档或⽂章读，不会的就直接划词翻
译，然后记录下这个单词并背诵。每天花半⼩时看点英⽂⽂档和⽂章，坚持两个⽉，你的英
语⽔平不说别的，看⽂档和⽂章绝对不会有难题了。这⼀定是⼀个很划算的个⼈时间投资，
花点时间学习英语，能为你将来的技术之路铺平很多坎。
画个图，想⼀想再做
你是否遇到过这种问题，需求⼀下来，看⼀眼，然后⻢上就按照设计稿开始做了，可能中间
出个问题导致你需要返⼯。
如果你存在这样的问题，我很推荐在看到设计稿和需求的时候花点时间想⼀想，画⼀画。考
虑⼀下设计稿中是否可以找到可以拆分出来的复⽤组件，是否存在之前写过的组件。该如何
组织这个界⾯，数据的流转是怎么样的。然后画⼀下这个⻚⾯的需求，最后再动⼿做。
利⽤好下班时间学习
说到下班时间，那可能就有⼈说了公司很迟下班，这其实是国内很普遍的情况。但是我认为
正常的加班是可以的，但是强制的加班就是在损耗你的身体和前途。
可以这么说，⼤部分的 996 公司，加班的这些时间并不会增加你的技术，⽆⾮就是在写⼀些
重复的业务逻辑。也许你可以拿到更多的钱，但是代价是身体还有前途。程序员是靠技术吃
饭的，如果你⻓久呆在⼀个⻓时间加班的公司，不能增⻓你的技术还要吞噬你的下班学习时
间，那么你⼀定会废掉的。如果你遇到了这种情况，只能推荐尽快跳槽到⾮ 996 的公司。
那么如果你有⾜够的下班时间，⼀定要花上 1， 2 ⼩时去学习，上班⼤家基本都⼀样，技术
的精进就是看下班以后的那⼏个⼩时了。如果你能利⽤好下班时间来学习，坚持下去，时间
⼀定会给你很好的答复。
列好 ToDo
我喜欢规划好⼀段时间内要做的事情，并且要把事情拆分为⼩点。给 ToDo 列好优先级，紧急
的优先级最⾼。相同优先级的我喜欢先做简单的，因为这样⼀旦完成就能划掉⼀个，提⾼成
就感。
反思和整理
每周末都会花上点时间整理下本周记录的笔记和看到的不错⽂章。然后考虑下本周完成的⼯
作和下周准备要完成的⼯作。]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[toString方法和valueOf方法以及Symbol.toPrimitive方法的学习]]></title>
        <id>https://coderdml.github.io/post/tostring-fang-fa-he-valueof-fang-fa-yi-ji-symboltoprimitive-fang-fa-de-xue-xi/</id>
        <link href="https://coderdml.github.io/post/tostring-fang-fa-he-valueof-fang-fa-yi-ji-symboltoprimitive-fang-fa-de-xue-xi/">
        </link>
        <updated>2023-03-17T04:16:15.000Z</updated>
        <content type="html"><![CDATA[<p>https://segmentfault.com/a/1190000016300245</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vscode使用中的卡顿问题]]></title>
        <id>https://coderdml.github.io/post/vscode-shi-yong-zhong-de-qia-dun-wen-ti/</id>
        <link href="https://coderdml.github.io/post/vscode-shi-yong-zhong-de-qia-dun-wen-ti/">
        </link>
        <updated>2023-03-07T19:55:13.000Z</updated>
        <content type="html"><![CDATA[<p>关闭Git:autorefresh选项</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vscode用tab键无法自动补全代码]]></title>
        <id>https://coderdml.github.io/post/vscode-yong-tab-jian-wu-fa-zi-dong-bu-quan-dai-ma/</id>
        <link href="https://coderdml.github.io/post/vscode-yong-tab-jian-wu-fa-zi-dong-bu-quan-dai-ma/">
        </link>
        <updated>2023-03-04T17:39:24.000Z</updated>
        <content type="html"><![CDATA[<p>vscode用tab键无法自动补全代码<br>
点左下角的设置，在输入框中输入tab，修改默认值即可，如下图：<br>
<img src="https://coderdml.github.io/post-images/1677951594170.png" alt="" loading="lazy"><br>
出现问题的时候我去查找，发现很多都让安装auto close tag这个插件，我后面安装了也没啥用，照样无法补全。有看到大哥说vscode本来就内嵌了emmet，可以自动补全，不需要安装插件。后面解决了，我卸载了auto close tag这个插件试试有没有影响，发现也没啥影响，照样可以补全。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue1]]></title>
        <id>https://coderdml.github.io/post/vue1/</id>
        <link href="https://coderdml.github.io/post/vue1/">
        </link>
        <updated>2023-03-04T16:57:07.000Z</updated>
        <content type="html"><![CDATA[<p>1.什么是渐进式框架<br>
渐进式意味着可以把vue作为应用的一部分嵌入进去<br>
vue的核心库及其生态系统也可以实现更多的业务逻辑<br>
2.vue的特点和web开发中的高级功能<br>
解耦视图和数据<br>
可复用的组件<br>
前端路由技术<br>
状态管理<br>
虚拟dom<br>
3.什么是MVVM框架<br>
Model View ViesModle<br>
4.v-on的修饰符<br>
5.vue中input标签的复用解决方法，加属性key</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[任务目标]]></title>
        <id>https://coderdml.github.io/post/ren-wu-mu-biao/</id>
        <link href="https://coderdml.github.io/post/ren-wu-mu-biao/">
        </link>
        <updated>2023-02-23T11:23:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.复习一遍VUE项目<br>
2.前端工程化<br>
3.Git、js课程<br>
4.nodejs、typscript<br>
5.背面试题<br>
6.投简历的同时学html和css</p>
]]></content>
    </entry>
</feed>